/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(2);\nvar isBuffer = __webpack_require__(12);\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzPzcwNjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLEdBQUcsU0FBUztBQUM1QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(0);\nvar normalizeHeaderName = __webpack_require__(15);\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(3);\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(3);\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzPzI4MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IitDQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVk7QUFDbkI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcz8yNGZmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar settle = __webpack_require__(16);\nvar buildURL = __webpack_require__(18);\nvar parseHeaders = __webpack_require__(19);\nvar isURLSameOrigin = __webpack_require__(20);\nvar createError = __webpack_require__(4);\nvar btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(21);\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (\"development\" !== 'test' &&\n        typeof window !== 'undefined' &&\n        window.XDomainRequest && !('withCredentials' in request) &&\n        !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || (request.readyState !== 4 && !xDomain)) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(22);\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcz9lYzZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar enhanceError = __webpack_require__(17);\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanM/MTZkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcz9hNDFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanM/NzU1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(8);
__webpack_require__(32);
module.exports = __webpack_require__(33);


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(9);\n__webpack_require__(31);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FwcC5qcz9iMTVmIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFBQSxDQUFRLENBQVI7QUFDQSxtQkFBQUEsQ0FBUSxFQUFSIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2Jvb3RzdHJhcCcpO1xyXG5yZXF1aXJlKCcuL2FuaW1hdGlvbicpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * We'll load the axios HTTP library which allows us to easily issue requests\r\n * to our Laravel back-end. This library automatically handles sending the\r\n * CSRF token as a header based on the value of the \"XSRF\" token cookie.\r\n */\n\nwindow.axios = __webpack_require__(10);\nwindow.mojs = __webpack_require__(30);\n\nwindow.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';\n\n/**\r\n * Next we will register the CSRF Token as a common header with Axios so that\r\n * all outgoing HTTP requests automatically have it attached. This is just\r\n * a simple convenience so we don't have to attach every token manually.\r\n */\n\nvar token = document.head.querySelector('meta[name=\"csrf-token\"]');\n\nif (token) {\n  window.axios.defaults.headers.common['X-CSRF-TOKEN'] = token.content;\n} else {\n  console.error('CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token');\n}\n\n/**\r\n * Echo exposes an expressive API for subscribing to channels and listening\r\n * for events that are broadcast by Laravel. Echo and event broadcasting\r\n * allows your team to easily build robust real-time web applications.\r\n */\n\n// import Echo from 'laravel-echo'\n\n// window.Pusher = require('pusher-js');\n\n// window.Echo = new Echo({\n//     broadcaster: 'pusher',\n//     key: process.env.MIX_PUSHER_APP_KEY,\n//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n//     encrypted: true\n// });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2Jvb3RzdHJhcC5qcz81OTExIl0sIm5hbWVzIjpbIndpbmRvdyIsImF4aW9zIiwicmVxdWlyZSIsIm1vanMiLCJkZWZhdWx0cyIsImhlYWRlcnMiLCJjb21tb24iLCJ0b2tlbiIsImRvY3VtZW50IiwiaGVhZCIsInF1ZXJ5U2VsZWN0b3IiLCJjb250ZW50IiwiY29uc29sZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBTUFBLE9BQU9DLEtBQVAsR0FBZSxtQkFBQUMsQ0FBUSxFQUFSLENBQWY7QUFDQUYsT0FBT0csSUFBUCxHQUFjLG1CQUFBRCxDQUFRLEVBQVIsQ0FBZDs7QUFFQUYsT0FBT0MsS0FBUCxDQUFhRyxRQUFiLENBQXNCQyxPQUF0QixDQUE4QkMsTUFBOUIsQ0FBcUMsa0JBQXJDLElBQTJELGdCQUEzRDs7QUFFQTs7Ozs7O0FBTUEsSUFBSUMsUUFBUUMsU0FBU0MsSUFBVCxDQUFjQyxhQUFkLENBQTRCLHlCQUE1QixDQUFaOztBQUVBLElBQUlILEtBQUosRUFBVztBQUNQUCxTQUFPQyxLQUFQLENBQWFHLFFBQWIsQ0FBc0JDLE9BQXRCLENBQThCQyxNQUE5QixDQUFxQyxjQUFyQyxJQUF1REMsTUFBTUksT0FBN0Q7QUFDSCxDQUZELE1BRU87QUFDSEMsVUFBUUMsS0FBUixDQUFjLHVFQUFkO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFdlJ2xsIGxvYWQgdGhlIGF4aW9zIEhUVFAgbGlicmFyeSB3aGljaCBhbGxvd3MgdXMgdG8gZWFzaWx5IGlzc3VlIHJlcXVlc3RzXHJcbiAqIHRvIG91ciBMYXJhdmVsIGJhY2stZW5kLiBUaGlzIGxpYnJhcnkgYXV0b21hdGljYWxseSBoYW5kbGVzIHNlbmRpbmcgdGhlXHJcbiAqIENTUkYgdG9rZW4gYXMgYSBoZWFkZXIgYmFzZWQgb24gdGhlIHZhbHVlIG9mIHRoZSBcIlhTUkZcIiB0b2tlbiBjb29raWUuXHJcbiAqL1xyXG5cclxud2luZG93LmF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcclxud2luZG93Lm1vanMgPSByZXF1aXJlKCdtby1qcycpO1xyXG5cclxud2luZG93LmF4aW9zLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnO1xyXG5cclxuLyoqXHJcbiAqIE5leHQgd2Ugd2lsbCByZWdpc3RlciB0aGUgQ1NSRiBUb2tlbiBhcyBhIGNvbW1vbiBoZWFkZXIgd2l0aCBBeGlvcyBzbyB0aGF0XHJcbiAqIGFsbCBvdXRnb2luZyBIVFRQIHJlcXVlc3RzIGF1dG9tYXRpY2FsbHkgaGF2ZSBpdCBhdHRhY2hlZC4gVGhpcyBpcyBqdXN0XHJcbiAqIGEgc2ltcGxlIGNvbnZlbmllbmNlIHNvIHdlIGRvbid0IGhhdmUgdG8gYXR0YWNoIGV2ZXJ5IHRva2VuIG1hbnVhbGx5LlxyXG4gKi9cclxuXHJcbmxldCB0b2tlbiA9IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpO1xyXG5cclxuaWYgKHRva2VuKSB7XHJcbiAgICB3aW5kb3cuYXhpb3MuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtQ1NSRi1UT0tFTiddID0gdG9rZW4uY29udGVudDtcclxufSBlbHNlIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0NTUkYgdG9rZW4gbm90IGZvdW5kOiBodHRwczovL2xhcmF2ZWwuY29tL2RvY3MvY3NyZiNjc3JmLXgtY3NyZi10b2tlbicpO1xyXG59XHJcblxyXG4vKipcclxuICogRWNobyBleHBvc2VzIGFuIGV4cHJlc3NpdmUgQVBJIGZvciBzdWJzY3JpYmluZyB0byBjaGFubmVscyBhbmQgbGlzdGVuaW5nXHJcbiAqIGZvciBldmVudHMgdGhhdCBhcmUgYnJvYWRjYXN0IGJ5IExhcmF2ZWwuIEVjaG8gYW5kIGV2ZW50IGJyb2FkY2FzdGluZ1xyXG4gKiBhbGxvd3MgeW91ciB0ZWFtIHRvIGVhc2lseSBidWlsZCByb2J1c3QgcmVhbC10aW1lIHdlYiBhcHBsaWNhdGlvbnMuXHJcbiAqL1xyXG5cclxuLy8gaW1wb3J0IEVjaG8gZnJvbSAnbGFyYXZlbC1lY2hvJ1xyXG5cclxuLy8gd2luZG93LlB1c2hlciA9IHJlcXVpcmUoJ3B1c2hlci1qcycpO1xyXG5cclxuLy8gd2luZG93LkVjaG8gPSBuZXcgRWNobyh7XHJcbi8vICAgICBicm9hZGNhc3RlcjogJ3B1c2hlcicsXHJcbi8vICAgICBrZXk6IHByb2Nlc3MuZW52Lk1JWF9QVVNIRVJfQVBQX0tFWSxcclxuLy8gICAgIGNsdXN0ZXI6IHByb2Nlc3MuZW52Lk1JWF9QVVNIRVJfQVBQX0NMVVNURVIsXHJcbi8vICAgICBlbmNyeXB0ZWQ6IHRydWVcclxuLy8gfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvYm9vdHN0cmFwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(11);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanM/OWFkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar bind = __webpack_require__(2);\nvar Axios = __webpack_require__(13);\nvar defaults = __webpack_require__(1);\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(6);\naxios.CancelToken = __webpack_require__(28);\naxios.isCancel = __webpack_require__(5);\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(29);\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzP2I0ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzPzQ1ZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar defaults = __webpack_require__(1);\nvar utils = __webpack_require__(0);\nvar InterceptorManager = __webpack_require__(23);\nvar dispatchRequest = __webpack_require__(24);\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanM/NWU2NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0NBQWtDLGNBQWM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHttZXRob2Q6ICdnZXQnfSwgdGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzViNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcz9lNTU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createError = __webpack_require__(4);\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzP2RiNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgLy8gTm90ZTogc3RhdHVzIGlzIG5vdCBleHBvc2VkIGJ5IFhEb21haW5SZXF1ZXN0XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzP2I3Y2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICByZXR1cm4gZXJyb3I7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/MGQwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzP2EwOTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixlQUFlOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzPzE4NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error;\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n    // initialize result and counter\n    var block, charCode, idx = 0, map = chars;\n    // if the next str index does not exist:\n    //   change the mapping table to \"=\"\n    //   check if d has no fractional digits\n    str.charAt(idx | 0) || (map = '=', idx % 1);\n    // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n    output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n  ) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nmodule.exports = btoa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcz9iNjEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mdW5jdGlvbiBFKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyJztcbn1cbkUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuRS5wcm90b3R5cGUuY29kZSA9IDU7XG5FLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbmZ1bmN0aW9uIGJ0b2EoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yIChcbiAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAgIC8vIGlmIHRoZSBuZXh0IHN0ciBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICBzdHIuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICkge1xuICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcbiAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICB0aHJvdyBuZXcgRSgpO1xuICAgIH1cbiAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcz9hNzU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsT0FBTzs7QUFFUDtBQUNBLDBEQUEwRCx3QkFBd0I7QUFDbEY7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsNkJBQTZCLGFBQWEsRUFBRTtBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzPzdlZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\nvar transformData = __webpack_require__(25);\nvar isCancel = __webpack_require__(5);\nvar defaults = __webpack_require__(1);\nvar isAbsoluteURL = __webpack_require__(26);\nvar combineURLs = __webpack_require__(27);\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzP2M0YmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(0);\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcz80Y2Q1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLE1BQU07QUFDakIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcz83NDhjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanM/YTkxNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Cancel = __webpack_require__(6);\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcz83MTZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzP2E3MTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"mojs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mojs\"] = factory();\n\telse\n\t\troot[\"mojs\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"build/\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(3);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _shapesMap = __webpack_require__(72);\n\n\tvar _shapesMap2 = _interopRequireDefault(_shapesMap);\n\n\tvar _shape = __webpack_require__(94);\n\n\tvar _shape2 = _interopRequireDefault(_shape);\n\n\tvar _shapeSwirl = __webpack_require__(117);\n\n\tvar _shapeSwirl2 = _interopRequireDefault(_shapeSwirl);\n\n\tvar _burst = __webpack_require__(118);\n\n\tvar _burst2 = _interopRequireDefault(_burst);\n\n\tvar _html = __webpack_require__(119);\n\n\tvar _html2 = _interopRequireDefault(_html);\n\n\tvar _stagger = __webpack_require__(127);\n\n\tvar _stagger2 = _interopRequireDefault(_stagger);\n\n\tvar _spriter = __webpack_require__(128);\n\n\tvar _spriter2 = _interopRequireDefault(_spriter);\n\n\tvar _motionPath = __webpack_require__(129);\n\n\tvar _motionPath2 = _interopRequireDefault(_motionPath);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _tweener = __webpack_require__(102);\n\n\tvar _tweener2 = _interopRequireDefault(_tweener);\n\n\tvar _tweenable = __webpack_require__(100);\n\n\tvar _tweenable2 = _interopRequireDefault(_tweenable);\n\n\tvar _thenable = __webpack_require__(99);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tvar _tunable = __webpack_require__(116);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tvar _delta = __webpack_require__(126);\n\n\tvar _delta2 = _interopRequireDefault(_delta);\n\n\tvar _deltas = __webpack_require__(125);\n\n\tvar _deltas2 = _interopRequireDefault(_deltas);\n\n\tvar _module = __webpack_require__(84);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tvar _easing = __webpack_require__(105);\n\n\tvar _easing2 = _interopRequireDefault(_easing);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar mojs = {\n\t  revision: '0.288.2', isDebug: true, helpers: _h2.default,\n\t  Shape: _shape2.default, ShapeSwirl: _shapeSwirl2.default, Burst: _burst2.default, Html: _html2.default, stagger: _stagger2.default, Spriter: _spriter2.default, MotionPath: _motionPath2.default,\n\t  Tween: _tween2.default, Timeline: _timeline2.default, Tweenable: _tweenable2.default, Thenable: _thenable2.default, Tunable: _tunable2.default, Module: _module2.default,\n\t  tweener: _tweener2.default, easing: _easing2.default, shapesMap: _shapesMap2.default, _pool: { Delta: _delta2.default, Deltas: _deltas2.default }\n\t};\n\n\t// functions alias\n\tmojs.h = mojs.helpers;\n\tmojs.delta = mojs.h.delta;\n\t// custom shape add function and class\n\tmojs.addShape = mojs.shapesMap.addShape;\n\tmojs.CustomShape = mojs.shapesMap.custom;\n\t// module alias\n\tmojs.Transit = mojs.Shape;\n\tmojs.Swirl = mojs.ShapeSwirl;\n\n\t// TODO:\n\t/*\n\t  H/V in paths\n\n\t  rand for direction\n\t  burst children angle after tune\n\t  burst pathScale after tune\n\t  swirl then issue\n\t  'rand' angle flick with `then`\n\t  not able to `play()` in `onComplete` callback\n\t  ---\n\t  module names\n\t  swirls in then chains for x/y\n\t  parse rand(stagger(20, 10), 20) values\n\t  percentage for radius\n\t*/\n\n\t// istanbul ignore next\n\tif (true) {\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t    return mojs;\n\t  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t// istanbul ignore next\n\tif (( false ? 'undefined' : (0, _typeof3.default)(module)) === \"object\" && (0, _typeof3.default)(module.exports) === \"object\") {\n\t  module.exports = mojs;\n\t}\n\n\texports.default = mojs;\n\n\n\ttypeof window !== 'undefined' && (window.mojs = mojs);\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _iterator = __webpack_require__(4);\n\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\n\tvar _symbol = __webpack_require__(55);\n\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(5), __esModule: true };\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(6);\n\t__webpack_require__(50);\n\tmodule.exports = __webpack_require__(54).f('iterator');\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(7)(true);\n\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(10)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(8)\n\t  , defined   = __webpack_require__(9);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(11)\n\t  , $export        = __webpack_require__(12)\n\t  , redefine       = __webpack_require__(27)\n\t  , hide           = __webpack_require__(17)\n\t  , has            = __webpack_require__(28)\n\t  , Iterators      = __webpack_require__(29)\n\t  , $iterCreate    = __webpack_require__(30)\n\t  , setToStringTag = __webpack_require__(46)\n\t  , getPrototypeOf = __webpack_require__(48)\n\t  , ITERATOR       = __webpack_require__(47)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\n\tvar returnThis = function(){ return this; };\n\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(13)\n\t  , core      = __webpack_require__(14)\n\t  , ctx       = __webpack_require__(15)\n\t  , hide      = __webpack_require__(17)\n\t  , PROTOTYPE = 'prototype';\n\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(16);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(18)\n\t  , createDesc = __webpack_require__(26);\n\tmodule.exports = __webpack_require__(22) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(19)\n\t  , IE8_DOM_DEFINE = __webpack_require__(21)\n\t  , toPrimitive    = __webpack_require__(25)\n\t  , dP             = Object.defineProperty;\n\n\texports.f = __webpack_require__(22) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(20);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(22) && !__webpack_require__(23)(function(){\n\t  return Object.defineProperty(__webpack_require__(24)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(23)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(20)\n\t  , document = __webpack_require__(13).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(20);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(17);\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(31)\n\t  , descriptor     = __webpack_require__(26)\n\t  , setToStringTag = __webpack_require__(46)\n\t  , IteratorPrototype = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(17)(IteratorPrototype, __webpack_require__(47)('iterator'), function(){ return this; });\n\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(19)\n\t  , dPs         = __webpack_require__(32)\n\t  , enumBugKeys = __webpack_require__(44)\n\t  , IE_PROTO    = __webpack_require__(41)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(24)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(45).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(18)\n\t  , anObject = __webpack_require__(19)\n\t  , getKeys  = __webpack_require__(33);\n\n\tmodule.exports = __webpack_require__(22) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(34)\n\t  , enumBugKeys = __webpack_require__(44);\n\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(28)\n\t  , toIObject    = __webpack_require__(35)\n\t  , arrayIndexOf = __webpack_require__(38)(false)\n\t  , IE_PROTO     = __webpack_require__(41)('IE_PROTO');\n\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(36)\n\t  , defined = __webpack_require__(9);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(37);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\n\tvar toString = {}.toString;\n\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(35)\n\t  , toLength  = __webpack_require__(39)\n\t  , toIndex   = __webpack_require__(40);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(8)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(8)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(42)('keys')\n\t  , uid    = __webpack_require__(43);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(13)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(13).document && document.documentElement;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(18).f\n\t  , has = __webpack_require__(28)\n\t  , TAG = __webpack_require__(47)('toStringTag');\n\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(42)('wks')\n\t  , uid        = __webpack_require__(43)\n\t  , Symbol     = __webpack_require__(13).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\n\t$exports.store = store;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(28)\n\t  , toObject    = __webpack_require__(49)\n\t  , IE_PROTO    = __webpack_require__(41)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(9);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(51);\n\tvar global        = __webpack_require__(13)\n\t  , hide          = __webpack_require__(17)\n\t  , Iterators     = __webpack_require__(29)\n\t  , TO_STRING_TAG = __webpack_require__(47)('toStringTag');\n\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(52)\n\t  , step             = __webpack_require__(53)\n\t  , Iterators        = __webpack_require__(29)\n\t  , toIObject        = __webpack_require__(35);\n\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(10)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(47);\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(56), __esModule: true };\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(57);\n\t__webpack_require__(68);\n\t__webpack_require__(69);\n\t__webpack_require__(70);\n\tmodule.exports = __webpack_require__(14).Symbol;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(13)\n\t  , has            = __webpack_require__(28)\n\t  , DESCRIPTORS    = __webpack_require__(22)\n\t  , $export        = __webpack_require__(12)\n\t  , redefine       = __webpack_require__(27)\n\t  , META           = __webpack_require__(58).KEY\n\t  , $fails         = __webpack_require__(23)\n\t  , shared         = __webpack_require__(42)\n\t  , setToStringTag = __webpack_require__(46)\n\t  , uid            = __webpack_require__(43)\n\t  , wks            = __webpack_require__(47)\n\t  , wksExt         = __webpack_require__(54)\n\t  , wksDefine      = __webpack_require__(59)\n\t  , keyOf          = __webpack_require__(60)\n\t  , enumKeys       = __webpack_require__(61)\n\t  , isArray        = __webpack_require__(64)\n\t  , anObject       = __webpack_require__(19)\n\t  , toIObject      = __webpack_require__(35)\n\t  , toPrimitive    = __webpack_require__(25)\n\t  , createDesc     = __webpack_require__(26)\n\t  , _create        = __webpack_require__(31)\n\t  , gOPNExt        = __webpack_require__(65)\n\t  , $GOPD          = __webpack_require__(67)\n\t  , $DP            = __webpack_require__(18)\n\t  , $keys          = __webpack_require__(33)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(66).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(63).f  = $propertyIsEnumerable;\n\t  __webpack_require__(62).f = $getOwnPropertySymbols;\n\n\t  if(DESCRIPTORS && !__webpack_require__(11)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(43)('meta')\n\t  , isObject = __webpack_require__(20)\n\t  , has      = __webpack_require__(28)\n\t  , setDesc  = __webpack_require__(18).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(23)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(13)\n\t  , core           = __webpack_require__(14)\n\t  , LIBRARY        = __webpack_require__(11)\n\t  , wksExt         = __webpack_require__(54)\n\t  , defineProperty = __webpack_require__(18).f;\n\tmodule.exports = function(name){\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n\t};\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(33)\n\t  , toIObject = __webpack_require__(35);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(33)\n\t  , gOPS    = __webpack_require__(62)\n\t  , pIE     = __webpack_require__(63);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(37);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(35)\n\t  , gOPN      = __webpack_require__(66).f\n\t  , toString  = {}.toString;\n\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\tvar $keys      = __webpack_require__(34)\n\t  , hiddenKeys = __webpack_require__(44).concat('length', 'prototype');\n\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n\t  return $keys(O, hiddenKeys);\n\t};\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(63)\n\t  , createDesc     = __webpack_require__(26)\n\t  , toIObject      = __webpack_require__(35)\n\t  , toPrimitive    = __webpack_require__(25)\n\t  , has            = __webpack_require__(28)\n\t  , IE8_DOM_DEFINE = __webpack_require__(21)\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\n\n\texports.f = __webpack_require__(22) ? gOPD : function getOwnPropertyDescriptor(O, P){\n\t  O = toIObject(O);\n\t  P = toPrimitive(P, true);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return gOPD(O, P);\n\t  } catch(e){ /* empty */ }\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n\t};\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports) {\n\n\t\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(59)('asyncIterator');\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(59)('observable');\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports) {\n\n\tvar Helpers, h;\n\n\tHelpers = (function() {\n\t  Helpers.prototype.NS = 'http://www.w3.org/2000/svg';\n\n\t  Helpers.prototype.logBadgeCss = 'background:#3A0839;color:#FF512F;border-radius:5px; padding: 1px 5px 2px; border: 1px solid #FF512F;';\n\n\t  Helpers.prototype.shortColors = {\n\t    transparent: 'rgba(0,0,0,0)',\n\t    none: 'rgba(0,0,0,0)',\n\t    aqua: 'rgb(0,255,255)',\n\t    black: 'rgb(0,0,0)',\n\t    blue: 'rgb(0,0,255)',\n\t    fuchsia: 'rgb(255,0,255)',\n\t    gray: 'rgb(128,128,128)',\n\t    green: 'rgb(0,128,0)',\n\t    lime: 'rgb(0,255,0)',\n\t    maroon: 'rgb(128,0,0)',\n\t    navy: 'rgb(0,0,128)',\n\t    olive: 'rgb(128,128,0)',\n\t    purple: 'rgb(128,0,128)',\n\t    red: 'rgb(255,0,0)',\n\t    silver: 'rgb(192,192,192)',\n\t    teal: 'rgb(0,128,128)',\n\t    white: 'rgb(255,255,255)',\n\t    yellow: 'rgb(255,255,0)',\n\t    orange: 'rgb(255,128,0)'\n\t  };\n\n\t  Helpers.prototype.chainOptionMap = {};\n\n\t  Helpers.prototype.callbacksMap = {\n\t    onRefresh: 1,\n\t    onStart: 1,\n\t    onComplete: 1,\n\t    onFirstUpdate: 1,\n\t    onUpdate: 1,\n\t    onProgress: 1,\n\t    onRepeatStart: 1,\n\t    onRepeatComplete: 1,\n\t    onPlaybackStart: 1,\n\t    onPlaybackPause: 1,\n\t    onPlaybackStop: 1,\n\t    onPlaybackComplete: 1\n\t  };\n\n\t  Helpers.prototype.tweenOptionMap = {\n\t    duration: 1,\n\t    delay: 1,\n\t    speed: 1,\n\t    repeat: 1,\n\t    easing: 1,\n\t    backwardEasing: 1,\n\t    isYoyo: 1,\n\t    shiftTime: 1,\n\t    isReversed: 1,\n\t    callbacksContext: 1\n\t  };\n\n\t  Helpers.prototype.unitOptionMap = {\n\t    left: 1,\n\t    top: 1,\n\t    x: 1,\n\t    y: 1,\n\t    rx: 1,\n\t    ry: 1\n\t  };\n\n\t  Helpers.prototype.RAD_TO_DEG = 180 / Math.PI;\n\n\t  function Helpers() {\n\t    this.vars();\n\t  }\n\n\t  Helpers.prototype.vars = function() {\n\t    var ua;\n\t    this.prefix = this.getPrefix();\n\t    this.getRemBase();\n\t    this.isFF = this.prefix.lowercase === 'moz';\n\t    this.isIE = this.prefix.lowercase === 'ms';\n\t    ua = navigator.userAgent;\n\t    this.isOldOpera = ua.match(/presto/gim);\n\t    this.isSafari = ua.indexOf('Safari') > -1;\n\t    this.isChrome = ua.indexOf('Chrome') > -1;\n\t    this.isOpera = ua.toLowerCase().indexOf(\"op\") > -1;\n\t    this.isChrome && this.isSafari && (this.isSafari = false);\n\t    (ua.match(/PhantomJS/gim)) && (this.isSafari = false);\n\t    this.isChrome && this.isOpera && (this.isChrome = false);\n\t    this.is3d = this.checkIf3d();\n\t    this.uniqIDs = -1;\n\t    this.div = document.createElement('div');\n\t    document.body.appendChild(this.div);\n\t    return this.defaultStyles = this.computedStyle(this.div);\n\t  };\n\n\t  Helpers.prototype.cloneObj = function(obj, exclude) {\n\t    var i, key, keys, newObj;\n\t    keys = Object.keys(obj);\n\t    newObj = {};\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (exclude != null) {\n\t        if (!exclude[key]) {\n\t          newObj[key] = obj[key];\n\t        }\n\t      } else {\n\t        newObj[key] = obj[key];\n\t      }\n\t    }\n\t    return newObj;\n\t  };\n\n\t  Helpers.prototype.extend = function(objTo, objFrom) {\n\t    var key, value;\n\t    for (key in objFrom) {\n\t      value = objFrom[key];\n\t      if (objTo[key] == null) {\n\t        objTo[key] = objFrom[key];\n\t      }\n\t    }\n\t    return objTo;\n\t  };\n\n\t  Helpers.prototype.getRemBase = function() {\n\t    var html, style;\n\t    html = document.querySelector('html');\n\t    style = getComputedStyle(html);\n\t    return this.remBase = parseFloat(style.fontSize);\n\t  };\n\n\t  Helpers.prototype.clamp = function(value, min, max) {\n\t    if (value < min) {\n\t      return min;\n\t    } else if (value > max) {\n\t      return max;\n\t    } else {\n\t      return value;\n\t    }\n\t  };\n\n\t  Helpers.prototype.setPrefixedStyle = function(el, name, value) {\n\t    (name === 'transform') && (el.style[\"\" + this.prefix.css + name] = value);\n\t    return el.style[name] = value;\n\t  };\n\n\t  Helpers.prototype.style = function(el, name, value) {\n\t    var key, keys, len, results;\n\t    if (typeof name === 'object') {\n\t      keys = Object.keys(name);\n\t      len = keys.length;\n\t      results = [];\n\t      while (len--) {\n\t        key = keys[len];\n\t        value = name[key];\n\t        results.push(this.setPrefixedStyle(el, key, value));\n\t      }\n\t      return results;\n\t    } else {\n\t      return this.setPrefixedStyle(el, name, value);\n\t    }\n\t  };\n\n\t  Helpers.prototype.prepareForLog = function(args) {\n\t    args = Array.prototype.slice.apply(args);\n\t    args.unshift('::');\n\t    args.unshift(this.logBadgeCss);\n\t    args.unshift('%cmo·js%c');\n\t    return args;\n\t  };\n\n\t  Helpers.prototype.log = function() {\n\t    if (mojs.isDebug === false) {\n\t      return;\n\t    }\n\t    return console.log.apply(console, this.prepareForLog(arguments));\n\t  };\n\n\t  Helpers.prototype.warn = function() {\n\t    if (mojs.isDebug === false) {\n\t      return;\n\t    }\n\t    return console.warn.apply(console, this.prepareForLog(arguments));\n\t  };\n\n\t  Helpers.prototype.error = function() {\n\t    if (mojs.isDebug === false) {\n\t      return;\n\t    }\n\t    return console.error.apply(console, this.prepareForLog(arguments));\n\t  };\n\n\t  Helpers.prototype.parseUnit = function(value) {\n\t    var amount, isStrict, ref, regex, returnVal, unit;\n\t    if (typeof value === 'number') {\n\t      return returnVal = {\n\t        unit: 'px',\n\t        isStrict: false,\n\t        value: value,\n\t        string: value === 0 ? \"\" + value : value + \"px\"\n\t      };\n\t    } else if (typeof value === 'string') {\n\t      regex = /px|%|rem|em|ex|cm|ch|mm|in|pt|pc|vh|vw|vmin|deg/gim;\n\t      unit = (ref = value.match(regex)) != null ? ref[0] : void 0;\n\t      isStrict = true;\n\t      if (!unit) {\n\t        unit = 'px';\n\t        isStrict = false;\n\t      }\n\t      amount = parseFloat(value);\n\t      return returnVal = {\n\t        unit: unit,\n\t        isStrict: isStrict,\n\t        value: amount,\n\t        string: amount === 0 ? \"\" + amount : \"\" + amount + unit\n\t      };\n\t    }\n\t    return value;\n\t  };\n\n\t  Helpers.prototype.bind = function(func, context) {\n\t    var bindArgs, wrapper;\n\t    wrapper = function() {\n\t      var args, unshiftArgs;\n\t      args = Array.prototype.slice.call(arguments);\n\t      unshiftArgs = bindArgs.concat(args);\n\t      return func.apply(context, unshiftArgs);\n\t    };\n\t    bindArgs = Array.prototype.slice.call(arguments, 2);\n\t    return wrapper;\n\t  };\n\n\t  Helpers.prototype.getRadialPoint = function(o) {\n\t    var point, radAngle, radiusX, radiusY;\n\t    if (o == null) {\n\t      o = {};\n\t    }\n\t    radAngle = (o.angle - 90) * 0.017453292519943295;\n\t    radiusX = o.radiusX != null ? o.radiusX : o.radius;\n\t    radiusY = o.radiusY != null ? o.radiusY : o.radius;\n\t    return point = {\n\t      x: o.center.x + (Math.cos(radAngle) * radiusX),\n\t      y: o.center.y + (Math.sin(radAngle) * radiusY)\n\t    };\n\t  };\n\n\t  Helpers.prototype.getPrefix = function() {\n\t    var dom, pre, styles, v;\n\t    styles = window.getComputedStyle(document.documentElement, \"\");\n\t    v = Array.prototype.slice.call(styles).join(\"\").match(/-(moz|webkit|ms)-/);\n\t    pre = (v || (styles.OLink === \"\" && [\"\", \"o\"]))[1];\n\t    dom = \"WebKit|Moz|MS|O\".match(new RegExp(\"(\" + pre + \")\", \"i\"))[1];\n\t    return {\n\t      dom: dom,\n\t      lowercase: pre,\n\t      css: \"-\" + pre + \"-\",\n\t      js: pre[0].toUpperCase() + pre.substr(1)\n\t    };\n\t  };\n\n\t  Helpers.prototype.strToArr = function(string) {\n\t    var arr;\n\t    arr = [];\n\t    if (typeof string === 'number' && !isNaN(string)) {\n\t      arr.push(this.parseUnit(string));\n\t      return arr;\n\t    }\n\t    string.trim().split(/\\s+/gim).forEach((function(_this) {\n\t      return function(str) {\n\t        return arr.push(_this.parseUnit(_this.parseIfRand(str)));\n\t      };\n\t    })(this));\n\t    return arr;\n\t  };\n\n\t  Helpers.prototype.calcArrDelta = function(arr1, arr2) {\n\t    var delta, i, j, len1, num;\n\t    delta = [];\n\t    for (i = j = 0, len1 = arr1.length; j < len1; i = ++j) {\n\t      num = arr1[i];\n\t      delta[i] = this.parseUnit(\"\" + (arr2[i].value - arr1[i].value) + arr2[i].unit);\n\t    }\n\t    return delta;\n\t  };\n\n\t  Helpers.prototype.isArray = function(variable) {\n\t    return variable instanceof Array;\n\t  };\n\n\t  Helpers.prototype.normDashArrays = function(arr1, arr2) {\n\t    var arr1Len, arr2Len, currItem, i, j, k, lenDiff, ref, ref1, startI;\n\t    arr1Len = arr1.length;\n\t    arr2Len = arr2.length;\n\t    if (arr1Len > arr2Len) {\n\t      lenDiff = arr1Len - arr2Len;\n\t      startI = arr2.length;\n\t      for (i = j = 0, ref = lenDiff; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t        currItem = i + startI;\n\t        arr2.push(this.parseUnit(\"0\" + arr1[currItem].unit));\n\t      }\n\t    } else if (arr2Len > arr1Len) {\n\t      lenDiff = arr2Len - arr1Len;\n\t      startI = arr1.length;\n\t      for (i = k = 0, ref1 = lenDiff; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n\t        currItem = i + startI;\n\t        arr1.push(this.parseUnit(\"0\" + arr2[currItem].unit));\n\t      }\n\t    }\n\t    return [arr1, arr2];\n\t  };\n\n\t  Helpers.prototype.makeColorObj = function(color) {\n\t    var alpha, b, colorObj, g, isRgb, r, regexString1, regexString2, result, rgbColor;\n\t    if (color[0] === '#') {\n\t      result = /^#?([a-f\\d]{1,2})([a-f\\d]{1,2})([a-f\\d]{1,2})$/i.exec(color);\n\t      colorObj = {};\n\t      if (result) {\n\t        r = result[1].length === 2 ? result[1] : result[1] + result[1];\n\t        g = result[2].length === 2 ? result[2] : result[2] + result[2];\n\t        b = result[3].length === 2 ? result[3] : result[3] + result[3];\n\t        colorObj = {\n\t          r: parseInt(r, 16),\n\t          g: parseInt(g, 16),\n\t          b: parseInt(b, 16),\n\t          a: 1\n\t        };\n\t      }\n\t    }\n\t    if (color[0] !== '#') {\n\t      isRgb = color[0] === 'r' && color[1] === 'g' && color[2] === 'b';\n\t      if (isRgb) {\n\t        rgbColor = color;\n\t      }\n\t      if (!isRgb) {\n\t        rgbColor = !this.shortColors[color] ? (this.div.style.color = color, this.computedStyle(this.div).color) : this.shortColors[color];\n\t      }\n\t      regexString1 = '^rgba?\\\\((\\\\d{1,3}),\\\\s?(\\\\d{1,3}),';\n\t      regexString2 = '\\\\s?(\\\\d{1,3}),?\\\\s?(\\\\d{1}|0?\\\\.\\\\d{1,})?\\\\)$';\n\t      result = new RegExp(regexString1 + regexString2, 'gi').exec(rgbColor);\n\t      colorObj = {};\n\t      alpha = parseFloat(result[4] || 1);\n\t      if (result) {\n\t        colorObj = {\n\t          r: parseInt(result[1], 10),\n\t          g: parseInt(result[2], 10),\n\t          b: parseInt(result[3], 10),\n\t          a: (alpha != null) && !isNaN(alpha) ? alpha : 1\n\t        };\n\t      }\n\t    }\n\t    return colorObj;\n\t  };\n\n\t  Helpers.prototype.computedStyle = function(el) {\n\t    return getComputedStyle(el);\n\t  };\n\n\t  Helpers.prototype.capitalize = function(str) {\n\t    if (typeof str !== 'string') {\n\t      throw Error('String expected - nothing to capitalize');\n\t    }\n\t    return str.charAt(0).toUpperCase() + str.substring(1);\n\t  };\n\n\t  Helpers.prototype.parseRand = function(string) {\n\t    var rand, randArr, units;\n\t    randArr = string.split(/rand\\(|\\,|\\)/);\n\t    units = this.parseUnit(randArr[2]);\n\t    rand = this.rand(parseFloat(randArr[1]), parseFloat(randArr[2]));\n\t    if (units.unit && randArr[2].match(units.unit)) {\n\t      return rand + units.unit;\n\t    } else {\n\t      return rand;\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseStagger = function(string, index) {\n\t    var base, number, splittedValue, unit, unitValue, value;\n\t    value = string.split(/stagger\\(|\\)$/)[1].toLowerCase();\n\t    splittedValue = value.split(/(rand\\(.*?\\)|[^\\(,\\s]+)(?=\\s*,|\\s*$)/gim);\n\t    value = splittedValue.length > 3 ? (base = this.parseUnit(this.parseIfRand(splittedValue[1])), splittedValue[3]) : (base = this.parseUnit(0), splittedValue[1]);\n\t    value = this.parseIfRand(value);\n\t    unitValue = this.parseUnit(value);\n\t    number = index * unitValue.value + base.value;\n\t    unit = base.isStrict ? base.unit : unitValue.isStrict ? unitValue.unit : '';\n\t    if (unit) {\n\t      return \"\" + number + unit;\n\t    } else {\n\t      return number;\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseIfStagger = function(value, i) {\n\t    if (!(typeof value === 'string' && value.match(/stagger/g))) {\n\t      return value;\n\t    } else {\n\t      return this.parseStagger(value, i);\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseIfRand = function(str) {\n\t    if (typeof str === 'string' && str.match(/rand\\(/)) {\n\t      return this.parseRand(str);\n\t    } else {\n\t      return str;\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseDelta = function(key, value, index) {\n\t    var curve, delta, easing, end, endArr, endColorObj, i, j, len1, start, startArr, startColorObj;\n\t    value = this.cloneObj(value);\n\t    easing = value.easing;\n\t    if (easing != null) {\n\t      easing = mojs.easing.parseEasing(easing);\n\t    }\n\t    delete value.easing;\n\t    curve = value.curve;\n\t    if (curve != null) {\n\t      curve = mojs.easing.parseEasing(curve);\n\t    }\n\t    delete value.curve;\n\t    start = Object.keys(value)[0];\n\t    end = value[start];\n\t    delta = {\n\t      start: start\n\t    };\n\t    if (isNaN(parseFloat(start)) && !start.match(/rand\\(/) && !start.match(/stagger\\(/)) {\n\t      if (key === 'strokeLinecap') {\n\t        this.warn(\"Sorry, stroke-linecap property is not animatable yet, using the start(\" + start + \") value instead\", value);\n\t        return delta;\n\t      }\n\t      startColorObj = this.makeColorObj(start);\n\t      endColorObj = this.makeColorObj(end);\n\t      delta = {\n\t        type: 'color',\n\t        name: key,\n\t        start: startColorObj,\n\t        end: endColorObj,\n\t        easing: easing,\n\t        curve: curve,\n\t        delta: {\n\t          r: endColorObj.r - startColorObj.r,\n\t          g: endColorObj.g - startColorObj.g,\n\t          b: endColorObj.b - startColorObj.b,\n\t          a: endColorObj.a - startColorObj.a\n\t        }\n\t      };\n\t    } else if (key === 'strokeDasharray' || key === 'strokeDashoffset' || key === 'origin') {\n\t      startArr = this.strToArr(start);\n\t      endArr = this.strToArr(end);\n\t      this.normDashArrays(startArr, endArr);\n\t      for (i = j = 0, len1 = startArr.length; j < len1; i = ++j) {\n\t        start = startArr[i];\n\t        end = endArr[i];\n\t        this.mergeUnits(start, end, key);\n\t      }\n\t      delta = {\n\t        type: 'array',\n\t        name: key,\n\t        start: startArr,\n\t        end: endArr,\n\t        delta: this.calcArrDelta(startArr, endArr),\n\t        easing: easing,\n\t        curve: curve\n\t      };\n\t    } else {\n\t      if (!this.callbacksMap[key] && !this.tweenOptionMap[key]) {\n\t        if (this.unitOptionMap[key]) {\n\t          end = this.parseUnit(this.parseStringOption(end, index));\n\t          start = this.parseUnit(this.parseStringOption(start, index));\n\t          this.mergeUnits(start, end, key);\n\t          delta = {\n\t            type: 'unit',\n\t            name: key,\n\t            start: start,\n\t            end: end,\n\t            delta: end.value - start.value,\n\t            easing: easing,\n\t            curve: curve\n\t          };\n\t        } else {\n\t          end = parseFloat(this.parseStringOption(end, index));\n\t          start = parseFloat(this.parseStringOption(start, index));\n\t          delta = {\n\t            type: 'number',\n\t            name: key,\n\t            start: start,\n\t            end: end,\n\t            delta: end - start,\n\t            easing: easing,\n\t            curve: curve\n\t          };\n\t        }\n\t      }\n\t    }\n\t    return delta;\n\t  };\n\n\t  Helpers.prototype.mergeUnits = function(start, end, key) {\n\t    if (!end.isStrict && start.isStrict) {\n\t      end.unit = start.unit;\n\t      return end.string = \"\" + end.value + end.unit;\n\t    } else if (end.isStrict && !start.isStrict) {\n\t      start.unit = end.unit;\n\t      return start.string = \"\" + start.value + start.unit;\n\t    } else if (end.isStrict && start.isStrict) {\n\t      if (end.unit !== start.unit) {\n\t        start.unit = end.unit;\n\t        start.string = \"\" + start.value + start.unit;\n\t        return this.warn(\"Two different units were specified on \\\"\" + key + \"\\\" delta property, mo · js will fallback to end \\\"\" + end.unit + \"\\\" unit \");\n\t      }\n\t    }\n\t  };\n\n\t  Helpers.prototype.rand = function(min, max) {\n\t    return (Math.random() * (max - min)) + min;\n\t  };\n\n\t  Helpers.prototype.isDOM = function(o) {\n\t    var isNode;\n\t    if (o == null) {\n\t      return false;\n\t    }\n\t    isNode = typeof o.nodeType === 'number' && typeof o.nodeName === 'string';\n\t    return typeof o === 'object' && isNode;\n\t  };\n\n\t  Helpers.prototype.getChildElements = function(element) {\n\t    var childNodes, children, i;\n\t    childNodes = element.childNodes;\n\t    children = [];\n\t    i = childNodes.length;\n\t    while (i--) {\n\t      if (childNodes[i].nodeType === 1) {\n\t        children.unshift(childNodes[i]);\n\t      }\n\t    }\n\t    return children;\n\t  };\n\n\t  Helpers.prototype.delta = function(start, end) {\n\t    var isType1, isType2, obj, type1, type2;\n\t    type1 = typeof start;\n\t    type2 = typeof end;\n\t    isType1 = type1 === 'string' || type1 === 'number' && !isNaN(start);\n\t    isType2 = type2 === 'string' || type2 === 'number' && !isNaN(end);\n\t    if (!isType1 || !isType2) {\n\t      this.error(\"delta method expects Strings or Numbers at input but got - \" + start + \", \" + end);\n\t      return;\n\t    }\n\t    obj = {};\n\t    obj[start] = end;\n\t    return obj;\n\t  };\n\n\t  Helpers.prototype.getUniqID = function() {\n\t    return ++this.uniqIDs;\n\t  };\n\n\t  Helpers.prototype.parsePath = function(path) {\n\t    var domPath;\n\t    if (typeof path === 'string') {\n\t      if (path.charAt(0).toLowerCase() === 'm') {\n\t        domPath = document.createElementNS(this.NS, 'path');\n\t        domPath.setAttributeNS(null, 'd', path);\n\t        return domPath;\n\t      } else {\n\t        return document.querySelector(path);\n\t      }\n\t    }\n\t    if (path.style) {\n\t      return path;\n\t    }\n\t  };\n\n\t  Helpers.prototype.closeEnough = function(num1, num2, eps) {\n\t    return Math.abs(num1 - num2) < eps;\n\t  };\n\n\t  Helpers.prototype.checkIf3d = function() {\n\t    var div, prefixed, style, tr;\n\t    div = document.createElement('div');\n\t    this.style(div, 'transform', 'translateZ(0)');\n\t    style = div.style;\n\t    prefixed = this.prefix.css + \"transform\";\n\t    tr = style[prefixed] != null ? style[prefixed] : style.transform;\n\t    return tr !== '';\n\t  };\n\n\n\t  /*\n\t    Method to check if variable holds pointer to an object.\n\t    @param {Any} Variable to test\n\t    @returns {Boolean} If variable is object.\n\t   */\n\n\t  Helpers.prototype.isObject = function(variable) {\n\t    return variable !== null && typeof variable === 'object';\n\t  };\n\n\n\t  /*\n\t    Method to get first value of the object.\n\t    Used to get end value on ∆s.\n\t    @param {Object} Object to get the value of.\n\t    @returns {Any} The value of the first object' property.\n\t   */\n\n\t  Helpers.prototype.getDeltaEnd = function(obj) {\n\t    var key;\n\t    key = Object.keys(obj)[0];\n\t    return obj[key];\n\t  };\n\n\n\t  /*\n\t    Method to get first key of the object.\n\t    Used to get start value on ∆s.\n\t    @param {Object} Object to get the value of.\n\t    @returns {String} The key of the first object' property.\n\t   */\n\n\t  Helpers.prototype.getDeltaStart = function(obj) {\n\t    var key;\n\t    key = Object.keys(obj)[0];\n\t    return key;\n\t  };\n\n\n\t  /*\n\t    Method to check if propery exists in callbacksMap or tweenOptionMap.\n\t    @param {String} Property name to check for\n\t    @returns {Boolean} If property is tween property.\n\t   */\n\n\t  Helpers.prototype.isTweenProp = function(keyName) {\n\t    return this.tweenOptionMap[keyName] || this.callbacksMap[keyName];\n\t  };\n\n\n\t  /*\n\t    Method to parse string property value\n\t    which can include both `rand` and `stagger `\n\t    value in various positions.\n\t    @param {String} Property name to check for.\n\t    @param {Number} Optional index for stagger.\n\t    @returns {Number} Parsed option value.\n\t   */\n\n\t  Helpers.prototype.parseStringOption = function(value, index) {\n\t    if (index == null) {\n\t      index = 0;\n\t    }\n\t    if (typeof value === 'string') {\n\t      value = this.parseIfStagger(value, index);\n\t      value = this.parseIfRand(value);\n\t    }\n\t    return value;\n\t  };\n\n\n\t  /*\n\t    Method to get the last item of array.\n\t    @private\n\t    @param {Array} Array to get the last item in.\n\t    @returns {Any} The last item of array.\n\t   */\n\n\t  Helpers.prototype.getLastItem = function(arr) {\n\t    return arr[arr.length - 1];\n\t  };\n\n\n\t  /*\n\t    Method parse HTMLElement.\n\t    @private\n\t    @param {String, Object} Selector string or HTMLElement.\n\t    @returns {Object} HTMLElement.\n\t   */\n\n\t  Helpers.prototype.parseEl = function(el) {\n\t    if (h.isDOM(el)) {\n\t      return el;\n\t    } else if (typeof el === 'string') {\n\t      el = document.querySelector(el);\n\t    }\n\t    if (el === null) {\n\t      h.error(\"Can't parse HTML element: \", el);\n\t    }\n\t    return el;\n\t  };\n\n\n\t  /*\n\t    Method force compositor layer on HTMLElement.\n\t    @private\n\t    @param {Object} HTMLElement.\n\t    @returns {Object} HTMLElement.\n\t   */\n\n\t  Helpers.prototype.force3d = function(el) {\n\t    this.setPrefixedStyle(el, 'backface-visibility', 'hidden');\n\t    return el;\n\t  };\n\n\n\t  /*\n\t    Method to check if value is delta.\n\t    @private\n\t    @param {Any} Property to check.\n\t    @returns {Boolean} If value is delta.\n\t   */\n\n\t  Helpers.prototype.isDelta = function(optionsValue) {\n\t    var isObject;\n\t    isObject = this.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || this.isArray(optionsValue) || this.isDOM(optionsValue));\n\t  };\n\n\t  return Helpers;\n\n\t})();\n\n\th = new Helpers;\n\n\tmodule.exports = h;\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Bit, BitsMap, Circle, Cross, Curve, Custom, Equal, Line, Polygon, Rect, Zigzag, h;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tCustom = __webpack_require__(85)[\"default\"] || __webpack_require__(85);\n\n\tCircle = __webpack_require__(86);\n\n\tLine = __webpack_require__(87);\n\n\tZigzag = __webpack_require__(88);\n\n\tRect = __webpack_require__(89);\n\n\tPolygon = __webpack_require__(90);\n\n\tCross = __webpack_require__(91);\n\n\tCurve = __webpack_require__(92)[\"default\"] || __webpack_require__(92);\n\n\tEqual = __webpack_require__(93);\n\n\th = __webpack_require__(71);\n\n\tBitsMap = (function() {\n\t  function BitsMap() {\n\t    this.addShape = h.bind(this.addShape, this);\n\t  }\n\n\t  BitsMap.prototype.bit = Bit;\n\n\t  BitsMap.prototype.custom = Custom;\n\n\t  BitsMap.prototype.circle = Circle;\n\n\t  BitsMap.prototype.line = Line;\n\n\t  BitsMap.prototype.zigzag = Zigzag;\n\n\t  BitsMap.prototype.rect = Rect;\n\n\t  BitsMap.prototype.polygon = Polygon;\n\n\t  BitsMap.prototype.cross = Cross;\n\n\t  BitsMap.prototype.equal = Equal;\n\n\t  BitsMap.prototype.curve = Curve;\n\n\t  BitsMap.prototype.getShape = function(name) {\n\t    return this[name] || h.error(\"no \\\"\" + name + \"\\\" shape available yet, please choose from this list:\", ['circle', 'line', 'zigzag', 'rect', 'polygon', 'cross', 'equal', 'curve']);\n\t  };\n\n\n\t  /*\n\t    Method to add shape to the map.\n\t    @public\n\t    @param {String} Name of the shape module.\n\t    @param {Object} Shape module class.\n\t   */\n\n\t  BitsMap.prototype.addShape = function(name, Module) {\n\t    return this[name] = Module;\n\t  };\n\n\t  return BitsMap;\n\n\t})();\n\n\tmodule.exports = new BitsMap;\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(3);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _module = __webpack_require__(84);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Bit = function (_Module) {\n\t  (0, _inherits3.default)(Bit, _Module);\n\n\t  function Bit() {\n\t    (0, _classCallCheck3.default)(this, Bit);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Module.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t  */\n\t  Bit.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      'ns': 'http://www.w3.org/2000/svg',\n\t      'tag': 'ellipse',\n\t      'parent': document.body,\n\t      'ratio': 1,\n\t      'radius': 50,\n\t      'radiusX': null,\n\t      'radiusY': null,\n\t      'stroke': 'hotpink',\n\t      'stroke-dasharray': '',\n\t      'stroke-dashoffset': '',\n\t      'stroke-linecap': '',\n\t      'stroke-width': 2,\n\t      'stroke-opacity': 1,\n\t      'fill': 'transparent',\n\t      'fill-opacity': 1,\n\t      'width': 0,\n\t      'height': 0\n\t    };\n\t    this._drawMap = ['stroke', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill', 'stroke-dashoffset', 'stroke-linecap', 'fill-opacity', 'transform'];\n\t  };\n\n\t  Bit.prototype._vars = function _vars() {\n\t    this._state = {};\n\t    this._drawMapLength = this._drawMap.length;\n\t  };\n\t  /*\n\t    Method for initial render of the shape.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._render = function _render() {\n\t    if (this._isRendered) {\n\t      return;\n\t    }\n\t    // set `_isRendered` hatch\n\t    this._isRendered = true;\n\t    // create `SVG` canvas to draw in\n\t    this._createSVGCanvas();\n\t    // set canvas size\n\t    this._setCanvasSize();\n\t    // draw the initial state\n\t    // this._draw();\n\t    // append the canvas to the parent from props\n\t    this._props.parent.appendChild(this._canvas);\n\t  };\n\t  /*\n\t    Method to create `SVG` canvas to draw in.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._createSVGCanvas = function _createSVGCanvas() {\n\t    var p = this._props;\n\t    // create canvas - `svg` element to draw in\n\t    this._canvas = document.createElementNS(p.ns, 'svg');\n\t    // create the element shape element and add it to the canvas\n\t    this.el = document.createElementNS(p.ns, p.tag);\n\t    this._canvas.appendChild(this.el);\n\t  };\n\t  /*\n\t    Method to set size of the _canvas.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._setCanvasSize = function _setCanvasSize() {\n\t    var p = this._props,\n\t        style = this._canvas.style;\n\n\t    style.display = 'block';\n\t    style.width = '100%';\n\t    style.height = '100%';\n\t    style.left = '0px';\n\t    style.top = '0px';\n\t  };\n\t  /*\n\t    Method to draw the shape.\n\t    Called on every frame.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._draw = function _draw() {\n\t    this._props.length = this._getLength();\n\n\t    var state = this._state,\n\t        props = this._props;\n\n\t    var len = this._drawMapLength;\n\t    while (len--) {\n\t      var name = this._drawMap[len];\n\t      switch (name) {\n\t        case 'stroke-dasharray':\n\t        case 'stroke-dashoffset':\n\t          this.castStrokeDash(name);\n\t      }\n\t      this._setAttrIfChanged(name, this._props[name]);\n\t    }\n\t    this._state.radius = this._props.radius;\n\t  };\n\n\t  Bit.prototype.castStrokeDash = function castStrokeDash(name) {\n\t    // # if array of values\n\t    var p = this._props;\n\t    if (_h2.default.isArray(p[name])) {\n\t      var stroke = '';\n\t      for (var i = 0; i < p[name].length; i++) {\n\t        var dash = p[name][i],\n\t            cast = dash.unit === '%' ? this.castPercent(dash.value) : dash.value;\n\t        stroke += cast + ' ';\n\t      }\n\t      p[name] = stroke === '0 ' ? stroke = '' : stroke;\n\t      return p[name] = stroke;\n\t    }\n\t    // # if single value\n\t    if ((0, _typeof3.default)(p[name]) === 'object') {\n\t      stroke = p[name].unit === '%' ? this.castPercent(p[name].value) : p[name].value;\n\t      p[name] = stroke === 0 ? stroke = '' : stroke;\n\t    }\n\t  };\n\n\t  Bit.prototype.castPercent = function castPercent(percent) {\n\t    return percent * (this._props.length / 100);\n\t  };\n\n\t  /*\n\t    Method to set props to attributes and cache the values.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._setAttrIfChanged = function _setAttrIfChanged(name, value) {\n\t    if (this._state[name] !== value) {\n\t      // this.el.style[name] = value;\n\t      this.el.setAttribute(name, value);\n\t      this._state[name] = value;\n\t    }\n\t  };\n\t  /*\n\t    Method to length of the shape.\n\t    @private\n\t    @returns {Number} Length of the shape.\n\t  */\n\n\n\t  Bit.prototype._getLength = function _getLength() {\n\t    var p = this._props,\n\t        len = 0,\n\t        isGetLength = !!(this.el && this.el.getTotalLength);\n\n\t    if (isGetLength && this.el.getAttribute('d')) {\n\t      len = this.el.getTotalLength();\n\t    } else {\n\t      len = 2 * (p.radiusX != null ? p.radiusX : p.radius);\n\t    }\n\t    return len;\n\t  };\n\t  /*\n\t    Method to calculate total sum between points.\n\t    @private\n\t    @param {Array} Array of points.\n\t    @returns {Number} Distance bewtween all points.\n\t  */\n\n\n\t  Bit.prototype._getPointsPerimiter = function _getPointsPerimiter(points) {\n\t    var sum = 0;\n\n\t    for (var i = 1; i < points.length; i++) {\n\t      sum += this._pointsDelta(points[i - 1], points[i]);\n\t    }\n\n\t    sum += this._pointsDelta(points[0], _h2.default.getLastItem(points));\n\t    return sum;\n\t  };\n\t  /*\n\t    Method to get delta from two points.\n\t    @private\n\t    @param {Object} Point 1.\n\t    @param {Object} Point 2.\n\t    @returns {Number} Distance between the pooints.\n\t  */\n\n\n\t  Bit.prototype._pointsDelta = function _pointsDelta(point1, point2) {\n\t    var dx = Math.abs(point1.x - point2.x),\n\t        dy = Math.abs(point1.y - point2.y);\n\t    return Math.sqrt(dx * dx + dy * dy);\n\t  };\n\t  /*\n\t    Method to set module's size.\n\t    @private\n\t    @param {Number} Module width.\n\t    @param {Number} Module height.\n\t  */\n\n\n\t  Bit.prototype._setSize = function _setSize(width, height) {\n\t    var p = this._props;\n\t    p.width = width;\n\t    p.height = height;\n\t    this._draw();\n\t  };\n\n\t  return Bit;\n\t}(_module2.default);\n\n\texports.default = Bit;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(3);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\n\t  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _setPrototypeOf = __webpack_require__(77);\n\n\tvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\n\tvar _create = __webpack_require__(81);\n\n\tvar _create2 = _interopRequireDefault(_create);\n\n\tvar _typeof2 = __webpack_require__(3);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n\t  }\n\n\t  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(78), __esModule: true };\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(79);\n\tmodule.exports = __webpack_require__(14).Object.setPrototypeOf;\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\tvar $export = __webpack_require__(12);\n\t$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(80).set});\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar isObject = __webpack_require__(20)\n\t  , anObject = __webpack_require__(19);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(15)(Function.call, __webpack_require__(67).f(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(82), __esModule: true };\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(83);\n\tvar $Object = __webpack_require__(14).Object;\n\tmodule.exports = function create(P, D){\n\t  return $Object.create(P, D);\n\t};\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(12)\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\t$export($export.S, 'Object', {create: __webpack_require__(31)});\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(3);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  Base class for module. Extends and parses defaults.\n\t*/\n\tvar Module = function () {\n\t  function Module() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Module);\n\n\t    // this._isIt = o.isIt;\n\t    // delete o.isIt;\n\t    this._o = o;\n\t    this._index = this._o.index || 0;\n\t    // map of props that should be\n\t    // parsed to arrays of values\n\t    this._arrayPropertyMap = {\n\t      strokeDashoffset: 1,\n\t      strokeDasharray: 1,\n\t      origin: 1\n\t    };\n\n\t    this._skipPropsDelta = {\n\t      timeline: 1,\n\t      prevChainModule: 1,\n\t      callbacksContext: 1\n\t    };\n\n\t    this._declareDefaults();\n\t    this._extendDefaults();\n\n\t    this._vars();\n\t    this._render();\n\t  }\n\t  /*\n\t    Method to declare defaults.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {};\n\t  };\n\t  /*\n\t    Method to declare module's variables.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._vars = function _vars() {\n\t    this._progress = 0;\n\t    this._strokeDasharrayBuffer = [];\n\t  };\n\t  /*\n\t    Method to render on initialization.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._render = function _render() {};\n\t  /*\n\t    Method to set property on the module.\n\t    @private\n\t    @param {String, Object} Name of the property to set\n\t                            or object with properties to set.\n\t    @param {Any} Value for the property to set. Could be\n\t                  undefined if the first param is object.\n\t  */\n\n\n\t  Module.prototype._setProp = function _setProp(attr, value) {\n\t    if ((typeof attr === 'undefined' ? 'undefined' : (0, _typeof3.default)(attr)) === 'object') {\n\t      for (var key in attr) {\n\t        this._assignProp(key, attr[key]);\n\t      }\n\t    } else {\n\t      this._assignProp(attr, value);\n\t    }\n\t  };\n\t  /*\n\t    Method to assign single property's value.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t  */\n\n\n\t  Module.prototype._assignProp = function _assignProp(key, value) {\n\t    this._props[key] = value;\n\t  };\n\t  /*\n\t    Method to show element.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._show = function _show() {\n\t    var p = this._props;\n\t    if (!this.el) {\n\t      return;\n\t    }\n\n\t    if (p.isSoftHide) {\n\t      // this.el.style.opacity = p.opacity;\n\t      this._showByTransform();\n\t    } else {\n\t      this.el.style.display = 'block';\n\t    }\n\n\t    this._isShown = true;\n\t  };\n\t  /*\n\t    Method to hide element.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._hide = function _hide() {\n\t    if (!this.el) {\n\t      return;\n\t    }\n\n\t    if (this._props.isSoftHide) {\n\t      // this.el.style.opacity = 0;\n\t      _h2.default.setPrefixedStyle(this.el, 'transform', 'scale(0)');\n\t    } else {\n\t      this.el.style.display = 'none';\n\t    }\n\n\t    this._isShown = false;\n\t  };\n\t  /*\n\t    Method to show element by applying transform back to normal.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._showByTransform = function _showByTransform() {};\n\t  /*\n\t    Method to parse option string.\n\t    Searches for stagger and rand values and parses them.\n\t    Leaves the value unattended otherwise.\n\t    @param {Any} Option value to parse.\n\t    @returns {Number} Parsed options value.\n\t  */\n\n\n\t  Module.prototype._parseOptionString = function _parseOptionString(value) {\n\t    if (typeof value === 'string') {\n\t      if (value.match(/stagger/)) {\n\t        value = _h2.default.parseStagger(value, this._index);\n\t      }\n\t    }\n\t    if (typeof value === 'string') {\n\t      if (value.match(/rand/)) {\n\t        value = _h2.default.parseRand(value);\n\t      }\n\t    }\n\t    return value;\n\t  };\n\t  /*\n\t    Method to parse postion option.\n\t    @param {String} Property name.\n\t    @param {Any} Property Value.\n\t    @returns {String} Parsed options value.\n\t  */\n\n\n\t  Module.prototype._parsePositionOption = function _parsePositionOption(key, value) {\n\t    if (_h2.default.unitOptionMap[key]) {\n\t      value = _h2.default.parseUnit(value).string;\n\t    }\n\t    return value;\n\t  };\n\t  /*\n\t    Method to parse strokeDash.. option.\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {String} Parsed options value.\n\t  */\n\n\n\t  Module.prototype._parseStrokeDashOption = function _parseStrokeDashOption(key, value) {\n\t    var result = value;\n\t    // parse numeric/percent values for strokeDash.. properties\n\t    if (this._arrayPropertyMap[key]) {\n\t      var result = [];\n\t      switch (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) {\n\t        case 'number':\n\t          result.push(_h2.default.parseUnit(value));\n\t          break;\n\t        case 'string':\n\t          var array = value.split(' ');\n\t          for (var i = 0; i < array.length; i++) {\n\t            result.push(_h2.default.parseUnit(array[i]));\n\t          }\n\t          break;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t  /*\n\t    Method to check if the property is delta property.\n\t    @private\n\t    @param {Any} Parameter value to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Module.prototype._isDelta = function _isDelta(optionsValue) {\n\t    var isObject = _h2.default.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || _h2.default.isArray(optionsValue) || _h2.default.isDOM(optionsValue));\n\t  };\n\t  /*\n\t    Method to get delta from property and set\n\t    the property's start value to the props object.\n\t    @private\n\t    @param {String} Key name to get delta for.\n\t    @param {Object} Option value to get the delta for.\n\t  */\n\n\n\t  Module.prototype._getDelta = function _getDelta(key, optionsValue) {\n\t    var delta;\n\t    if ((key === 'left' || key === 'top') && !this._o.ctx) {\n\t      _h2.default.warn('Consider to animate x/y properties instead of left/top,\\n        as it would be much more performant', optionsValue);\n\t    }\n\t    // skip delta calculation for a property if it is listed\n\t    // in skipPropsDelta object\n\t    if (this._skipPropsDelta && this._skipPropsDelta[key]) {\n\t      return;\n\t    }\n\t    // get delta\n\t    delta = _h2.default.parseDelta(key, optionsValue, this._index);\n\t    // if successfully parsed - save it\n\t    if (delta.type != null) {\n\t      this._deltas[key] = delta;\n\t    }\n\n\t    var deltaEnd = (0, _typeof3.default)(delta.end) === 'object' ? delta.end.value === 0 ? 0 : delta.end.string : delta.end;\n\t    // set props to end value of the delta\n\t    // 0 should be 0 regardless units\n\t    this._props[key] = deltaEnd;\n\t  };\n\t  /*\n\t    Method to copy `_o` options to `_props` object\n\t    with fallback to `_defaults`.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._extendDefaults = function _extendDefaults() {\n\t    this._props = {};\n\t    this._deltas = {};\n\t    for (var key in this._defaults) {\n\t      // skip property if it is listed in _skipProps\n\t      // if (this._skipProps && this._skipProps[key]) { continue; }\n\t      // copy the properties to the _o object\n\t      var value = this._o[key] != null ? this._o[key] : this._defaults[key];\n\t      // parse option\n\t      this._parseOption(key, value);\n\t    }\n\t  };\n\t  /*\n\t    Method to tune new oprions to _o and _props object.\n\t    @private\n\t    @param {Object} Options object to tune to.\n\t  */\n\n\n\t  Module.prototype._tuneNewOptions = function _tuneNewOptions(o) {\n\t    // hide the module before tuning it's options\n\t    // cuz the user could see the change\n\t    this._hide();\n\t    for (var key in o) {\n\t      // skip property if it is listed in _skipProps\n\t      // if (this._skipProps && this._skipProps[key]) { continue; }\n\t      // copy the properties to the _o object\n\t      // delete the key from deltas\n\t      o && delete this._deltas[key];\n\t      // rewrite _o record\n\t      this._o[key] = o[key];\n\t      // save the options to _props\n\t      this._parseOption(key, o[key]);\n\t    }\n\t  };\n\t  /*\n\t    Method to parse option value.\n\t    @private\n\t    @param {String} Option name.\n\t    @param {Any} Option value.\n\t  */\n\n\n\t  Module.prototype._parseOption = function _parseOption(name, value) {\n\t    // if delta property\n\t    if (this._isDelta(value) && !this._skipPropsDelta[name]) {\n\t      this._getDelta(name, value);\n\t      var deltaEnd = _h2.default.getDeltaEnd(value);\n\t      return this._assignProp(name, this._parseProperty(name, deltaEnd));\n\t    }\n\n\t    this._assignProp(name, this._parseProperty(name, value));\n\t  };\n\t  /*\n\t    Method to parse postion and string props.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {Any}  Parsed property value.\n\t  */\n\n\n\t  Module.prototype._parsePreArrayProperty = function _parsePreArrayProperty(name, value) {\n\t    // parse stagger and rand values\n\t    value = this._parseOptionString(value);\n\t    // parse units for position properties\n\t    return this._parsePositionOption(name, value);\n\t  };\n\t  /*\n\t    Method to parse property value.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {Any}  Parsed property value.\n\t  */\n\n\n\t  Module.prototype._parseProperty = function _parseProperty(name, value) {\n\t    // parse `HTML` element in `parent` option\n\t    if (name === 'parent') {\n\t      return _h2.default.parseEl(value);\n\t    }\n\t    // parse `stagger`, `rand` and `position`\n\t    value = this._parsePreArrayProperty(name, value);\n\t    // parse numeric/percent values for strokeDash.. properties\n\t    return this._parseStrokeDashOption(name, value);\n\t  };\n\t  /*\n\t    Method to parse values inside ∆.\n\t    @private\n\t    @param {String} Key name.\n\t    @param {Object} Delta.\n\t    @returns {Object} Delta with parsed parameters.\n\t  */\n\n\n\t  Module.prototype._parseDeltaValues = function _parseDeltaValues(name, delta) {\n\t    // return h.parseDelta( name, delta, this._index );\n\n\t    var d = {};\n\t    for (var key in delta) {\n\t      var value = delta[key];\n\n\t      // delete delta[key];\n\t      // add parsed properties\n\t      var newEnd = this._parsePreArrayProperty(name, value);\n\t      d[this._parsePreArrayProperty(name, key)] = newEnd;\n\t    }\n\t    return d;\n\t  };\n\t  /*\n\t    Method to parse delta and nondelta properties.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {Any}  Parsed property value.\n\t  */\n\n\n\t  Module.prototype._preparsePropValue = function _preparsePropValue(key, value) {\n\t    return this._isDelta(value) ? this._parseDeltaValues(key, value) : this._parsePreArrayProperty(key, value);\n\t  };\n\t  /*\n\t    Method to calculate current progress of the deltas.\n\t    @private\n\t    @param {Number} Eased progress to calculate - [0..1].\n\t    @param {Number} Progress to calculate - [0..1].\n\t  */\n\n\n\t  Module.prototype._calcCurrentProps = function _calcCurrentProps(easedProgress, p) {\n\n\t    for (var key in this._deltas) {\n\n\t      var value = this._deltas[key];\n\n\t      // get eased progress from delta easing if defined and not curve\n\t      var isCurve = !!value.curve;\n\t      var ep = value.easing != null && !isCurve ? value.easing(p) : easedProgress;\n\n\t      if (value.type === 'array') {\n\t        var arr;\n\t        // if prop property is array - reuse it else - create an array\n\t        if (_h2.default.isArray(this._props[key])) {\n\t          arr = this._props[key];\n\t          arr.length = 0;\n\t        } else {\n\t          arr = [];\n\t        }\n\n\t        // just optimization to prevent curve\n\t        // calculations on every array item\n\t        var proc = isCurve ? value.curve(p) : null;\n\n\t        for (var i = 0; i < value.delta.length; i++) {\n\t          var item = value.delta[i],\n\t              dash = !isCurve ? value.start[i].value + ep * item.value : proc * (value.start[i].value + p * item.value);\n\t          arr.push({\n\t            string: '' + dash + item.unit,\n\t            value: dash,\n\t            unit: item.unit\n\t          });\n\t        }\n\n\t        this._props[key] = arr;\n\t      } else if (value.type === 'number') {\n\t        this._props[key] = !isCurve ? value.start + ep * value.delta : value.curve(p) * (value.start + p * value.delta);\n\t      } else if (value.type === 'unit') {\n\t        var currentValue = !isCurve ? value.start.value + ep * value.delta : value.curve(p) * (value.start.value + p * value.delta);\n\n\t        this._props[key] = '' + currentValue + value.end.unit;\n\t      } else if (value.type === 'color') {\n\t        var r, g, b, a;\n\t        if (!isCurve) {\n\t          r = parseInt(value.start.r + ep * value.delta.r, 10);\n\t          g = parseInt(value.start.g + ep * value.delta.g, 10);\n\t          b = parseInt(value.start.b + ep * value.delta.b, 10);\n\t          a = parseFloat(value.start.a + ep * value.delta.a);\n\t        } else {\n\t          var cp = value.curve(p);\n\t          r = parseInt(cp * (value.start.r + p * value.delta.r), 10);\n\t          g = parseInt(cp * (value.start.g + p * value.delta.g), 10);\n\t          b = parseInt(cp * (value.start.b + p * value.delta.b), 10);\n\t          a = parseFloat(cp * (value.start.a + p * value.delta.a));\n\t        }\n\t        this._props[key] = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to calculate current progress and probably draw it in children.\n\t    @private\n\t    @param {Number} Eased progress to set - [0..1].\n\t    @param {Number} Progress to set - [0..1].\n\t  */\n\n\n\t  Module.prototype._setProgress = function _setProgress(easedProgress, progress) {\n\t    this._progress = easedProgress;\n\t    this._calcCurrentProps(easedProgress, progress);\n\t  };\n\n\t  return Module;\n\t}();\n\n\texports.default = Module;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _bit = __webpack_require__(73);\n\n\tvar _bit2 = _interopRequireDefault(_bit);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Custom = function (_Bit) {\n\t  (0, _inherits3.default)(Custom, _Bit);\n\n\t  function Custom() {\n\t    (0, _classCallCheck3.default)(this, Custom);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Bit.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\t  Custom.prototype._declareDefaults = function _declareDefaults() {\n\t    _Bit.prototype._declareDefaults.call(this);\n\n\t    this._defaults.tag = 'path';\n\t    this._defaults.parent = null;\n\n\t    // remove `stroke-width` from `_drawMap`\n\t    // because we need to recal strokeWidth size regarding scale\n\t    for (var i = 0; i < this._drawMap.length; i++) {\n\t      if (this._drawMap[i] === 'stroke-width') {\n\t        this._drawMap.splice(i, 1);\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to get shape to set on module's path.\n\t    @public\n\t    @returns {String} Empty string.\n\t  */\n\n\n\t  Custom.prototype.getShape = function getShape() {\n\t    return '';\n\t  };\n\t  /*\n\t    Method to get shape perimeter length.\n\t    @public\n\t    @returns {Number} Default length string.\n\t  */\n\n\n\t  Custom.prototype.getLength = function getLength() {\n\t    return 100;\n\t  };\n\t  /*\n\t    Method to draw the shape.\n\t    Called on every frame.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\n\t  Custom.prototype._draw = function _draw() {\n\t    var p = this._props,\n\t        state = this._state,\n\t        radiusXChange = state['radiusX'] !== p.radiusX,\n\t        radiusYChange = state['radiusY'] !== p.radiusY,\n\t        radiusChange = state['radius'] !== p.radius;\n\n\t    // update transform only if one of radiuses changed\n\t    if (radiusXChange || radiusYChange || radiusChange) {\n\t      this.el.setAttribute('transform', this._getScale());\n\t      state['radiusX'] = p.radiusX;\n\t      state['radiusY'] = p.radiusY;\n\t      state['radius'] = p.radius;\n\t    }\n\n\t    this._setAttrIfChanged('stroke-width', p['stroke-width'] / p.maxScale);\n\n\t    _Bit.prototype._draw.call(this);\n\t  };\n\t  /*\n\t    Method for initial render of the shape.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\n\t  Custom.prototype._render = function _render() {\n\t    if (this._isRendered) {\n\t      return;\n\t    }\n\t    this._isRendered = true;\n\n\t    this._length = this.getLength();\n\n\t    var p = this._props;\n\t    p.parent.innerHTML = '<svg id=\"js-mojs-shape-canvas\" xmlns=\"http://www.w3.org/2000/svg\" xlink=\"http://www.w3.org/1999/xlink\"><g id=\"js-mojs-shape-el\">' + this.getShape() + '</g></svg>';\n\n\t    this._canvas = p.parent.querySelector('#js-mojs-shape-canvas');\n\t    this.el = p.parent.querySelector('#js-mojs-shape-el');\n\t    this._setCanvasSize();\n\t  };\n\t  /*\n\t    Method to get scales for the shape.\n\t    @private\n\t    @mutates @props\n\t  */\n\n\n\t  Custom.prototype._getScale = function _getScale() {\n\t    var p = this._props,\n\t        radiusX = p.radiusX ? p.radiusX : p.radius,\n\t        radiusY = p.radiusY ? p.radiusY : p.radius;\n\n\t    p.scaleX = 2 * radiusX / 100;\n\t    p.scaleY = 2 * radiusY / 100;\n\t    p.maxScale = Math.max(p.scaleX, p.scaleY);\n\n\t    p.shiftX = p.width / 2 - 50 * p.scaleX;\n\t    p.shiftY = p.height / 2 - 50 * p.scaleY;\n\n\t    var translate = 'translate(' + p.shiftX + ', ' + p.shiftY + ')';\n\t    return translate + ' scale(' + p.scaleX + ', ' + p.scaleY + ')';\n\t  };\n\t  /*\n\t    Method to length of the shape.\n\t    @private\n\t    @returns {Number} Length of the shape.\n\t  */\n\n\n\t  Custom.prototype._getLength = function _getLength() {\n\t    return this._length;\n\t  };\n\n\t  return Custom;\n\t}(_bit2.default);\n\n\texports.default = Custom;\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Circle,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tCircle = (function(superClass) {\n\t  extend(Circle, superClass);\n\n\t  function Circle() {\n\t    return Circle.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Circle.prototype._declareDefaults = function() {\n\t    Circle.__super__._declareDefaults.apply(this, arguments);\n\t    return this._defaults.shape = 'ellipse';\n\t  };\n\n\t  Circle.prototype._draw = function() {\n\t    var rx, ry;\n\t    rx = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    ry = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    this._setAttrIfChanged('rx', rx);\n\t    this._setAttrIfChanged('ry', ry);\n\t    this._setAttrIfChanged('cx', this._props.width / 2);\n\t    this._setAttrIfChanged('cy', this._props.height / 2);\n\t    return Circle.__super__._draw.apply(this, arguments);\n\t  };\n\n\t  Circle.prototype._getLength = function() {\n\t    var radiusX, radiusY;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    return 2 * Math.PI * Math.sqrt((radiusX * radiusX + radiusY * radiusY) / 2);\n\t  };\n\n\t  return Circle;\n\n\t})(Bit);\n\n\tmodule.exports = Circle;\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Line,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tLine = (function(superClass) {\n\t  extend(Line, superClass);\n\n\t  function Line() {\n\t    return Line.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Line.prototype._declareDefaults = function() {\n\t    Line.__super__._declareDefaults.apply(this, arguments);\n\t    return this._defaults.tag = 'line';\n\t  };\n\n\t  Line.prototype._draw = function() {\n\t    var radiusX, x, y;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    x = this._props.width / 2;\n\t    y = this._props.height / 2;\n\t    this._setAttrIfChanged('x1', x - radiusX);\n\t    this._setAttrIfChanged('x2', x + radiusX);\n\t    this._setAttrIfChanged('y1', y);\n\t    this._setAttrIfChanged('y2', y);\n\t    return Line.__super__._draw.apply(this, arguments);\n\t  };\n\n\t  return Line;\n\n\t})(Bit);\n\n\tmodule.exports = Line;\n\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Zigzag,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tZigzag = (function(superClass) {\n\t  extend(Zigzag, superClass);\n\n\t  function Zigzag() {\n\t    return Zigzag.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Zigzag.prototype._declareDefaults = function() {\n\t    Zigzag.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'path';\n\t    return this._defaults.points = 3;\n\t  };\n\n\t  Zigzag.prototype._draw = function() {\n\t    var currentX, currentY, delta, i, isPoints, isRadiusX, isRadiusY, j, length, p, points, radiusX, radiusY, ref, stepX, x, y, yFlip;\n\t    Zigzag.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    if (!this._props.points) {\n\t      return;\n\t    }\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    isPoints = p.points === this._prevPoints;\n\t    if (isRadiusX && isRadiusY && isPoints) {\n\t      return;\n\t    }\n\t    x = p.width / 2;\n\t    y = p.height / 2;\n\t    currentX = x - radiusX;\n\t    currentY = y;\n\t    stepX = (2 * radiusX) / (p.points - 1);\n\t    yFlip = -1;\n\t    delta = Math.sqrt(stepX * stepX + radiusY * radiusY);\n\t    length = -delta;\n\t    points = \"M\" + currentX + \", \" + y + \" \";\n\t    for (i = j = 0, ref = p.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t      points += \"L\" + currentX + \", \" + currentY + \" \";\n\t      currentX += stepX;\n\t      length += delta;\n\t      currentY = yFlip === -1 ? y - radiusY : y;\n\t      yFlip = -yFlip;\n\t    }\n\t    this._length = length;\n\t    this.el.setAttribute('d', points);\n\t    this._prevPoints = p.points;\n\t    this._prevRadiusX = radiusX;\n\t    return this._prevRadiusY = radiusY;\n\t  };\n\n\t  Zigzag.prototype._getLength = function() {\n\t    return this._length;\n\t  };\n\n\t  return Zigzag;\n\n\t})(Bit);\n\n\tmodule.exports = Zigzag;\n\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Rect,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tRect = (function(superClass) {\n\t  extend(Rect, superClass);\n\n\t  function Rect() {\n\t    return Rect.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Rect.prototype._declareDefaults = function() {\n\t    Rect.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'rect';\n\t    this._defaults.rx = 0;\n\t    return this._defaults.ry = 0;\n\t  };\n\n\t  Rect.prototype._draw = function() {\n\t    var p, radiusX, radiusY;\n\t    Rect.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    radiusX = p.radiusX != null ? p.radiusX : p.radius;\n\t    radiusY = p.radiusY != null ? p.radiusY : p.radius;\n\t    this._setAttrIfChanged('width', 2 * radiusX);\n\t    this._setAttrIfChanged('height', 2 * radiusY);\n\t    this._setAttrIfChanged('x', (p.width / 2) - radiusX);\n\t    this._setAttrIfChanged('y', (p.height / 2) - radiusY);\n\t    this._setAttrIfChanged('rx', p.rx);\n\t    return this._setAttrIfChanged('ry', p.ry);\n\t  };\n\n\t  Rect.prototype._getLength = function() {\n\t    var radiusX, radiusY;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    return 2 * (2 * radiusX + 2 * radiusY);\n\t  };\n\n\t  return Rect;\n\n\t})(Bit);\n\n\tmodule.exports = Rect;\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Polygon, h,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\th = __webpack_require__(71);\n\n\tPolygon = (function(superClass) {\n\t  extend(Polygon, superClass);\n\n\t  function Polygon() {\n\t    return Polygon.__super__.constructor.apply(this, arguments);\n\t  }\n\n\n\t  /*\n\t    Method to declare defaults.\n\t    @overrides @ Bit\n\t   */\n\n\t  Polygon.prototype._declareDefaults = function() {\n\t    Polygon.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'path';\n\t    return this._defaults.points = 3;\n\t  };\n\n\n\t  /*\n\t    Method to draw the shape.\n\t    @overrides @ Bit\n\t   */\n\n\t  Polygon.prototype._draw = function() {\n\t    var char, d, i, isPoints, isRadiusX, isRadiusY, j, k, len, p, point, radiusX, radiusY, ref, ref1, step;\n\t    p = this._props;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    isPoints = p.points === this._prevPoints;\n\t    if (!(isRadiusX && isRadiusY && isPoints)) {\n\t      step = 360 / this._props.points;\n\t      if (this._radialPoints == null) {\n\t        this._radialPoints = [];\n\t      } else {\n\t        this._radialPoints.length = 0;\n\t      }\n\t      for (i = j = 0, ref = this._props.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t        this._radialPoints.push(h.getRadialPoint({\n\t          radius: this._props.radius,\n\t          radiusX: this._props.radiusX,\n\t          radiusY: this._props.radiusY,\n\t          angle: i * step,\n\t          center: {\n\t            x: p.width / 2,\n\t            y: p.height / 2\n\t          }\n\t        }));\n\t      }\n\t      d = '';\n\t      ref1 = this._radialPoints;\n\t      for (i = k = 0, len = ref1.length; k < len; i = ++k) {\n\t        point = ref1[i];\n\t        char = i === 0 ? 'M' : 'L';\n\t        d += \"\" + char + (point.x.toFixed(4)) + \",\" + (point.y.toFixed(4)) + \" \";\n\t      }\n\t      this._prevPoints = p.points;\n\t      this._prevRadiusX = radiusX;\n\t      this._prevRadiusY = radiusY;\n\t      this.el.setAttribute('d', (d += 'z'));\n\t    }\n\t    return Polygon.__super__._draw.apply(this, arguments);\n\t  };\n\n\n\t  /*\n\t    Method to get length of the shape.\n\t    @overrides @ Bit\n\t   */\n\n\t  Polygon.prototype._getLength = function() {\n\t    return this._getPointsPerimiter(this._radialPoints);\n\t  };\n\n\t  return Polygon;\n\n\t})(Bit);\n\n\tmodule.exports = Polygon;\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Cross,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tCross = (function(superClass) {\n\t  extend(Cross, superClass);\n\n\t  function Cross() {\n\t    return Cross.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Cross.prototype._declareDefaults = function() {\n\t    Cross.__super__._declareDefaults.apply(this, arguments);\n\t    return this._defaults.tag = 'path';\n\t  };\n\n\t  Cross.prototype._draw = function() {\n\t    var d, isRadiusX, isRadiusY, line1, line2, p, radiusX, radiusY, x, x1, x2, y, y1, y2;\n\t    Cross.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    if (isRadiusX && isRadiusY) {\n\t      return;\n\t    }\n\t    x = this._props.width / 2;\n\t    y = this._props.height / 2;\n\t    x1 = x - radiusX;\n\t    x2 = x + radiusX;\n\t    line1 = \"M\" + x1 + \",\" + y + \" L\" + x2 + \",\" + y;\n\t    y1 = y - radiusY;\n\t    y2 = y + radiusY;\n\t    line2 = \"M\" + x + \",\" + y1 + \" L\" + x + \",\" + y2;\n\t    d = line1 + \" \" + line2;\n\t    this.el.setAttribute('d', d);\n\t    this._prevRadiusX = radiusX;\n\t    return this._prevRadiusY = radiusY;\n\t  };\n\n\t  Cross.prototype._getLength = function() {\n\t    var radiusX, radiusY;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    return 2 * (radiusX + radiusY);\n\t  };\n\n\t  return Cross;\n\n\t})(Bit);\n\n\tmodule.exports = Cross;\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _bit = __webpack_require__(73);\n\n\tvar _bit2 = _interopRequireDefault(_bit);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Curve = function (_Bit) {\n\t  (0, _inherits3.default)(Curve, _Bit);\n\n\t  function Curve() {\n\t    (0, _classCallCheck3.default)(this, Curve);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Bit.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\t  Curve.prototype._declareDefaults = function _declareDefaults() {\n\t    _Bit.prototype._declareDefaults.call(this);\n\t    this._defaults.tag = 'path';\n\t  };\n\t  /*\n\t    Method to draw the module.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\n\t  Curve.prototype._draw = function _draw() {\n\t    _Bit.prototype._draw.call(this);\n\t    var p = this._props;\n\n\t    var radiusX = p.radiusX != null ? p.radiusX : p.radius;\n\t    var radiusY = p.radiusY != null ? p.radiusY : p.radius;\n\n\t    var isRadiusX = radiusX === this._prevRadiusX;\n\t    var isRadiusY = radiusY === this._prevRadiusY;\n\t    var isPoints = p.points === this._prevPoints;\n\t    // skip if nothing changed\n\t    if (isRadiusX && isRadiusY && isPoints) {\n\t      return;\n\t    }\n\n\t    var x = p.width / 2;\n\t    var y = p.height / 2;\n\t    var x1 = x - radiusX;\n\t    var x2 = x + radiusX;\n\n\t    var d = 'M' + x1 + ' ' + y + ' Q ' + x + ' ' + (y - 2 * radiusY) + ' ' + x2 + ' ' + y;\n\n\t    // set the `d` attribute and save it to `_prevD`\n\t    this.el.setAttribute('d', d);\n\t    // save the properties\n\t    this._prevPoints = p.points;\n\t    this._prevRadiusX = radiusX;\n\t    this._prevRadiusY = radiusY;\n\t  };\n\n\t  Curve.prototype._getLength = function _getLength() {\n\t    var p = this._props;\n\n\t    var radiusX = p.radiusX != null ? p.radiusX : p.radius;\n\t    var radiusY = p.radiusY != null ? p.radiusY : p.radius;\n\n\t    var dRadius = radiusX + radiusY;\n\t    var sqrt = Math.sqrt((3 * radiusX + radiusY) * (radiusX + 3 * radiusY));\n\n\t    return .5 * Math.PI * (3 * dRadius - sqrt);\n\t  };\n\n\t  return Curve;\n\t}(_bit2.default); // istanbul ignore next\n\n\n\texports.default = Curve;\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Equal,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(73)[\"default\"] || __webpack_require__(73);\n\n\tEqual = (function(superClass) {\n\t  extend(Equal, superClass);\n\n\t  function Equal() {\n\t    return Equal.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Equal.prototype._declareDefaults = function() {\n\t    Equal.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'path';\n\t    return this._defaults.points = 2;\n\t  };\n\n\t  Equal.prototype._draw = function() {\n\t    var d, i, isPoints, isRadiusX, isRadiusY, j, p, radiusX, radiusY, ref, x, x1, x2, y, yStart, yStep;\n\t    Equal.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    if (!this._props.points) {\n\t      return;\n\t    }\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    isPoints = p.points === this._prevPoints;\n\t    if (isRadiusX && isRadiusY && isPoints) {\n\t      return;\n\t    }\n\t    x = this._props.width / 2;\n\t    y = this._props.height / 2;\n\t    x1 = x - radiusX;\n\t    x2 = x + radiusX;\n\t    d = '';\n\t    yStep = 2 * radiusY / (this._props.points - 1);\n\t    yStart = y - radiusY;\n\t    for (i = j = 0, ref = this._props.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t      y = \"\" + (i * yStep + yStart);\n\t      d += \"M\" + x1 + \", \" + y + \" L\" + x2 + \", \" + y + \" \";\n\t    }\n\t    this.el.setAttribute('d', d);\n\t    this._prevPoints = p.points;\n\t    this._prevRadiusX = radiusX;\n\t    return this._prevRadiusY = radiusY;\n\t  };\n\n\t  Equal.prototype._getLength = function() {\n\t    return 2 * (this._props.radiusX != null ? this._props.radiusX : this._props.radius);\n\t  };\n\n\t  return Equal;\n\n\t})(Bit);\n\n\tmodule.exports = Equal;\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _module = __webpack_require__(84);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tvar _thenable = __webpack_require__(99);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tvar _tunable = __webpack_require__(116);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tvar _tweenable = __webpack_require__(100);\n\n\tvar _tweenable2 = _interopRequireDefault(_tweenable);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar h = __webpack_require__(71);\n\tvar Bit = __webpack_require__(73);\n\tvar shapesMap = __webpack_require__(72);\n\n\t// TODO\n\t//  - refactor\n\t//    - add setIfChanged to Module\n\t//  --\n\t//  - tween for every prop\n\n\tvar Shape = function (_Tunable) {\n\t  (0, _inherits3.default)(Shape, _Tunable);\n\n\t  function Shape() {\n\t    (0, _classCallCheck3.default)(this, Shape);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tunable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t  */\n\t  Shape.prototype._declareDefaults = function _declareDefaults() {\n\t    // DEFAULTS / APIs\n\t    this._defaults = {\n\t      // where to append the module to [selector, HTMLElement]\n\t      parent: document.body,\n\t      // class name for the `el`\n\t      className: '',\n\t      // Possible values: [circle, line, zigzag, rect, polygon, cross, equal ]\n\t      shape: 'circle',\n\t      // ∆ :: Possible values: [color name, rgb, rgba, hex]\n\t      stroke: 'transparent',\n\t      // ∆ :: Possible values: [ 0..1 ]\n\t      strokeOpacity: 1,\n\t      // Possible values: ['butt' | 'round' | 'square']\n\t      strokeLinecap: '',\n\t      // ∆ :: Possible values: [ number ]\n\t      strokeWidth: 2,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      strokeDasharray: 0,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      strokeDashoffset: 0,\n\t      // ∆ :: Possible values: [color name, rgb, rgba, hex]\n\t      fill: 'deeppink',\n\t      // ∆ :: Possible values: [ 0..1 ]\n\t      fillOpacity: 1,\n\t      // {Boolean} - if should hide module with `opacity` instead of `display`\n\t      isSoftHide: true,\n\t      // {Boolean} - if should trigger composite layer for the `el`\n\t      isForce3d: false,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      left: '50%',\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      top: '50%',\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      x: 0,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      y: 0,\n\t      // ∆ :: Possible values: [ number ]\n\t      angle: 0,\n\t      // ∆ :: Possible values: [ number ]\n\t      scale: 1,\n\t      // ∆ :: Possible values: [ number ] Fallbacks to `scale`.\n\t      scaleX: null,\n\t      // ∆ :: Possible values: [ number ] Fallbacks to `scale`.\n\t      scaleY: null,\n\t      // ∆ :: Possible values: [ number, string ]\n\t      origin: '50% 50%',\n\t      // ∆ :: Possible values: [ 0..1 ]\n\t      opacity: 1,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      rx: 0,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      ry: 0,\n\t      // ∆ :: Possible values: [ number ]\n\t      points: 3,\n\t      // ∆ :: Possible values: [ number ]\n\t      radius: 50,\n\t      // ∆ :: Possible values: [ number ]\n\t      radiusX: null,\n\t      // ∆ :: Possible values: [ number ]\n\t      radiusY: null,\n\t      // Possible values: [ boolean ]\n\t      isShowStart: false,\n\t      // Possible values: [ boolean ]\n\t      isShowEnd: true,\n\t      // Possible values: [ boolean ]\n\t      isRefreshState: true,\n\t      // Possible values: [ number > 0 ]\n\t      duration: 400,\n\t      // Possible values: [ number ]\n\n\t      /* technical ones: */\n\t      // explicit width of the module canvas\n\t      width: null,\n\t      // explicit height of the module canvas\n\t      height: null,\n\t      // Possible values: [ number ]\n\t      // sizeGap:          0,\n\t      /* [boolean] :: If should have child shape. */\n\t      isWithShape: true,\n\t      // context for all the callbacks\n\t      callbacksContext: this\n\t    };\n\t  };\n\t  /*\n\t    Method to start the animation with optional new options.\n\t    @public\n\t    @overrides @ Tunable\n\t    @param {Object} New options to set on the run.\n\t    @returns {Object} this.\n\t  */\n\n\n\t  Shape.prototype.tune = function tune(o) {\n\t    _Tunable.prototype.tune.call(this, o);\n\t    // update shapeModule's size to the max in `then` chain\n\t    this._getMaxSizeInChain();\n\t    return this;\n\t  };\n\t  /*\n\t    Method to create a then record for the module.\n\t    @public\n\t    @overrides @ Thenable\n\t    @param    {Object} Options for the next animation.\n\t    @returns  {Object} this.\n\t  */\n\n\n\t  Shape.prototype.then = function then(o) {\n\t    // this._makeTimeline()\n\t    _Tunable.prototype.then.call(this, o);\n\t    // update shapeModule's size to the max in `then` chain\n\t    this._getMaxSizeInChain();\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to declare variables.\n\t    @overrides Thenable\n\t  */\n\n\n\t  Shape.prototype._vars = function _vars() {\n\t    // call _vars method on Thenable\n\t    _Tunable.prototype._vars.call(this);\n\t    this._lastSet = {};\n\t    // save previous module in the chain\n\t    this._prevChainModule = this._o.prevChainModule;\n\t    // should draw on foreign svg canvas\n\t    this.isForeign = !!this._o.ctx;\n\t    // this._o.isTimelineLess = true;\n\t    // should take an svg element as self bit\n\t    return this.isForeignBit = !!this._o.shape;\n\t  };\n\t  /*\n\t    Method to initialize modules presentation.\n\t    @private\n\t    @overrides Module\n\t  */\n\n\n\t  Shape.prototype._render = function _render() {\n\t    if (!this._isRendered && !this._isChained) {\n\t      // create `mojs` shape element\n\t      this.el = document.createElement('div');\n\t      // set name on the `el`\n\t      this.el.setAttribute('data-name', 'mojs-shape');\n\t      // set class on the `el`\n\t      this.el.setAttribute('class', this._props.className);\n\t      // create shape module\n\t      this._createShape();\n\t      // append `el` to parent\n\t      this._props.parent.appendChild(this.el);\n\t      // set position styles on the el\n\t      this._setElStyles();\n\t      // set initial position for the first module in the chain\n\t      this._setProgress(0, 0);\n\t      // show at start if `isShowStart`\n\t      if (this._props.isShowStart) {\n\t        this._show();\n\t      } else {\n\t        this._hide();\n\t      }\n\t      // set `_isRendered` hatch\n\t      this._isRendered = true;\n\t    } else if (this._isChained) {\n\t      // save elements from master module\n\t      this.el = this._masterModule.el;\n\t      this.shapeModule = this._masterModule.shapeModule;\n\t    }\n\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set el styles on initialization.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._setElStyles = function _setElStyles() {\n\t    if (!this.el) {\n\t      return;\n\t    }\n\t    // if (!this.isForeign) {\n\t    var p = this._props,\n\t        style = this.el.style,\n\t        width = p.shapeWidth,\n\t        height = p.shapeHeight;\n\n\t    style.position = 'absolute';\n\t    this._setElSizeStyles(width, height);\n\n\t    if (p.isForce3d) {\n\t      var name = 'backface-visibility';\n\t      style['' + name] = 'hidden';\n\t      style['' + h.prefix.css + name] = 'hidden';\n\t    }\n\t    // }\n\t  };\n\t  /*\n\t    Method to set `width`/`height`/`margins` to the `el` styles.\n\t    @param {Number} Width.\n\t    @param {height} Height.\n\t  */\n\n\n\t  Shape.prototype._setElSizeStyles = function _setElSizeStyles(width, height) {\n\t    var style = this.el.style;\n\t    style.width = width + 'px';\n\t    style.height = height + 'px';\n\t    style['margin-left'] = -width / 2 + 'px';\n\t    style['margin-top'] = -height / 2 + 'px';\n\t  };\n\t  /*\n\t    Method to draw shape.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._draw = function _draw() {\n\t    if (!this.shapeModule) {\n\t      return;\n\t    }\n\n\t    var p = this._props,\n\t        bP = this.shapeModule._props;\n\t    // set props on bit\n\t    // bP.x                    = this._origin.x;\n\t    // bP.y                    = this._origin.y;\n\t    bP.rx = p.rx;\n\t    bP.ry = p.ry;\n\t    bP.stroke = p.stroke;\n\t    bP['stroke-width'] = p.strokeWidth;\n\t    bP['stroke-opacity'] = p.strokeOpacity;\n\t    bP['stroke-dasharray'] = p.strokeDasharray;\n\t    bP['stroke-dashoffset'] = p.strokeDashoffset;\n\t    bP['stroke-linecap'] = p.strokeLinecap;\n\t    bP['fill'] = p.fill;\n\t    bP['fill-opacity'] = p.fillOpacity;\n\t    bP.radius = p.radius;\n\t    bP.radiusX = p.radiusX;\n\t    bP.radiusY = p.radiusY;\n\t    bP.points = p.points;\n\n\t    this.shapeModule._draw();\n\t    this._drawEl();\n\t  };\n\t  /*\n\t    Method to set current modules props to main div el.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._drawEl = function _drawEl() {\n\t    // return;\n\t    if (this.el == null) {\n\t      return true;\n\t    }\n\t    var p = this._props;\n\t    var style = this.el.style;\n\n\t    // style.opacity = p.opacity;\n\t    this._isPropChanged('opacity') && (style.opacity = p.opacity);\n\t    if (!this.isForeign) {\n\t      this._isPropChanged('left') && (style.left = p.left);\n\t      this._isPropChanged('top') && (style.top = p.top);\n\n\t      var isX = this._isPropChanged('x'),\n\t          isY = this._isPropChanged('y'),\n\t          isTranslate = isX || isY,\n\t          isScaleX = this._isPropChanged('scaleX'),\n\t          isScaleY = this._isPropChanged('scaleY'),\n\t          isScale = this._isPropChanged('scale'),\n\t          isScale = isScale || isScaleX || isScaleY,\n\t          isRotate = this._isPropChanged('angle');\n\n\t      if (isTranslate || isScale || isRotate) {\n\t        var transform = this._fillTransform();\n\t        style[h.prefix.css + 'transform'] = transform;\n\t        style['transform'] = transform;\n\t      }\n\n\t      if (this._isPropChanged('origin') || this._deltas['origin']) {\n\t        var origin = this._fillOrigin();\n\t        style[h.prefix.css + 'transform-origin'] = origin;\n\t        style['transform-origin'] = origin;\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to check if property changed after the latest check.\n\t    @private\n\t    @param {String} Name of the property to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Shape.prototype._isPropChanged = function _isPropChanged(name) {\n\t    // if there is no recod for the property - create it\n\t    if (this._lastSet[name] == null) {\n\t      this._lastSet[name] = {};\n\t    }\n\t    if (this._lastSet[name].value !== this._props[name]) {\n\t      this._lastSet[name].value = this._props[name];\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  };\n\t  /*\n\t    Method to tune new option on run.\n\t    @private\n\t    @override @ Module\n\t    @param {Object}  Option to tune on run.\n\t  */\n\n\n\t  Shape.prototype._tuneNewOptions = function _tuneNewOptions(o) {\n\t    // call super on Module\n\t    _Tunable.prototype._tuneNewOptions.call(this, o);\n\t    // return if empty object\n\t    if (!(o != null && (0, _keys2.default)(o).length)) {\n\t      return 1;\n\t    }\n\n\t    // this._calcSize();\n\t    this._setElStyles();\n\t  };\n\t  /*\n\t    Method to get max radiusX value.\n\t    @private\n\t    @param {String} Radius name.\n\t  */\n\n\n\t  Shape.prototype._getMaxRadius = function _getMaxRadius(name) {\n\t    var selfSize, selfSizeX;\n\t    selfSize = this._getRadiusSize('radius');\n\t    return this._getRadiusSize(name, selfSize);\n\t  };\n\t  /*\n\t    Method to increase calculated size based on easing.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._increaseSizeWithEasing = function _increaseSizeWithEasing() {\n\t    var p = this._props,\n\t        easing = this._o.easing,\n\t        isStringEasing = easing && typeof easing === 'string';\n\n\t    switch (isStringEasing && easing.toLowerCase()) {\n\t      case 'elastic.out':\n\t      case 'elastic.inout':\n\t        p.size *= 1.25;\n\t        break;\n\t      case 'back.out':\n\t      case 'back.inout':\n\t        p.size *= 1.1;\n\t    }\n\t  };\n\t  /*\n\t    Method to increase calculated size based on bit ratio.\n\t    @private\n\t  */\n\t  // _increaseSizeWithBitRatio () {\n\t  //   var p   = this._props;\n\t  //   // p.size *= this.shape._props.ratio;\n\t  //   p.size += 2 * p.sizeGap;\n\t  // }\n\t  /*\n\t    Method to get maximum radius size with optional fallback.\n\t    @private\n\t    @param {Object}\n\t      @param key {String} Name of the radius - [radius|radiusX|radiusY].\n\t      @param @optional fallback {Number}  Optional number to set if there\n\t                                          is no value for the key.\n\t  */\n\n\n\t  Shape.prototype._getRadiusSize = function _getRadiusSize(name) {\n\t    var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t    var delta = this._deltas[name];\n\t    // if value is delta value\n\t    if (delta != null) {\n\t      // get maximum number between start and end values of the delta\n\t      return Math.max(Math.abs(delta.end), Math.abs(delta.start));\n\t    } else if (this._props[name] != null) {\n\t      // else get the value from props object\n\t      return parseFloat(this._props[name]);\n\t    } else {\n\t      return fallback;\n\t    }\n\t  };\n\t  /*\n\t    Method to get max shape canvas size and save it to _props.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._getShapeSize = function _getShapeSize() {\n\t    var p = this._props,\n\n\t    // get maximum stroke value\n\t    stroke = this._getMaxStroke();\n\t    // save shape `width` and `height` to `_props`\n\t    p.shapeWidth = p.width != null ? p.width : 2 * this._getMaxRadius('radiusX') + stroke;\n\n\t    p.shapeHeight = p.height != null ? p.height : 2 * this._getMaxRadius('radiusY') + stroke;\n\t  };\n\t  /*\n\t    Method to create shape.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._createShape = function _createShape() {\n\t    // calculate max shape canvas size and set to _props\n\t    this._getShapeSize();\n\t    // don't create actual shape if !`isWithShape`\n\t    if (!this._props.isWithShape) {\n\t      return;\n\t    }\n\n\t    var p = this._props;\n\t    // get shape's class\n\t    var Shape = shapesMap.getShape(this._props.shape);\n\t    // create `_shape` module\n\t    this.shapeModule = new Shape({\n\t      width: p.shapeWidth,\n\t      height: p.shapeHeight,\n\t      parent: this.el\n\t    });\n\t  };\n\t  /*\n\t    Method to get max size in `then` chain\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._getMaxSizeInChain = function _getMaxSizeInChain() {\n\t    var p = this._props,\n\t        maxW = 0,\n\t        maxH = 0;\n\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      this._modules[i]._getShapeSize();\n\t      maxW = Math.max(maxW, this._modules[i]._props.shapeWidth);\n\t      maxH = Math.max(maxH, this._modules[i]._props.shapeHeight);\n\t    }\n\n\t    this.shapeModule && this.shapeModule._setSize(maxW, maxH);\n\t    this._setElSizeStyles(maxW, maxH);\n\t  };\n\t  /*\n\t    Method to get max value of the strokeWidth.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._getMaxStroke = function _getMaxStroke() {\n\t    var p = this._props;\n\t    var dStroke = this._deltas['strokeWidth'];\n\t    return dStroke != null ? Math.max(dStroke.start, dStroke.end) : p.strokeWidth;\n\t  };\n\t  /*\n\t    Method to draw current progress of the deltas.\n\t    @private\n\t    @override @ Module\n\t    @param   {Number}  EasedProgress to set - [0..1].\n\t    @param   {Number}  Progress to set - [0..1].\n\t  */\n\n\n\t  Shape.prototype._setProgress = function _setProgress(easedProgress, progress) {\n\t    // call the super on Module\n\t    _module2.default.prototype._setProgress.call(this, easedProgress, progress);\n\t    // draw current progress\n\t    this._draw(easedProgress);\n\t  };\n\t  /*\n\t    Method to add callback overrides to passed object.\n\t    @private\n\t    @param {Object} Object to add the overrides to.\n\t  */\n\n\n\t  Shape.prototype._applyCallbackOverrides = function _applyCallbackOverrides(obj) {\n\t    var it = this,\n\t        p = this._props;\n\t    // specify control functions for the module\n\t    obj.callbackOverrides = {\n\t      onUpdate: function onUpdate(ep, p) {\n\t        return it._setProgress(ep, p);\n\t      },\n\t      onStart: function onStart(isFwd) {\n\t        // don't touch main `el` onStart in chained elements\n\t        if (it._isChained) {\n\t          return;\n\t        };\n\t        if (isFwd) {\n\t          it._show();\n\t        } else {\n\t          if (!p.isShowStart) {\n\t            it._hide();\n\t          }\n\t        }\n\t      },\n\t      onComplete: function onComplete(isFwd) {\n\t        // don't touch main `el` if not the last in `then` chain\n\t        if (!it._isLastInChain()) {\n\t          return;\n\t        }\n\t        if (isFwd) {\n\t          if (!p.isShowEnd) {\n\t            it._hide();\n\t          }\n\t        } else {\n\t          it._show();\n\t        }\n\t      },\n\t      onRefresh: function onRefresh(isBefore) {\n\t        p.isRefreshState && isBefore && it._refreshBefore();\n\t      }\n\t    };\n\t  };\n\t  /*\n\t    Method to setup tween and timeline options before creating them.\n\t    @override @ Tweenable\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._transformTweenOptions = function _transformTweenOptions() {\n\t    this._applyCallbackOverrides(this._o);\n\t  };\n\t  /*\n\t    Method to create transform string.\n\t    @private\n\t    @returns {String} Transform string.\n\t  */\n\n\n\t  Shape.prototype._fillTransform = function _fillTransform() {\n\t    var p = this._props,\n\t        scaleX = p.scaleX != null ? p.scaleX : p.scale,\n\t        scaleY = p.scaleY != null ? p.scaleY : p.scale,\n\t        scale = scaleX + ', ' + scaleY;\n\t    return 'translate(' + p.x + ', ' + p.y + ') rotate(' + p.angle + 'deg) scale(' + scale + ')';\n\t  };\n\t  /*\n\t    Method to create transform-origin string.\n\t    @private\n\t    @returns {String} Transform string.\n\t  */\n\n\n\t  Shape.prototype._fillOrigin = function _fillOrigin() {\n\t    var p = this._props,\n\t        str = '';\n\t    for (var i = 0; i < p.origin.length; i++) {\n\t      str += p.origin[i].string + ' ';\n\t    }\n\t    return str;\n\t  };\n\t  /*\n\t    Method to refresh state befor startTime.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._refreshBefore = function _refreshBefore() {\n\t    // call setProgress with eased and normal progress\n\t    this._setProgress(this.tween._props.easing(0), 0);\n\n\t    if (this._props.isShowStart) {\n\t      this._show();\n\t    } else {\n\t      this._hide();\n\t    }\n\t  };\n\t  /*\n\t    Method that gets called on `soft` show of the module,\n\t    it should restore transform styles of the module.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Shape.prototype._showByTransform = function _showByTransform() {\n\t    // reset the cache of the scale prop\n\t    this._lastSet.scale = null;\n\t    // draw el accroding to it's props\n\t    this._drawEl();\n\t  };\n\n\t  return Shape;\n\t}(_tunable2.default);\n\n\texports.default = Shape;\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(96), __esModule: true };\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(97);\n\tmodule.exports = __webpack_require__(14).Object.keys;\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 Object.keys(O)\n\tvar toObject = __webpack_require__(49)\n\t  , $keys    = __webpack_require__(33);\n\n\t__webpack_require__(98)('keys', function(){\n\t  return function keys(it){\n\t    return $keys(toObject(it));\n\t  };\n\t});\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(12)\n\t  , core    = __webpack_require__(14)\n\t  , fails   = __webpack_require__(23);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _tweenable = __webpack_require__(100);\n\n\tvar _tweenable2 = _interopRequireDefault(_tweenable);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  The Thenable class adds .then public method and\n\t  the ability to chain API calls.\n\t*/\n\tvar Thenable = function (_Tweenable) {\n\t  (0, _inherits3.default)(Thenable, _Tweenable);\n\n\t  function Thenable() {\n\t    (0, _classCallCheck3.default)(this, Thenable);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tweenable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to create a then record for the module.\n\t    @public\n\t    @param    {Object} Options for the next animation.\n\t    @returns  {Object} this.\n\t  */\n\t  Thenable.prototype.then = function then(o) {\n\t    // return if nothing was passed\n\t    if (o == null || !(0, _keys2.default)(o).length) {\n\t      return 1;\n\t    }\n\t    // merge then options with the current ones\n\t    var prevRecord = this._history[this._history.length - 1],\n\t        prevModule = this._modules[this._modules.length - 1],\n\t        merged = this._mergeThenOptions(prevRecord, o);\n\n\t    this._resetMergedFlags(merged);\n\t    // create a submodule of the same type as the master module\n\t    var module = new this.constructor(merged);\n\t    // set `this` as amster module of child module\n\t    module._masterModule = this;\n\t    // save the modules to the _modules array\n\t    this._modules.push(module);\n\t    // add module's tween into master timeline\n\t    this.timeline.append(module);\n\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to reset some flags on merged options object.\n\t    @private\n\t    @param   {Object} Options object.\n\t    @returns {Object} Options object.\n\t  */\n\n\n\t  Thenable.prototype._resetMergedFlags = function _resetMergedFlags(obj) {\n\t    // set the submodule to be without timeline for perf reasons\n\t    obj.isTimelineLess = true;\n\t    // reset isShowStart flag for the submodules\n\t    obj.isShowStart = false;\n\t    // reset isRefreshState flag for the submodules\n\t    obj.isRefreshState = false;\n\t    // set the submodule callbacks context\n\t    obj.callbacksContext = this._props.callbacksContext || this;\n\t    // set previous module\n\t    obj.prevChainModule = _h2.default.getLastItem(this._modules);\n\t    // pass the `this` as master module\n\t    obj.masterModule = this;\n\t    return obj;\n\t  };\n\t  /*\n\t    Method to initialize properties.\n\t    @private\n\t  */\n\n\n\t  Thenable.prototype._vars = function _vars() {\n\t    _Tweenable.prototype._vars.call(this);\n\t    // save _master module\n\t    this._masterModule = this._o.masterModule;\n\t    // set isChained flag based on prevChainModule option\n\t    this._isChained = !!this._masterModule;\n\t    // we are expect that the _o object\n\t    // have been already extended by defaults\n\t    var initialRecord = _h2.default.cloneObj(this._props);\n\t    for (var key in this._arrayPropertyMap) {\n\t      if (this._o[key]) {\n\t        var preParsed = this._parsePreArrayProperty(key, this._o[key]);\n\t        initialRecord[key] = preParsed;\n\t      }\n\t    }\n\n\t    this._history = [initialRecord];\n\t    // the array holds all modules in the then chain\n\t    this._modules = [this];\n\t    // the props that to exclude from then merge\n\t    this._nonMergeProps = { shape: 1 };\n\t  };\n\t  /*\n\t    Method to merge two options into one. Used in .then chains.\n\t    @private\n\t    @param {Object} Start options for the merge.\n\t    @param {Object} End options for the merge.\n\t    @returns {Object} Merged options.\n\t  */\n\n\n\t  Thenable.prototype._mergeThenOptions = function _mergeThenOptions(start, end) {\n\t    var o = {};\n\t    this._mergeStartLoop(o, start);\n\t    this._mergeEndLoop(o, start, end);\n\t    this._history.push(o);\n\t    return o;\n\t  };\n\t  /*\n\t    Method to pipe startValue of the delta.\n\t    @private\n\t    @param {String} Start property name.\n\t    @param {Any} Start property value.\n\t    @returns {Any} Start property value.\n\t  */\n\n\n\t  Thenable.prototype._checkStartValue = function _checkStartValue(name, value) {\n\t    return value;\n\t  };\n\t  /*\n\t    Originally part of the _mergeThenOptions.\n\t    Loops thru start object and copies all the props from it.\n\t    @param {Object} An object to copy in.\n\t    @parma {Object} Start options object.\n\t  */\n\n\n\t  Thenable.prototype._mergeStartLoop = function _mergeStartLoop(o, start) {\n\t    // loop thru start options object\n\t    for (var key in start) {\n\t      var value = start[key];\n\t      if (start[key] == null) {\n\t        continue;\n\t      };\n\t      // copy all values from start if not tween prop or duration\n\t      if (!_h2.default.isTweenProp(key) || key === 'duration') {\n\t        // if delta - copy only the end value\n\t        if (this._isDelta(value)) {\n\t          o[key] = _h2.default.getDeltaEnd(value);\n\t        } else {\n\t          o[key] = value;\n\t        }\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Originally part of the _mergeThenOptions.\n\t    Loops thru start object and merges all the props from it.\n\t    @param {Object} An object to copy in.\n\t    @parma {Object} Start options object.\n\t    @parma {Object} End options object.\n\t  */\n\n\n\t  Thenable.prototype._mergeEndLoop = function _mergeEndLoop(o, start, end) {\n\t    var endKeys = (0, _keys2.default)(end);\n\n\t    for (var key in end) {\n\t      // just copy parent option\n\t      if (key == 'parent') {\n\t        o[key] = end[key];continue;\n\t      };\n\n\t      // get key/value of the end object\n\t      // endKey - name of the property, endValue - value of the property\n\t      var endValue = end[key],\n\t          startValue = start[key] != null ? start[key] : this._defaults[key];\n\n\t      startValue = this._checkStartValue(key, startValue);\n\t      if (endValue == null) {\n\t        continue;\n\t      };\n\t      // make ∆ of start -> end\n\t      // if key name is radiusX/radiusY and\n\t      // the startValue is not set fallback to radius value\n\t      var isSubRadius = key === 'radiusX' || key === 'radiusY';\n\t      if (isSubRadius && startValue == null) {\n\t        startValue = start.radius;\n\t      }\n\n\t      var isSubRadius = key === 'scaleX' || key === 'scaleY';\n\t      if (isSubRadius && startValue == null) {\n\t        startValue = start.scale;\n\t      }\n\n\t      o[key] = this._mergeThenProperty(key, startValue, endValue);\n\t    }\n\t  };\n\t  /*\n\t    Method to merge `start` and `end` for a property in then record.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Start value of the property.\n\t    @param {Any}    End value of the property.\n\t  */\n\n\n\t  Thenable.prototype._mergeThenProperty = function _mergeThenProperty(key, startValue, endValue) {\n\t    // if isnt tween property\n\t    var isBoolean = typeof endValue === 'boolean',\n\t        curve,\n\t        easing;\n\n\t    if (!_h2.default.isTweenProp(key) && !this._nonMergeProps[key] && !isBoolean) {\n\n\t      if (_h2.default.isObject(endValue) && endValue.to != null) {\n\t        curve = endValue.curve;\n\t        easing = endValue.easing;\n\t        endValue = endValue.to;\n\t      }\n\n\t      // if end value is delta - just save it\n\t      if (this._isDelta(endValue)) {\n\t        return this._parseDeltaValues(key, endValue);\n\t      } else {\n\t        var parsedEndValue = this._parsePreArrayProperty(key, endValue);\n\t        // if end value is not delta - merge with start value\n\t        if (this._isDelta(startValue)) {\n\t          var _ref;\n\n\t          // if start value is delta - take the end value\n\t          // as start value of the new delta\n\t          return _ref = {}, _ref[_h2.default.getDeltaEnd(startValue)] = parsedEndValue, _ref.easing = easing, _ref.curve = curve, _ref;\n\t          // if both start and end value are not ∆ - make ∆\n\t        } else {\n\t          var _ref2;\n\n\t          return _ref2 = {}, _ref2[startValue] = parsedEndValue, _ref2.easing = easing, _ref2.curve = curve, _ref2;\n\t        }\n\t      }\n\t      // copy the tween values unattended\n\t    } else {\n\t      return endValue;\n\t    }\n\t  };\n\t  /*\n\t    Method to retreive array's length and return -1 for\n\t    all other types.\n\t    @private\n\t    @param {Array, Any} Array to get the width for.\n\t    @returns {Number} Array length or -1 if not array.\n\t  */\n\n\n\t  Thenable.prototype._getArrayLength = function _getArrayLength(arr) {\n\t    return _h2.default.isArray(arr) ? arr.length : -1;\n\t  };\n\t  /*\n\t    Method to check if the property is delta property.\n\t    @private\n\t    @param {Any} Parameter value to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Thenable.prototype._isDelta = function _isDelta(optionsValue) {\n\t    var isObject = _h2.default.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || _h2.default.isArray(optionsValue) || _h2.default.isDOM(optionsValue));\n\t  };\n\t  /*\n\t    Method to check if the module is first in `then` chain.\n\t    @private\n\t    @returns {Boolean} If the module is the first in module chain.\n\t  */\n\n\n\t  Thenable.prototype._isFirstInChain = function _isFirstInChain() {\n\t    return !this._masterModule;\n\t  };\n\t  /*\n\t    Method to check if the module is last in `then` chain.\n\t    @private\n\t    @returns {Boolean} If the module is the last in module chain.\n\t  */\n\n\n\t  Thenable.prototype._isLastInChain = function _isLastInChain() {\n\t    var master = this._masterModule;\n\t    // if there is no master field - check the modules length\n\t    // if module length is 1 thus there is no modules chain \n\t    // it is the last one, otherwise it isnt\n\t    if (!master) {\n\t      return this._modules.length === 1;\n\t    }\n\t    // if there is master - check if it is the last item in _modules chain\n\t    return this === _h2.default.getLastItem(master._modules);\n\t  };\n\n\t  return Thenable;\n\t}(_tweenable2.default);\n\n\texports.default = Thenable;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _module = __webpack_require__(84);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  Class to define a module ancestor\n\t  with timeline and tween options and functionality.\n\t  All runable modules should inherit from this class.\n\n\t  @class Tweenable\n\t*/\n\tvar Tweenable = function (_Module) {\n\t  (0, _inherits3.default)(Tweenable, _Module);\n\n\t  /*\n\t    `play` method for the timeline.\n\t    @public\n\t    @param {Number} Time shift.\n\t    @returns this.\n\t  */\n\t  Tweenable.prototype.play = function play() {\n\t    this.timeline.play.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `playBackward` method for the timeline.\n\t    @public\n\t    @param {Number} Time shift.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.playBackward = function playBackward() {\n\t    this.timeline.playBackward.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `pause` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.pause = function pause() {\n\t    this.timeline.pause.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `stop` method for the timeline.\n\t    @public\n\t    @param {Number} [0...1] Progress to set on stop.\n\t                            *Default* is `0` if `play`\n\t                            and `1` if `playBAckward`.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.stop = function stop() {\n\t    this.timeline.stop.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `reset` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.reset = function reset() {\n\t    this.timeline.reset.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `replay` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.replay = function replay() {\n\t    this.timeline.replay.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `replay` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.replayBackward = function replayBackward() {\n\t    this.timeline.replayBackward.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `resume` method for the timeline.\n\t    @public\n\t    @param {Number} Time shift.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.resume = function resume() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t    this.timeline.resume.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `setProgress` method for the timeline.\n\t    @public\n\t    @param {Number} [0...1] Progress value.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.setProgress = function setProgress() {\n\t    this.timeline.setProgress.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    setSpeed method for the timeline.\n\t    @param {Number} Speed value.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.setSpeed = function setSpeed(speed) {\n\t    this.timeline.setSpeed.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  function Tweenable() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Tweenable);\n\n\t    // pipe function for _o object\n\t    // before creating tween/timeline\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, _Module.call(this, o));\n\t    // super of Module\n\n\n\t    _this._transformTweenOptions();\n\t    // make tween only if isTweenLess option is not set\n\t    !_this._o.isTweenLess && _this._makeTween();\n\t    // make timeline only if isTimelineLess option is not set\n\t    !_this._o.isTimelineLess && _this._makeTimeline();\n\t    return _this;\n\t  }\n\t  /*\n\t    Placeholder method that should be overrided\n\t    and will be called before tween/timeline creation.\n\t    @private\n\t  */\n\n\n\t  Tweenable.prototype._transformTweenOptions = function _transformTweenOptions() {};\n\t  /*\n\t    Method to create tween.\n\t    @private\n\t  */\n\n\n\t  Tweenable.prototype._makeTween = function _makeTween() {\n\t    // pass callbacks context\n\t    this._o.callbacksContext = this._o.callbacksContext || this;\n\t    this.tween = new _tween2.default(this._o);\n\t    // make timeline property point to tween one is \"no timeline\" mode\n\t    this._o.isTimelineLess && (this.timeline = this.tween);\n\t  };\n\t  /*\n\t    Method to create timeline.\n\t    @private\n\t    @param {Object} Timeline's options.\n\t                    An object which contains \"timeline\" property with\n\t                    timeline options.\n\t  */\n\n\n\t  Tweenable.prototype._makeTimeline = function _makeTimeline() {\n\t    // pass callbacks context\n\t    this._o.timeline = this._o.timeline || {};\n\t    this._o.timeline.callbacksContext = this._o.callbacksContext || this;\n\t    this.timeline = new _timeline2.default(this._o.timeline);\n\t    // set the flag to indicate that real timeline is present\n\t    this._isTimeline = true;\n\t    // if tween exist - add it to the timeline there is some\n\t    // modules like burst and stagger that have no tween\n\t    this.tween && this.timeline.add(this.tween);\n\t  };\n\n\t  return Tweenable;\n\t}(_module2.default);\n\n\texports.default = Tweenable;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _tweener = __webpack_require__(102);\n\n\tvar _tweener2 = _interopRequireDefault(_tweener);\n\n\tvar _easing = __webpack_require__(105);\n\n\tvar _easing2 = _interopRequireDefault(_easing);\n\n\tvar _module = __webpack_require__(84);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t// import h from '../h';\n\tvar Tween = function (_Module) {\n\t  (0, _inherits3.default)(Tween, _Module);\n\n\t  /*\n\t    Method do declare defaults with this._defaults object.\n\t    @private\n\t  */\n\t  Tween.prototype._declareDefaults = function _declareDefaults() {\n\t    // DEFAULTS\n\t    this._defaults = {\n\t      /* duration of the tween [0..∞] */\n\t      duration: 350,\n\t      /* delay of the tween [-∞..∞] */\n\t      delay: 0,\n\t      /* repeat of the tween [0..∞], means how much to\n\t         repeat the tween regardless first run,\n\t         for instance repeat: 2 will make the tween run 3 times */\n\t      repeat: 0,\n\t      /* speed of playback [0..∞], speed that is less then 1\n\t         will slowdown playback, for instance .5 will make tween\n\t         run 2x slower. Speed of 2 will speedup the tween to 2x. */\n\t      speed: 1,\n\t      /*  flip onUpdate's progress on each even period.\n\t          note that callbacks order won't flip at least\n\t          for now (under consideration). */\n\t      isYoyo: false,\n\t      /* easing for the tween, could be any easing type [link to easing-types.md] */\n\t      easing: 'Sin.Out',\n\t      /*\n\t        Easing for backward direction of the tweenthe tween,\n\t        if `null` - fallbacks to `easing` property.\n\t        forward direction in `yoyo` period is treated as backward for the easing.\n\t      */\n\t      backwardEasing: null,\n\t      /* custom tween's name */\n\t      name: null,\n\t      /* custom tween's base name */\n\t      nameBase: 'Tween',\n\t      /*\n\t        onProgress callback runs before any other callback.\n\t        @param {Number}   The entire, not eased, progress\n\t                          of the tween regarding repeat option.\n\t        @param {Boolean}  The direction of the tween.\n\t                          `true` for forward direction.\n\t                          `false` for backward direction(tween runs in reverse).\n\t      */\n\t      onProgress: null,\n\t      /*\n\t        onStart callback runs on very start of the tween just after onProgress\n\t        one. Runs on very end of the tween if tween is reversed.\n\t        @param {Boolean}  Direction of the tween.\n\t                          `true` for forward direction.\n\t                          `false` for backward direction(tween runs in reverse).\n\t      */\n\t      onStart: null,\n\t      onRefresh: null,\n\t      onComplete: null,\n\t      onRepeatStart: null,\n\t      onRepeatComplete: null,\n\t      onFirstUpdate: null,\n\t      onUpdate: null,\n\t      isChained: false,\n\t      // playback callbacks\n\t      onPlaybackStart: null,\n\t      onPlaybackPause: null,\n\t      onPlaybackStop: null,\n\t      onPlaybackComplete: null,\n\t      // context which all callbacks will be called with\n\t      callbacksContext: null\n\t    };\n\t  };\n\t  /*\n\t    API method to play the Tween.\n\t    @public\n\t    @param  {Number} Shift time in milliseconds.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.play = function play() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t    if (this._state === 'play' && this._isRunning) {\n\t      return this;\n\t    }\n\t    this._props.isReversed = false;\n\t    this._subPlay(shift, 'play');\n\t    this._setPlaybackState('play');\n\t    return this;\n\t  };\n\t  /*\n\t    API method to play the Tween in reverse.\n\t    @public\n\t    @param  {Number} Shift time in milliseconds.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.playBackward = function playBackward() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t    if (this._state === 'reverse' && this._isRunning) {\n\t      return this;\n\t    }\n\t    this._props.isReversed = true;\n\t    this._subPlay(shift, 'reverse');\n\t    this._setPlaybackState('reverse');\n\t    return this;\n\t  };\n\t  /*\n\t    API method to pause Tween.\n\t    @public\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.pause = function pause() {\n\t    if (this._state === 'pause' || this._state === 'stop') {\n\t      return this;\n\t    }\n\t    this._removeFromTweener();\n\t    this._setPlaybackState('pause');\n\t    return this;\n\t  };\n\t  /*\n\t    API method to stop the Tween.\n\t    @public\n\t    @param   {Number} Progress [0..1] to set when stopped.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.stop = function stop(progress) {\n\t    if (this._state === 'stop') {\n\t      return this;\n\t    }\n\n\t    this._wasUknownUpdate = undefined;\n\n\t    var stopProc = progress != null ? progress\n\t    /* if no progress passsed - set 1 if tween\n\t       is playingBackward, otherwise set to 0 */\n\t    : this._state === 'reverse' ? 1 : 0;\n\n\t    this.setProgress(stopProc);\n\n\t    this.reset();\n\t    return this;\n\t  };\n\t  /*\n\t    API method to replay(restart) the Tween.\n\t    @public\n\t    @param   {Number} Shift time in milliseconds.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.replay = function replay() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t    this.reset();\n\t    this.play(shift);\n\t    return this;\n\t  };\n\t  /*\n\t    API method to replay(restart) backward the Tween.\n\t    @public\n\t    @param   {Number} Shift time in milliseconds.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.replayBackward = function replayBackward() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t    this.reset();\n\t    this.playBackward(shift);\n\t    return this;\n\t  };\n\t  /*\n\t    API method to resume the Tween.\n\t    @public\n\t    @param  {Number} Shift time in milliseconds.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.resume = function resume() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n\t    if (this._state !== 'pause') {\n\t      return this;\n\t    }\n\n\t    switch (this._prevState) {\n\t      case 'play':\n\t        this.play(shift);\n\t        break;\n\t      case 'reverse':\n\t        this.playBackward(shift);\n\t        break;\n\t    }\n\n\t    return this;\n\t  };\n\t  /*\n\t    API method to set progress on tween.\n\t    @public\n\t    @param {Number} Progress to set.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.setProgress = function setProgress(progress) {\n\t    var p = this._props;\n\t    // set start time if there is no one yet.\n\t    !p.startTime && this._setStartTime();\n\t    // reset play time\n\t    this._playTime = null;\n\t    // progress should be in range of [0..1]\n\t    progress < 0 && (progress = 0);\n\t    progress > 1 && (progress = 1);\n\t    // update self with calculated time\n\t    this._update(p.startTime - p.delay + progress * p.repeatTime);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set tween's speed.\n\t    @public\n\t    @param {Number} Speed value.\n\t    @returns this.\n\t  */\n\n\n\t  Tween.prototype.setSpeed = function setSpeed(speed) {\n\t    this._props.speed = speed;\n\t    // if playing - normalize _startTime and _prevTime to the current point.\n\t    if (this._state === 'play' || this._state === 'reverse') {\n\t      this._setResumeTime(this._state);\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to reset tween's state and properties.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tween.prototype.reset = function reset() {\n\t    this._removeFromTweener();\n\t    this._setPlaybackState('stop');\n\t    this._progressTime = 0;\n\t    this._isCompleted = false;\n\t    this._isStarted = false;\n\t    this._isFirstUpdate = false;\n\t    this._wasUknownUpdate = undefined;\n\t    this._prevTime = undefined;\n\t    this._prevYoyo = undefined;\n\t    // this._props.startTime  = undefined;\n\t    this._props.isReversed = false;\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to launch play. Used as launch\n\t    method for bothplay and reverse methods.\n\t    @private\n\t    @param  {Number} Shift time in milliseconds.\n\t    @param  {String} Play or reverse state.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype._subPlay = function _subPlay() {\n\t    var shift = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t    var state = arguments[1];\n\n\t    var resumeTime,\n\t        startTime,\n\t        p = this._props,\n\n\t    // check if direction of playback changes,\n\t    // if so, the _progressTime needs to be flipped\n\t    _state = this._state,\n\t        _prevState = this._prevState,\n\t        isPause = _state === 'pause',\n\t        wasPlay = _state === 'play' || isPause && _prevState === 'play',\n\t        wasReverse = _state === 'reverse' || isPause && _prevState === 'reverse',\n\t        isFlip = wasPlay && state === 'reverse' || wasReverse && state === 'play';\n\n\t    // if tween was ended, set progress to 0 if not, set to elapsed progress\n\t    this._progressTime = this._progressTime >= p.repeatTime ? 0 : this._progressTime;\n\t    // flip the _progressTime if playback direction changed\n\t    if (isFlip) {\n\t      this._progressTime = p.repeatTime - this._progressTime;\n\t    }\n\t    // set resume time and normalize prev/start times\n\t    this._setResumeTime(state, shift);\n\t    // add self to tweener = play\n\t    _tweener2.default.add(this);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set _resumeTime, _startTime and _prevTime.\n\t    @private\n\t    @param {String} Current state. [play, reverse]\n\t    @param {Number} Time shift. *Default* is 0.\n\t  */\n\n\n\t  Tween.prototype._setResumeTime = function _setResumeTime(state) {\n\t    var shift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t    // get current moment as resume time\n\t    this._resumeTime = performance.now();\n\t    // set start time regarding passed `shift` and `procTime`\n\t    var startTime = this._resumeTime - Math.abs(shift) - this._progressTime;\n\t    this._setStartTime(startTime, false);\n\t    // if we have prevTime - we need to normalize\n\t    // it for the current resume time\n\t    if (this._prevTime != null) {\n\t      this._prevTime = state === 'play' ? this._normPrevTimeForward() : this._props.endTime - this._progressTime;\n\t    }\n\t  };\n\t  /*\n\t    Method recalculate _prevTime for forward direction.\n\t    @private\n\t    @return {Number} Normalized prev time.\n\t  */\n\n\n\t  Tween.prototype._normPrevTimeForward = function _normPrevTimeForward() {\n\t    var p = this._props;\n\t    return p.startTime + this._progressTime - p.delay;\n\t  };\n\t  /*\n\t    Constructor of the class.\n\t    @private\n\t  */\n\n\n\t  function Tween() {\n\t    var _ret;\n\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Tween);\n\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, _Module.call(this, o));\n\n\t    _this._props.name == null && _this._setSelfName();\n\t    return _ret = _this, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t  /*\n\t    Method to set self name to generic one.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._setSelfName = function _setSelfName() {\n\t    var globalName = '_' + this._props.nameBase + 's';\n\t    // track amount of tweens globally\n\t    _tweener2.default[globalName] = _tweener2.default[globalName] == null ? 1 : ++_tweener2.default[globalName];\n\t    // and set generic tween's name  || Tween # ||\n\t    this._props.name = this._props.nameBase + ' ' + _tweener2.default[globalName];\n\t  };\n\t  /*\n\t    Method set playback state string.\n\t    @private\n\t    @param {String} State name\n\t  */\n\n\n\t  Tween.prototype._setPlaybackState = function _setPlaybackState(state) {\n\t    // save previous state\n\t    this._prevState = this._state;\n\t    this._state = state;\n\n\t    // callbacks\n\t    var wasPause = this._prevState === 'pause',\n\t        wasStop = this._prevState === 'stop',\n\t        wasPlay = this._prevState === 'play',\n\t        wasReverse = this._prevState === 'reverse',\n\t        wasPlaying = wasPlay || wasReverse,\n\t        wasStill = wasStop || wasPause;\n\n\t    if ((state === 'play' || state === 'reverse') && wasStill) {\n\t      this._playbackStart();\n\t    }\n\t    if (state === 'pause' && wasPlaying) {\n\t      this._playbackPause();\n\t    }\n\t    if (state === 'stop' && (wasPlaying || wasPause)) {\n\t      this._playbackStop();\n\t    }\n\t  };\n\t  /*\n\t    Method to declare some vars.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._vars = function _vars() {\n\t    this.progress = 0;\n\t    this._prevTime = undefined;\n\t    this._progressTime = 0;\n\t    this._negativeShift = 0;\n\t    this._state = 'stop';\n\t    // if negative delay was specified,\n\t    // save it to _negativeShift property and\n\t    // reset it back to 0\n\t    if (this._props.delay < 0) {\n\t      this._negativeShift = this._props.delay;\n\t      this._props.delay = 0;\n\t    }\n\n\t    return this._calcDimentions();\n\t  };\n\t  /*\n\t    Method to calculate tween's dimentions.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._calcDimentions = function _calcDimentions() {\n\t    this._props.time = this._props.duration + this._props.delay;\n\t    this._props.repeatTime = this._props.time * (this._props.repeat + 1);\n\t  };\n\t  /*\n\t    Method to extend defaults by options and put them in _props.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._extendDefaults = function _extendDefaults() {\n\t    // save callback overrides object with fallback to empty one\n\t    this._callbackOverrides = this._o.callbackOverrides || {};\n\t    delete this._o.callbackOverrides;\n\t    // call the _extendDefaults @ Module\n\t    _Module.prototype._extendDefaults.call(this);\n\n\t    var p = this._props;\n\t    p.easing = _easing2.default.parseEasing(p.easing);\n\t    p.easing._parent = this;\n\n\t    // parse only present backward easing to prevent parsing as `linear.none`\n\t    // because we need to fallback to `easing` in `_setProgress` method\n\t    if (p.backwardEasing != null) {\n\t      p.backwardEasing = _easing2.default.parseEasing(p.backwardEasing);\n\t      p.backwardEasing._parent = this;\n\t    }\n\t  };\n\t  /*\n\t    Method for setting start and end time to props.\n\t    @private\n\t    @param {Number(Timestamp)}, {Null} Start time.\n\t    @param {Boolean} Should reset flags.\n\t    @returns this\n\t  */\n\n\n\t  Tween.prototype._setStartTime = function _setStartTime(time) {\n\t    var isResetFlags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t    var p = this._props,\n\t        shiftTime = p.shiftTime || 0;\n\t    // reset flags\n\t    if (isResetFlags) {\n\t      this._isCompleted = false;this._isRepeatCompleted = false;\n\t      this._isStarted = false;\n\t    }\n\t    // set start time to passed time or to the current moment\n\t    var startTime = time == null ? performance.now() : time;\n\t    // calculate bounds\n\t    // - negativeShift is negative delay in options hash\n\t    // - shift time is shift of the parent\n\t    p.startTime = startTime + p.delay + this._negativeShift + shiftTime;\n\t    p.endTime = p.startTime + p.repeatTime - p.delay;\n\t    // set play time to the startTimes\n\t    // if playback controls are used - use _resumeTime as play time,\n\t    // else use shifted startTime -- shift is needed for timelines append chains\n\t    this._playTime = this._resumeTime != null ? this._resumeTime : startTime + shiftTime;\n\t    this._resumeTime = null;\n\n\t    return this;\n\t  };\n\t  /*\n\t    Method to update tween's progress.\n\t    @private\n\t    @param {Number} Current update time.\n\t    -- next params only present when parent Timeline calls the method.\n\t    @param {Number} Previous Timeline's update time.\n\t    @param {Boolean} Was parent in yoyo period.\n\t    @param {Number} [-1, 0, 1] If update is on edge.\n\t                   -1 = edge jump in negative direction.\n\t                    0 = no edge jump.\n\t                    1 = edge jump in positive direction.\n\t  */\n\n\n\t  Tween.prototype._update = function _update(time, timelinePrevTime, wasYoyo, onEdge) {\n\t    var p = this._props;\n\t    // if we don't the _prevTime thus the direction we are heading to,\n\t    // but prevTime was passed thus we are child of a Timeline\n\t    // set _prevTime to passed one and pretent that there was unknown\n\t    // update to not to block start/complete callbacks\n\t    if (this._prevTime == null && timelinePrevTime != null) {\n\n\t      if (this._props.speed && this._playTime) {\n\t        // play point + ( speed * delta )\n\t        this._prevTime = this._playTime + this._props.speed * (timelinePrevTime - this._playTime);\n\t      }\n\t      // this._prevTime = timelinePrevTime;\n\t      this._wasUknownUpdate = true;\n\t    }\n\n\t    // var before = time;\n\t    // cache vars\n\t    var startPoint = p.startTime - p.delay;\n\t    // if speed param was defined - calculate\n\t    // new time regarding speed\n\t    if (p.speed && this._playTime) {\n\t      // play point + ( speed * delta )\n\t      time = this._playTime + p.speed * (time - this._playTime);\n\t    }\n\n\t    // due to javascript precision issues, after speed mapping\n\t    // we can get very close number that was made from progress of 1\n\t    // and in fact represents `endTime` if so, set the time to `endTime`\n\t    if (Math.abs(p.endTime - time) < 0.00000001) {\n\t      time = p.endTime;\n\t    }\n\n\t    // if parent is onEdge but not very start nor very end\n\t    if (onEdge && wasYoyo != null) {\n\t      var T = this._getPeriod(time),\n\t          isYoyo = !!(p.isYoyo && this._props.repeat && T % 2 === 1);\n\n\t      // for timeline\n\t      // notify children about edge jump\n\t      if (this._timelines) {\n\t        for (var i = 0; i < this._timelines.length; i++) {\n\t          this._timelines[i]._update(time, timelinePrevTime, wasYoyo, onEdge);\n\t        }\n\t      }\n\t      // forward edge direction\n\t      if (onEdge === 1) {\n\t        // jumped from yoyo period?\n\t        if (wasYoyo) {\n\t          this._prevTime = time + 1;\n\t          this._repeatStart(time, isYoyo);\n\t          this._start(time, isYoyo);\n\t        } else {\n\t          this._prevTime = time - 1;\n\t          this._repeatComplete(time, isYoyo);\n\t          this._complete(time, isYoyo);\n\t        }\n\t        // backward edge direction\n\t      } else if (onEdge === -1) {\n\t        // jumped from yoyo period?\n\t        if (wasYoyo) {\n\t          this._prevTime = time - 1;\n\t          this._repeatComplete(time, isYoyo);\n\t          this._complete(time, isYoyo);\n\t        } else {\n\t          // call _start callbacks only if prev time was in active area\n\t          // not always true for append chains\n\t          if (this._prevTime >= p.startTime && this._prevTime <= p.endTime) {\n\t            this._prevTime = time + 1;\n\t            this._repeatStart(time, isYoyo);\n\t            this._start(time, isYoyo);\n\t            // reset isCOmpleted immediately to prevent onComplete cb\n\t            this._isCompleted = true;\n\t          }\n\t        }\n\t      }\n\t      // reset the _prevTime - drop one frame to undestand\n\t      // where we are heading\n\t      this._prevTime = undefined;\n\t    }\n\t    // if in active area and not ended - save progress time\n\t    // for pause/play purposes.\n\t    if (time > startPoint && time < p.endTime) {\n\t      this._progressTime = time - startPoint;\n\t    }\n\t    // else if not started or ended set progress time to 0\n\t    else if (time <= startPoint) {\n\t        this._progressTime = 0;\n\t      } else if (time >= p.endTime) {\n\t        // set progress time to repeat time + tiny cofficient\n\t        // to make it extend further than the end time\n\t        this._progressTime = p.repeatTime + .00000000001;\n\t      }\n\t    // reverse time if _props.isReversed is set\n\t    if (p.isReversed) {\n\t      time = p.endTime - this._progressTime;\n\t    }\n\t    // We need to know what direction we are heading to,\n\t    // so if we don't have the previous update value - this is very first\n\t    // update, - skip it entirely and wait for the next value\n\t    if (this._prevTime == null) {\n\t      this._prevTime = time;\n\t      this._wasUknownUpdate = true;\n\t      return false;\n\t    }\n\n\t    // ====== AFTER SKIPPED FRAME ======\n\n\t    // handle onProgress callback\n\t    if (time >= startPoint && time <= p.endTime) {\n\t      this._progress((time - startPoint) / p.repeatTime, time);\n\t    }\n\t    /*\n\t      if time is inside the active area of the tween.\n\t      active area is the area from start time to end time,\n\t      with all the repeat and delays in it\n\t    */\n\t    if (time >= p.startTime && time <= p.endTime) {\n\t      this._updateInActiveArea(time);\n\t    } else {\n\t      // if was in active area - update in inactive area but just once -\n\t      // right after the active area\n\t      if (this._isInActiveArea) {\n\t        this._updateInInactiveArea(time);\n\t      } else if (!this._isRefreshed) {\n\t        // onRefresh callback\n\t        // before startTime\n\t        if (time < p.startTime && this.progress !== 0) {\n\t          this._refresh(true);\n\t          this._isRefreshed = true;\n\t          // after endTime\n\t        }\n\t        // else if ( time > p.endTime ) { }\n\t      }\n\t    }\n\n\t    this._prevTime = time;\n\t    return time >= p.endTime || time <= startPoint;\n\t  };\n\t  /*\n\t    Method to handle tween's progress in inactive area.\n\t    @private\n\t    @param {Number} Current update time.\n\t  */\n\n\n\t  Tween.prototype._updateInInactiveArea = function _updateInInactiveArea(time) {\n\t    if (!this._isInActiveArea) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    // complete if time is larger then end time\n\t    if (time > p.endTime && !this._isCompleted) {\n\t      this._progress(1, time);\n\t      // get period number\n\t      var T = this._getPeriod(p.endTime),\n\t          isYoyo = p.isYoyo && T % 2 === 0;\n\n\t      this._setProgress(isYoyo ? 0 : 1, time, isYoyo);\n\t      this._repeatComplete(time, isYoyo);\n\t      this._complete(time, isYoyo);\n\t    }\n\t    // if was active and went to - inactive area \"-\"\n\t    if (time < this._prevTime && time < p.startTime && !this._isStarted && !this._isCompleted) {\n\t      // if was in active area and didn't fire onStart callback\n\t      this._progress(0, time, false);\n\t      this._setProgress(0, time, false);\n\t      this._isRepeatStart = false;\n\t      this._repeatStart(time, false);\n\t      this._start(time, false);\n\t    }\n\t    this._isInActiveArea = false;\n\t  };\n\t  /*\n\t    Method to handle tween's progress in active area.\n\t    @private\n\t    @param {Number} Current update time.\n\t  */\n\n\n\t  Tween.prototype._updateInActiveArea = function _updateInActiveArea(time) {\n\n\t    var props = this._props,\n\t        delayDuration = props.delay + props.duration,\n\t        startPoint = props.startTime - props.delay,\n\t        elapsed = (time - props.startTime + props.delay) % delayDuration,\n\t        TCount = Math.round((props.endTime - props.startTime + props.delay) / delayDuration),\n\t        T = this._getPeriod(time),\n\t        TValue = this._delayT,\n\t        prevT = this._getPeriod(this._prevTime),\n\t        TPrevValue = this._delayT;\n\n\t    // \"zero\" and \"one\" value regarding yoyo and it's period\n\t    var isYoyo = props.isYoyo && T % 2 === 1,\n\t        isYoyoPrev = props.isYoyo && prevT % 2 === 1,\n\t        yoyoZero = isYoyo ? 1 : 0,\n\t        yoyoOne = 1 - yoyoZero;\n\n\t    if (time === props.endTime) {\n\t      this._wasUknownUpdate = false;\n\t      // if `time` is equal to `endTime`, T represents the next period,\n\t      // so we need to decrement T and calculate \"one\" value regarding yoyo\n\t      var isYoyo = props.isYoyo && (T - 1) % 2 === 1;\n\t      this._setProgress(isYoyo ? 0 : 1, time, isYoyo);\n\t      if (time > this._prevTime) {\n\t        this._isRepeatCompleted = false;\n\t      }\n\t      this._repeatComplete(time, isYoyo);\n\t      return this._complete(time, isYoyo);\n\t    }\n\n\t    // reset callback flags\n\t    this._isCompleted = false;\n\t    this._isRefreshed = false;\n\t    // if time is inside the duration area of the tween\n\t    if (startPoint + elapsed >= props.startTime) {\n\t      this._isInActiveArea = true;this._isRepeatCompleted = false;\n\t      this._isRepeatStart = false;this._isStarted = false;\n\t      // active zone or larger then end\n\t      var elapsed2 = (time - props.startTime) % delayDuration,\n\t          proc = elapsed2 / props.duration;\n\t      // |=====|=====|=====| >>>\n\t      //      ^1^2\n\t      var isOnEdge = T > 0 && prevT < T;\n\t      // |=====|=====|=====| <<<\n\t      //      ^2^1\n\t      var isOnReverseEdge = prevT > T;\n\n\t      // for use in timeline\n\t      this._onEdge = 0;\n\t      isOnEdge && (this._onEdge = 1);\n\t      isOnReverseEdge && (this._onEdge = -1);\n\n\t      if (this._wasUknownUpdate) {\n\t        if (time > this._prevTime) {\n\t          this._start(time, isYoyo);\n\t          this._repeatStart(time, isYoyo);\n\t          this._firstUpdate(time, isYoyo);\n\t        }\n\t        // if backward direction and \n\t        // if ( time < this._prevTime && time !== this._props.startTime ) {\n\t        if (time < this._prevTime) {\n\t          this._complete(time, isYoyo);\n\t          this._repeatComplete(time, isYoyo);\n\t          this._firstUpdate(time, isYoyo);\n\t          // reset isCompleted immediately\n\t          this._isCompleted = false;\n\t        }\n\t      }\n\n\t      if (isOnEdge) {\n\t        // if not just after delay\n\t        // |---=====|---=====|---=====| >>>\n\t        //            ^1 ^2\n\t        // because we have already handled\n\t        // 1 and onRepeatComplete in delay gap\n\t        if (this.progress !== 1) {\n\t          // prevT\n\t          var isThisYoyo = props.isYoyo && (T - 1) % 2 === 1;\n\t          this._repeatComplete(time, isThisYoyo);\n\t        }\n\t        // if on edge but not at very start\n\t        // |=====|=====|=====| >>>\n\t        // ^!    ^here ^here \n\t        if (prevT >= 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t      }\n\n\t      if (time > this._prevTime) {\n\t        //  |=====|=====|=====| >>>\n\t        // ^1  ^2\n\t        if (!this._isStarted && this._prevTime <= props.startTime) {\n\t          this._start(time, isYoyo);\n\t          this._repeatStart(time, isYoyo);\n\t          // it was zero anyways\n\n\t          // restart flags immediately in case if we will\n\t          // return to '-' inactive area on the next step\n\t          this._isStarted = false;\n\t          this._isRepeatStart = false;\n\t        }\n\t        this._firstUpdate(time, isYoyo);\n\t      }\n\n\t      if (isOnReverseEdge) {\n\t        // if on edge but not at very end\n\t        // |=====|=====|=====| <<<\n\t        //       ^here ^here ^not here\n\t        if (this.progress !== 0 && this.progress !== 1 && prevT != TCount) {\n\t          this._repeatStart(time, isYoyoPrev);\n\t        }\n\t        // if on very end edge\n\t        // |=====|=====|=====| <<<\n\t        //       ^!    ^! ^2 ^1\n\t        // we have handled the case in this._wasUknownUpdate\n\t        // block so filter that\n\t        if (prevT === TCount && !this._wasUknownUpdate) {\n\t          this._complete(time, isYoyo);\n\t          this._repeatComplete(time, isYoyo);\n\t          this._firstUpdate(time, isYoyo);\n\t          // reset isComplete flag call\n\t          // cuz we returned to active area\n\t          // this._isRepeatCompleted = false;\n\t          this._isCompleted = false;\n\t        }\n\t        this._repeatComplete(time, isYoyo);\n\t      }\n\n\t      if (prevT === 'delay') {\n\t        // if just before delay gap\n\t        // |---=====|---=====|---=====| <<<\n\t        //               ^2    ^1\n\t        if (T < TPrevValue) {\n\t          this._repeatComplete(time, isYoyo);\n\t        }\n\t        // if just after delay gap\n\t        // |---=====|---=====|---=====| >>>\n\t        //            ^1  ^2\n\t        if (T === TPrevValue && T > 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t      }\n\n\t      // swap progress and repeatStart based on direction\n\t      if (time > this._prevTime) {\n\t        // if progress is equal 0 and progress grows\n\t        if (proc === 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t        if (time !== props.endTime) {\n\t          this._setProgress(isYoyo ? 1 - proc : proc, time, isYoyo);\n\t        }\n\t      } else {\n\t        if (time !== props.endTime) {\n\t          this._setProgress(isYoyo ? 1 - proc : proc, time, isYoyo);\n\t        }\n\t        // if progress is equal 0 and progress grows\n\t        if (proc === 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t      }\n\n\t      if (time === props.startTime) {\n\t        this._start(time, isYoyo);\n\t      }\n\t      // delay gap - react only once\n\t    } else if (this._isInActiveArea) {\n\t      // because T will be string of \"delay\" here,\n\t      // let's normalize it be setting to TValue\n\t      var t = T === 'delay' ? TValue : T,\n\t          isGrows = time > this._prevTime;\n\t      // decrement period if forward direction of update\n\t      isGrows && t--;\n\t      // calculate normalized yoyoZero value\n\t      yoyoZero = props.isYoyo && t % 2 === 1 ? 1 : 0;\n\t      // if was in active area and previous time was larger\n\t      // |---=====|---=====|---=====| <<<\n\t      //   ^2 ^1    ^2 ^1    ^2 ^1\n\t      if (time < this._prevTime) {\n\t        this._setProgress(yoyoZero, time, yoyoZero === 1);\n\t        this._repeatStart(time, yoyoZero === 1);\n\t      }\n\t      // set 1 or 0 regarding direction and yoyo\n\t      this._setProgress(isGrows ? 1 - yoyoZero : yoyoZero, time, yoyoZero === 1);\n\t      // if time grows\n\t      if (time > this._prevTime) {\n\t        // if reverse direction and in delay gap, then progress will be 0\n\t        // if so we don't need to call the onRepeatComplete callback\n\t        // |---=====|---=====|---=====| <<<\n\t        //   ^0       ^0       ^0   \n\t        // OR we have flipped 0 to 1 regarding yoyo option\n\t        if (this.progress !== 0 || yoyoZero === 1) {\n\t          // since we repeatComplete for previous period\n\t          // invert isYoyo option\n\t          // is elapsed is 0 - count as previous period\n\t          this._repeatComplete(time, yoyoZero === 1);\n\t        }\n\t      }\n\t      // set flag to indicate inactive area\n\t      this._isInActiveArea = false;\n\t    }\n\t    // we've got the first update now\n\t    this._wasUknownUpdate = false;\n\t  };\n\t  /*\n\t    Method to remove the Tween from the tweener.\n\t    @private\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype._removeFromTweener = function _removeFromTweener() {\n\t    _tweener2.default.remove(this);return this;\n\t  };\n\t  /*\n\t    Method to get current period number.\n\t    @private\n\t    @param {Number} Time to get the period for.\n\t    @returns {Number} Current period number.\n\t  */\n\n\n\t  Tween.prototype._getPeriod = function _getPeriod(time) {\n\t    var p = this._props,\n\t        TTime = p.delay + p.duration,\n\t        dTime = p.delay + time - p.startTime,\n\t        T = dTime / TTime,\n\n\t    // if time if equal to endTime we need to set the elapsed\n\t    // time to 0 to fix the occasional precision js bug, which\n\t    // causes 0 to be something like 1e-12\n\t    elapsed = time < p.endTime ? dTime % TTime : 0;\n\t    // If the latest period, round the result, otherwise floor it.\n\t    // Basically we always can floor the result, but because of js\n\t    // precision issues, sometimes the result is 2.99999998 which\n\t    // will result in 2 instead of 3 after the floor operation.\n\t    T = time >= p.endTime ? Math.round(T) : Math.floor(T);\n\t    // if time is larger then the end time\n\t    if (time > p.endTime) {\n\t      // set equal to the periods count\n\t      T = Math.round((p.endTime - p.startTime + p.delay) / TTime);\n\t      // if in delay gap, set _delayT to current\n\t      // period number and return \"delay\"\n\t    } else if (elapsed > 0 && elapsed < p.delay) {\n\t      this._delayT = T;T = 'delay';\n\t    }\n\t    // if the end of period and there is a delay\n\t    return T;\n\t  };\n\t  /*\n\t    Method to set Tween's progress and call onUpdate callback.\n\t    @private\n\t    @override @ Module\n\t    @param {Number} Progress to set.\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is yoyo perido. Used in Timeline to pass to Tween.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype._setProgress = function _setProgress(proc, time, isYoyo) {\n\t    var p = this._props,\n\t        isYoyoChanged = p.wasYoyo !== isYoyo,\n\t        isForward = time > this._prevTime;\n\n\t    this.progress = proc;\n\t    // get the current easing for `forward` direction regarding `yoyo`\n\t    if (isForward && !isYoyo || !isForward && isYoyo) {\n\t      this.easedProgress = p.easing(proc);\n\t      // get the current easing for `backward` direction regarding `yoyo`\n\t    } else if (!isForward && !isYoyo || isForward && isYoyo) {\n\t      var easing = p.backwardEasing != null ? p.backwardEasing : p.easing;\n\n\t      this.easedProgress = easing(proc);\n\t    }\n\n\t    if (p.prevEasedProgress !== this.easedProgress || isYoyoChanged) {\n\t      if (p.onUpdate != null && typeof p.onUpdate === 'function') {\n\t        p.onUpdate.call(p.callbacksContext || this, this.easedProgress, this.progress, isForward, isYoyo);\n\t      }\n\t    }\n\t    p.prevEasedProgress = this.easedProgress;\n\t    p.wasYoyo = isYoyo;\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set tween's state to start and call onStart callback.\n\t    @method _start\n\t    @private\n\t    @param {Number} Progress to set.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._start = function _start(time, isYoyo) {\n\t    if (this._isStarted) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onStart != null && typeof p.onStart === 'function') {\n\t      p.onStart.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isCompleted = false;this._isStarted = true;\n\t    this._isFirstUpdate = false;\n\t  };\n\t  /*\n\t    Method to call onPlaybackStart callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackStart = function _playbackStart() {\n\t    var p = this._props;\n\t    if (p.onPlaybackStart != null && typeof p.onPlaybackStart === 'function') {\n\t      p.onPlaybackStart.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to call onPlaybackPause callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackPause = function _playbackPause() {\n\t    var p = this._props;\n\t    if (p.onPlaybackPause != null && typeof p.onPlaybackPause === 'function') {\n\t      p.onPlaybackPause.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to call onPlaybackStop callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackStop = function _playbackStop() {\n\t    var p = this._props;\n\t    if (p.onPlaybackStop != null && typeof p.onPlaybackStop === 'function') {\n\t      p.onPlaybackStop.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to call onPlaybackComplete callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackComplete = function _playbackComplete() {\n\t    var p = this._props;\n\t    if (p.onPlaybackComplete != null && typeof p.onPlaybackComplete === 'function') {\n\t      p.onPlaybackComplete.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to set tween's state to complete.\n\t    @method _complete\n\t    @private\n\t    @param {Number} Current time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._complete = function _complete(time, isYoyo) {\n\t    if (this._isCompleted) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onComplete != null && typeof p.onComplete === 'function') {\n\t      p.onComplete.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\n\t    this._isCompleted = true;this._isStarted = false;\n\t    this._isFirstUpdate = false;\n\t    // reset _prevYoyo for timeline usage\n\t    this._prevYoyo = undefined;\n\t  };\n\n\t  /*\n\t    Method to run onFirstUpdate callback.\n\t    @method _firstUpdate\n\t    @private\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._firstUpdate = function _firstUpdate(time, isYoyo) {\n\t    if (this._isFirstUpdate) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onFirstUpdate != null && typeof p.onFirstUpdate === 'function') {\n\t      // onFirstUpdate should have tween pointer\n\t      p.onFirstUpdate.tween = this;\n\t      p.onFirstUpdate.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isFirstUpdate = true;\n\t  };\n\t  /*\n\t    Method call onRepeatComplete calback and set flags.\n\t    @private\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is repeat period.\n\t  */\n\n\n\t  Tween.prototype._repeatComplete = function _repeatComplete(time, isYoyo) {\n\t    if (this._isRepeatCompleted) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onRepeatComplete != null && typeof p.onRepeatComplete === 'function') {\n\t      p.onRepeatComplete.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isRepeatCompleted = true;\n\t    // this._prevYoyo = null;\n\t  };\n\n\t  /*\n\t    Method call onRepeatStart calback and set flags.\n\t    @private\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._repeatStart = function _repeatStart(time, isYoyo) {\n\t    if (this._isRepeatStart) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onRepeatStart != null && typeof p.onRepeatStart === 'function') {\n\t      p.onRepeatStart.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isRepeatStart = true;\n\t  };\n\t  /*\n\t    Method to launch onProgress callback.\n\t    @method _progress\n\t    @private\n\t    @param {Number} Progress to set.\n\t  */\n\n\n\t  Tween.prototype._progress = function _progress(progress, time) {\n\t    var p = this._props;\n\t    if (p.onProgress != null && typeof p.onProgress === 'function') {\n\t      p.onProgress.call(p.callbacksContext || this, progress, time > this._prevTime);\n\t    }\n\t  };\n\t  /*\n\t    Method to launch onRefresh callback.\n\t    @method _refresh\n\t    @private\n\t    @param {Boolean} If refresh even before start time.\n\t  */\n\n\n\t  Tween.prototype._refresh = function _refresh(isBefore) {\n\t    var p = this._props;\n\t    if (p.onRefresh != null) {\n\t      var context = p.callbacksContext || this,\n\t          progress = isBefore ? 0 : 1;\n\n\t      p.onRefresh.call(context, isBefore, p.easing(progress), progress);\n\t    }\n\t  };\n\t  /*\n\t    Method which is called when the tween is removed from tweener.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._onTweenerRemove = function _onTweenerRemove() {};\n\t  /*\n\t    Method which is called when the tween is removed\n\t    from tweener when finished.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._onTweenerFinish = function _onTweenerFinish() {\n\t    this._setPlaybackState('stop');\n\t    this._playbackComplete();\n\t  };\n\t  /*\n\t    Method to set property[s] on Tween.\n\t    @private\n\t    @override @ Module\n\t    @param {Object, String} Hash object of key/value pairs, or property name.\n\t    @param {_} Property's value to set.\n\t  */\n\n\n\t  Tween.prototype._setProp = function _setProp(obj, value) {\n\t    _Module.prototype._setProp.call(this, obj, value);\n\t    this._calcDimentions();\n\t  };\n\t  /*\n\t    Method to set single property.\n\t    @private\n\t    @override @ Module\n\t    @param {String} Name of the property.\n\t    @param {Any} Value for the property.\n\t  */\n\n\n\t  Tween.prototype._assignProp = function _assignProp(key, value) {\n\t    // fallback to defaults\n\t    if (value == null) {\n\t      value = this._defaults[key];\n\t    }\n\t    // parse easing\n\t    if (key === 'easing') {\n\t      value = _easing2.default.parseEasing(value);\n\t      value._parent = this;\n\t    }\n\t    // handle control callbacks overrides\n\t    var control = this._callbackOverrides[key],\n\t        isntOverriden = !value || !value.isMojsCallbackOverride;\n\t    if (control && isntOverriden) {\n\t      value = this._overrideCallback(value, control);\n\t    }\n\t    // call super on Module\n\t    _Module.prototype._assignProp.call(this, key, value);\n\t  };\n\t  /*\n\t    Method to override callback for controll pupropes.\n\t    @private\n\t    @param {String}    Callback name.\n\t    @parma {Function}  Method to call  \n\t  */\n\n\n\t  Tween.prototype._overrideCallback = function _overrideCallback(callback, fun) {\n\t    var isCallback = callback && typeof callback === 'function',\n\t        override = function callbackOverride() {\n\t      // call overriden callback if it exists\n\t      isCallback && callback.apply(this, arguments);\n\t      // call the passed cleanup function\n\t      fun.apply(this, arguments);\n\t    };\n\t    // add overridden flag\n\t    override.isMojsCallbackOverride = true;\n\t    return override;\n\t  };\n\n\t  // _visualizeProgress(time) {\n\t  //   var str = '|',\n\t  //       procStr = ' ',\n\t  //       p = this._props,\n\t  //       proc = p.startTime - p.delay;\n\n\t  //   while ( proc < p.endTime ) {\n\t  //     if (p.delay > 0 ) {\n\t  //       var newProc = proc + p.delay;\n\t  //       if ( time > proc && time < newProc ) {\n\t  //         procStr += ' ^ ';\n\t  //       } else {\n\t  //         procStr += '   ';\n\t  //       }\n\t  //       proc = newProc;\n\t  //       str  += '---';\n\t  //     }\n\t  //     var newProc = proc + p.duration;\n\t  //     if ( time > proc && time < newProc ) {\n\t  //       procStr += '  ^   ';\n\t  //     } else if (time === proc) {\n\t  //       procStr += '^     ';\n\t  //     } else if (time === newProc) {\n\t  //       procStr += '    ^ ';\n\t  //     } else {\n\t  //       procStr += '      ';\n\t  //     }\n\t  //     proc = newProc;\n\t  //     str += '=====|';\n\t  //   }\n\n\t  //   console.log(str);\n\t  //   console.log(procStr);\n\t  // }\n\n\n\t  return Tween;\n\t}(_module2.default);\n\n\texports.default = Tween;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\t__webpack_require__(103);\n\n\t__webpack_require__(104);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Tweener = function () {\n\t  function Tweener() {\n\t    (0, _classCallCheck3.default)(this, Tweener);\n\n\t    this._vars();\n\t    this._listenVisibilityChange();\n\t    return this;\n\t  }\n\n\t  Tweener.prototype._vars = function _vars() {\n\t    this.tweens = [];\n\t    this._savedTweens = [];\n\t    this._loop = this._loop.bind(this);\n\t    this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\t  };\n\t  /*\n\t    Main animation loop. Should have only one concurrent loop.\n\t    @private\n\t    @returns this\n\t  */\n\n\n\t  Tweener.prototype._loop = function _loop() {\n\t    if (!this._isRunning) {\n\t      return false;\n\t    }\n\t    this._update(window.performance.now());\n\t    if (!this.tweens.length) {\n\t      return this._isRunning = false;\n\t    }\n\t    requestAnimationFrame(this._loop);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to start animation loop.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._startLoop = function _startLoop() {\n\t    if (this._isRunning) {\n\t      return;\n\t    };this._isRunning = true;\n\t    requestAnimationFrame(this._loop);\n\t  };\n\t  /*\n\t    Method to stop animation loop.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._stopLoop = function _stopLoop() {\n\t    this._isRunning = false;\n\t  };\n\t  /*\n\t    Method to update every tween/timeline on animation frame.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._update = function _update(time) {\n\t    var i = this.tweens.length;\n\t    while (i--) {\n\t      // cache the current tween\n\t      var tween = this.tweens[i];\n\t      if (tween && tween._update(time) === true) {\n\t        this.remove(tween);\n\t        tween._onTweenerFinish();\n\t        tween._prevTime = undefined;\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to add a Tween/Timeline to loop pool.\n\t    @param {Object} Tween/Timeline to add.\n\t  */\n\n\n\t  Tweener.prototype.add = function add(tween) {\n\t    // return if tween is already running\n\t    if (tween._isRunning) {\n\t      return;\n\t    }\n\t    tween._isRunning = true;\n\t    this.tweens.push(tween);\n\t    this._startLoop();\n\t  };\n\t  /*\n\t    Method stop updating all the child tweens/timelines.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype.removeAll = function removeAll() {\n\t    this.tweens.length = 0;\n\t  };\n\t  /*\n\t    Method to remove specific tween/timeline form updating.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype.remove = function remove(tween) {\n\t    var index = typeof tween === 'number' ? tween : this.tweens.indexOf(tween);\n\n\t    if (index !== -1) {\n\t      tween = this.tweens[index];\n\t      if (tween) {\n\t        tween._isRunning = false;\n\t        this.tweens.splice(index, 1);\n\t        tween._onTweenerRemove();\n\t      }\n\t    }\n\t  };\n\n\t  /*\n\t    Method to initialize event listeners to visibility change events.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._listenVisibilityChange = function _listenVisibilityChange() {\n\t    if (typeof document.hidden !== \"undefined\") {\n\t      this._visibilityHidden = \"hidden\";\n\t      this._visibilityChange = \"visibilitychange\";\n\t    } else if (typeof document.mozHidden !== \"undefined\") {\n\t      this._visibilityHidden = \"mozHidden\";\n\t      this._visibilityChange = \"mozvisibilitychange\";\n\t    } else if (typeof document.msHidden !== \"undefined\") {\n\t      this._visibilityHidden = \"msHidden\";\n\t      this._visibilityChange = \"msvisibilitychange\";\n\t    } else if (typeof document.webkitHidden !== \"undefined\") {\n\t      this._visibilityHidden = \"webkitHidden\";\n\t      this._visibilityChange = \"webkitvisibilitychange\";\n\t    }\n\n\t    document.addEventListener(this._visibilityChange, this._onVisibilityChange, false);\n\t  };\n\t  /*\n\t    Method that will fire on visibility change.\n\t  */\n\n\n\t  Tweener.prototype._onVisibilityChange = function _onVisibilityChange() {\n\t    if (document[this._visibilityHidden]) {\n\t      this._savePlayingTweens();\n\t    } else {\n\t      this._restorePlayingTweens();\n\t    }\n\t  };\n\t  /*\n\t    Method to save all playing tweens.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._savePlayingTweens = function _savePlayingTweens() {\n\t    this._savedTweens = this.tweens.slice(0);\n\t    for (var i = 0; i < this._savedTweens.length; i++) {\n\t      this._savedTweens[i].pause();\n\t    }\n\t  };\n\t  /*\n\t    Method to restore all playing tweens.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._restorePlayingTweens = function _restorePlayingTweens() {\n\t    for (var i = 0; i < this._savedTweens.length; i++) {\n\t      this._savedTweens[i].resume();\n\t    }\n\t  };\n\n\t  return Tweener;\n\t}();\n\n\tvar t = new Tweener();\n\texports.default = t;\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports) {\n\n\t\n\t/* istanbul ignore next */\n\t(function() {\n\t  'use strict';\n\t  var cancel, i, isOldBrowser, lastTime, vendors, vp, w;\n\t  vendors = ['webkit', 'moz'];\n\t  i = 0;\n\t  w = window;\n\t  while (i < vendors.length && !w.requestAnimationFrame) {\n\t    vp = vendors[i];\n\t    w.requestAnimationFrame = w[vp + 'RequestAnimationFrame'];\n\t    cancel = w[vp + 'CancelAnimationFrame'];\n\t    w.cancelAnimationFrame = cancel || w[vp + 'CancelRequestAnimationFrame'];\n\t    ++i;\n\t  }\n\t  isOldBrowser = !w.requestAnimationFrame || !w.cancelAnimationFrame;\n\t  if (/iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent) || isOldBrowser) {\n\t    lastTime = 0;\n\t    w.requestAnimationFrame = function(callback) {\n\t      var nextTime, now;\n\t      now = Date.now();\n\t      nextTime = Math.max(lastTime + 16, now);\n\t      return setTimeout((function() {\n\t        callback(lastTime = nextTime);\n\t      }), nextTime - now);\n\t    };\n\t    w.cancelAnimationFrame = clearTimeout;\n\t  }\n\t})();\n\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports) {\n\n\t\n\t/* istanbul ignore next */\n\t(function(root) {\n\t  var offset, ref, ref1;\n\t  if (root.performance == null) {\n\t    root.performance = {};\n\t  }\n\t  Date.now = Date.now || function() {\n\t    return (new Date).getTime();\n\t  };\n\t  if (root.performance.now == null) {\n\t    offset = ((ref = root.performance) != null ? (ref1 = ref.timing) != null ? ref1.navigationStart : void 0 : void 0) ? performance.timing.navigationStart : Date.now();\n\t    return root.performance.now = function() {\n\t      return Date.now() - offset;\n\t    };\n\t  }\n\t})(window);\n\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Easing, PI, PathEasing, approximate, bezier, easing, h, mix, sin;\n\n\tbezier = __webpack_require__(106);\n\n\tPathEasing = __webpack_require__(107);\n\n\tmix = __webpack_require__(108);\n\n\th = __webpack_require__(71);\n\n\tapproximate = __webpack_require__(109)[\"default\"] || __webpack_require__(109);\n\n\tsin = Math.sin;\n\n\tPI = Math.PI;\n\n\tEasing = (function() {\n\t  function Easing() {}\n\n\t  Easing.prototype.bezier = bezier;\n\n\t  Easing.prototype.PathEasing = PathEasing;\n\n\t  Easing.prototype.path = (new PathEasing('creator')).create;\n\n\t  Easing.prototype.approximate = approximate;\n\n\t  Easing.prototype.inverse = function(p) {\n\t    return 1 - p;\n\t  };\n\n\t  Easing.prototype.linear = {\n\t    none: function(k) {\n\t      return k;\n\t    }\n\t  };\n\n\t  Easing.prototype.ease = {\n\t    \"in\": bezier.apply(Easing, [0.42, 0, 1, 1]),\n\t    out: bezier.apply(Easing, [0, 0, 0.58, 1]),\n\t    inout: bezier.apply(Easing, [0.42, 0, 0.58, 1])\n\t  };\n\n\t  Easing.prototype.sin = {\n\t    \"in\": function(k) {\n\t      return 1 - Math.cos(k * PI / 2);\n\t    },\n\t    out: function(k) {\n\t      return sin(k * PI / 2);\n\t    },\n\t    inout: function(k) {\n\t      return 0.5 * (1 - Math.cos(PI * k));\n\t    }\n\t  };\n\n\t  Easing.prototype.quad = {\n\t    \"in\": function(k) {\n\t      return k * k;\n\t    },\n\t    out: function(k) {\n\t      return k * (2 - k);\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k;\n\t      }\n\t      return -0.5 * (--k * (k - 2) - 1);\n\t    }\n\t  };\n\n\t  Easing.prototype.cubic = {\n\t    \"in\": function(k) {\n\t      return k * k * k;\n\t    },\n\t    out: function(k) {\n\t      return --k * k * k + 1;\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k * k;\n\t      }\n\t      return 0.5 * ((k -= 2) * k * k + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.quart = {\n\t    \"in\": function(k) {\n\t      return k * k * k * k;\n\t    },\n\t    out: function(k) {\n\t      return 1 - (--k * k * k * k);\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k * k * k;\n\t      }\n\t      return -0.5 * ((k -= 2) * k * k * k - 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.quint = {\n\t    \"in\": function(k) {\n\t      return k * k * k * k * k;\n\t    },\n\t    out: function(k) {\n\t      return --k * k * k * k * k + 1;\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k * k * k * k;\n\t      }\n\t      return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.expo = {\n\t    \"in\": function(k) {\n\t      if (k === 0) {\n\t        return 0;\n\t      } else {\n\t        return Math.pow(1024, k - 1);\n\t      }\n\t    },\n\t    out: function(k) {\n\t      if (k === 1) {\n\t        return 1;\n\t      } else {\n\t        return 1 - Math.pow(2, -10 * k);\n\t      }\n\t    },\n\t    inout: function(k) {\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * Math.pow(1024, k - 1);\n\t      }\n\t      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.circ = {\n\t    \"in\": function(k) {\n\t      return 1 - Math.sqrt(1 - k * k);\n\t    },\n\t    out: function(k) {\n\t      return Math.sqrt(1 - (--k * k));\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t      }\n\t      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t    }\n\t  };\n\n\t  Easing.prototype.back = {\n\t    \"in\": function(k) {\n\t      var s;\n\t      s = 1.70158;\n\t      return k * k * ((s + 1) * k - s);\n\t    },\n\t    out: function(k) {\n\t      var s;\n\t      s = 1.70158;\n\t      return --k * k * ((s + 1) * k + s) + 1;\n\t    },\n\t    inout: function(k) {\n\t      var s;\n\t      s = 1.70158 * 1.525;\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * (k * k * ((s + 1) * k - s));\n\t      }\n\t      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.elastic = {\n\t    \"in\": function(k) {\n\t      var a, p, s;\n\t      s = void 0;\n\t      p = 0.4;\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      a = 1;\n\t      s = p / 4;\n\t      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t    },\n\t    out: function(k) {\n\t      var a, p, s;\n\t      s = void 0;\n\t      p = 0.4;\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      a = 1;\n\t      s = p / 4;\n\t      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t    },\n\t    inout: function(k) {\n\t      var a, p, s;\n\t      s = void 0;\n\t      p = 0.4;\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      a = 1;\n\t      s = p / 4;\n\t      if ((k *= 2) < 1) {\n\t        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t      }\n\t      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t    }\n\t  };\n\n\t  Easing.prototype.bounce = {\n\t    \"in\": function(k) {\n\t      return 1 - easing.bounce.out(1 - k);\n\t    },\n\t    out: function(k) {\n\t      if (k < (1 / 2.75)) {\n\t        return 7.5625 * k * k;\n\t      } else if (k < (2 / 2.75)) {\n\t        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t      } else if (k < (2.5 / 2.75)) {\n\t        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t      } else {\n\t        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t      }\n\t    },\n\t    inout: function(k) {\n\t      if (k < 0.5) {\n\t        return easing.bounce[\"in\"](k * 2) * 0.5;\n\t      }\n\t      return easing.bounce.out(k * 2 - 1) * 0.5 + 0.5;\n\t    }\n\t  };\n\n\t  Easing.prototype.parseEasing = function(easing) {\n\t    var easingParent, type;\n\t    if (easing == null) {\n\t      easing = 'linear.none';\n\t    }\n\t    type = typeof easing;\n\t    if (type === 'string') {\n\t      if (easing.charAt(0).toLowerCase() === 'm') {\n\t        return this.path(easing);\n\t      } else {\n\t        easing = this._splitEasing(easing);\n\t        easingParent = this[easing[0]];\n\t        if (!easingParent) {\n\t          h.error(\"Easing with name \\\"\" + easing[0] + \"\\\" was not found, fallback to \\\"linear.none\\\" instead\");\n\t          return this['linear']['none'];\n\t        }\n\t        return easingParent[easing[1]];\n\t      }\n\t    }\n\t    if (h.isArray(easing)) {\n\t      return this.bezier.apply(this, easing);\n\t    }\n\t    if ('function') {\n\t      return easing;\n\t    }\n\t  };\n\n\t  Easing.prototype._splitEasing = function(string) {\n\t    var firstPart, secondPart, split;\n\t    if (typeof string === 'function') {\n\t      return string;\n\t    }\n\t    if (typeof string === 'string' && string.length) {\n\t      split = string.split('.');\n\t      firstPart = split[0].toLowerCase() || 'linear';\n\t      secondPart = split[1].toLowerCase() || 'none';\n\t      return [firstPart, secondPart];\n\t    } else {\n\t      return ['linear', 'none'];\n\t    }\n\t  };\n\n\t  return Easing;\n\n\t})();\n\n\teasing = new Easing;\n\n\teasing.mix = mix(easing);\n\n\tmodule.exports = easing;\n\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var BezierEasing, bezierEasing, h,\n\t  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n\th = __webpack_require__(71);\n\n\n\t/**\n\t * Copyright (c) 2014 Gaëtan Renaudeau http://goo.gl/El3k7u\n\t * Adopted from https://github.com/gre/bezier-easing\n\t */\n\n\tBezierEasing = (function() {\n\t  function BezierEasing(o) {\n\t    this.vars();\n\t    return this.generate;\n\t  }\n\n\t  BezierEasing.prototype.vars = function() {\n\t    return this.generate = h.bind(this.generate, this);\n\t  };\n\n\t  BezierEasing.prototype.generate = function(mX1, mY1, mX2, mY2) {\n\t    var A, B, C, NEWTON_ITERATIONS, NEWTON_MIN_SLOPE, SUBDIVISION_MAX_ITERATIONS, SUBDIVISION_PRECISION, _precomputed, arg, binarySubdivide, calcBezier, calcSampleValues, f, float32ArraySupported, getSlope, getTForX, i, j, kSampleStepSize, kSplineTableSize, mSampleValues, newtonRaphsonIterate, precompute, str;\n\t    if (arguments.length < 4) {\n\t      return this.error('Bezier function expects 4 arguments');\n\t    }\n\t    for (i = j = 0; j < 4; i = ++j) {\n\t      arg = arguments[i];\n\t      if (typeof arg !== \"number\" || isNaN(arg) || !isFinite(arg)) {\n\t        return this.error('Bezier function expects 4 arguments');\n\t      }\n\t    }\n\t    if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {\n\t      return this.error('Bezier x values should be > 0 and < 1');\n\t    }\n\t    NEWTON_ITERATIONS = 4;\n\t    NEWTON_MIN_SLOPE = 0.001;\n\t    SUBDIVISION_PRECISION = 0.0000001;\n\t    SUBDIVISION_MAX_ITERATIONS = 10;\n\t    kSplineTableSize = 11;\n\t    kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\t    float32ArraySupported = indexOf.call(global, 'Float32Array') >= 0;\n\t    A = function(aA1, aA2) {\n\t      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n\t    };\n\t    B = function(aA1, aA2) {\n\t      return 3.0 * aA2 - 6.0 * aA1;\n\t    };\n\t    C = function(aA1) {\n\t      return 3.0 * aA1;\n\t    };\n\t    calcBezier = function(aT, aA1, aA2) {\n\t      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n\t    };\n\t    getSlope = function(aT, aA1, aA2) {\n\t      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n\t    };\n\t    newtonRaphsonIterate = function(aX, aGuessT) {\n\t      var currentSlope, currentX;\n\t      i = 0;\n\t      while (i < NEWTON_ITERATIONS) {\n\t        currentSlope = getSlope(aGuessT, mX1, mX2);\n\n\t        /* istanbul ignore if */\n\t        if (currentSlope === 0.0) {\n\t          return aGuessT;\n\t        }\n\t        currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n\t        aGuessT -= currentX / currentSlope;\n\t        ++i;\n\t      }\n\t      return aGuessT;\n\t    };\n\t    calcSampleValues = function() {\n\t      i = 0;\n\t      while (i < kSplineTableSize) {\n\t        mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n\t        ++i;\n\t      }\n\t    };\n\n\t    /* istanbul ignore next */\n\t    binarySubdivide = function(aX, aA, aB) {\n\t      var currentT, currentX, isBig;\n\t      currentX = void 0;\n\t      currentT = void 0;\n\t      i = 0;\n\t      while (true) {\n\t        currentT = aA + (aB - aA) / 2.0;\n\t        currentX = calcBezier(currentT, mX1, mX2) - aX;\n\t        if (currentX > 0.0) {\n\t          aB = currentT;\n\t        } else {\n\t          aA = currentT;\n\t        }\n\t        isBig = Math.abs(currentX) > SUBDIVISION_PRECISION;\n\t        if (!(isBig && ++i < SUBDIVISION_MAX_ITERATIONS)) {\n\t          break;\n\t        }\n\t      }\n\t      return currentT;\n\t    };\n\t    getTForX = function(aX) {\n\t      var currentSample, delta, dist, guessForT, initialSlope, intervalStart, lastSample;\n\t      intervalStart = 0.0;\n\t      currentSample = 1;\n\t      lastSample = kSplineTableSize - 1;\n\t      while (currentSample !== lastSample && mSampleValues[currentSample] <= aX) {\n\t        intervalStart += kSampleStepSize;\n\t        ++currentSample;\n\t      }\n\t      --currentSample;\n\t      delta = mSampleValues[currentSample + 1] - mSampleValues[currentSample];\n\t      dist = (aX - mSampleValues[currentSample]) / delta;\n\t      guessForT = intervalStart + dist * kSampleStepSize;\n\t      initialSlope = getSlope(guessForT, mX1, mX2);\n\t      if (initialSlope >= NEWTON_MIN_SLOPE) {\n\t        return newtonRaphsonIterate(aX, guessForT);\n\t      } else {\n\n\t        /* istanbul ignore next */\n\t        if (initialSlope === 0.0) {\n\t          return guessForT;\n\t        } else {\n\t          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n\t        }\n\t      }\n\t    };\n\t    precompute = function() {\n\t      var _precomputed;\n\t      _precomputed = true;\n\t      if (mX1 !== mY1 || mX2 !== mY2) {\n\t        return calcSampleValues();\n\t      }\n\t    };\n\t    mSampleValues = !float32ArraySupported ? new Array(kSplineTableSize) : new Float32Array(kSplineTableSize);\n\t    _precomputed = false;\n\t    f = function(aX) {\n\t      if (!_precomputed) {\n\t        precompute();\n\t      }\n\t      if (mX1 === mY1 && mX2 === mY2) {\n\t        return aX;\n\t      }\n\t      if (aX === 0) {\n\t        return 0;\n\t      }\n\t      if (aX === 1) {\n\t        return 1;\n\t      }\n\t      return calcBezier(getTForX(aX), mY1, mY2);\n\t    };\n\t    str = \"bezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\t    f.toStr = function() {\n\t      return str;\n\t    };\n\t    return f;\n\t  };\n\n\t  BezierEasing.prototype.error = function(msg) {\n\t    return h.error(msg);\n\t  };\n\n\t  return BezierEasing;\n\n\t})();\n\n\tbezierEasing = new BezierEasing;\n\n\tmodule.exports = bezierEasing;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar PathEasing, h;\n\n\th = __webpack_require__(71);\n\n\tPathEasing = (function() {\n\t  PathEasing.prototype._vars = function() {\n\t    this._precompute = h.clamp(this.o.precompute || 1450, 100, 10000);\n\t    this._step = 1 / this._precompute;\n\t    this._rect = this.o.rect || 100;\n\t    this._approximateMax = this.o.approximateMax || 5;\n\t    this._eps = this.o.eps || 0.001;\n\t    return this._boundsPrevProgress = -1;\n\t  };\n\n\t  function PathEasing(path, o1) {\n\t    this.o = o1 != null ? o1 : {};\n\t    if (path === 'creator') {\n\t      return;\n\t    }\n\t    this.path = h.parsePath(path);\n\t    if (this.path == null) {\n\t      return h.error('Error while parsing the path');\n\t    }\n\t    this._vars();\n\t    this.path.setAttribute('d', this._normalizePath(this.path.getAttribute('d')));\n\t    this.pathLength = this.path.getTotalLength();\n\t    this.sample = h.bind(this.sample, this);\n\t    this._hardSample = h.bind(this._hardSample, this);\n\t    this._preSample();\n\t    this;\n\t  }\n\n\t  PathEasing.prototype._preSample = function() {\n\t    var i, j, length, point, progress, ref, results;\n\t    this._samples = [];\n\t    results = [];\n\t    for (i = j = 0, ref = this._precompute; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n\t      progress = i * this._step;\n\t      length = this.pathLength * progress;\n\t      point = this.path.getPointAtLength(length);\n\t      results.push(this._samples[i] = {\n\t        point: point,\n\t        length: length,\n\t        progress: progress\n\t      });\n\t    }\n\t    return results;\n\t  };\n\n\t  PathEasing.prototype._findBounds = function(array, p) {\n\t    var buffer, direction, end, i, j, len, loopEnd, pointP, pointX, ref, ref1, start, value;\n\t    if (p === this._boundsPrevProgress) {\n\t      return this._prevBounds;\n\t    }\n\t    if (this._boundsStartIndex == null) {\n\t      this._boundsStartIndex = 0;\n\t    }\n\t    len = array.length;\n\t    if (this._boundsPrevProgress > p) {\n\t      loopEnd = 0;\n\t      direction = 'reverse';\n\t    } else {\n\t      loopEnd = len;\n\t      direction = 'forward';\n\t    }\n\t    if (direction === 'forward') {\n\t      start = array[0];\n\t      end = array[array.length - 1];\n\t    } else {\n\t      start = array[array.length - 1];\n\t      end = array[0];\n\t    }\n\t    for (i = j = ref = this._boundsStartIndex, ref1 = loopEnd; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n\t      value = array[i];\n\t      pointX = value.point.x / this._rect;\n\t      pointP = p;\n\t      if (direction === 'reverse') {\n\t        buffer = pointX;\n\t        pointX = pointP;\n\t        pointP = buffer;\n\t      }\n\t      if (pointX < pointP) {\n\t        start = value;\n\t        this._boundsStartIndex = i;\n\t      } else {\n\t        end = value;\n\t        break;\n\t      }\n\t    }\n\t    this._boundsPrevProgress = p;\n\t    return this._prevBounds = {\n\t      start: start,\n\t      end: end\n\t    };\n\t  };\n\n\t  PathEasing.prototype.sample = function(p) {\n\t    var bounds, res;\n\t    p = h.clamp(p, 0, 1);\n\t    bounds = this._findBounds(this._samples, p);\n\t    res = this._checkIfBoundsCloseEnough(p, bounds);\n\t    if (res != null) {\n\t      return res;\n\t    }\n\t    return this._findApproximate(p, bounds.start, bounds.end);\n\t  };\n\n\t  PathEasing.prototype._checkIfBoundsCloseEnough = function(p, bounds) {\n\t    var point, y;\n\t    point = void 0;\n\t    y = this._checkIfPointCloseEnough(p, bounds.start.point);\n\t    if (y != null) {\n\t      return y;\n\t    }\n\t    return this._checkIfPointCloseEnough(p, bounds.end.point);\n\t  };\n\n\t  PathEasing.prototype._checkIfPointCloseEnough = function(p, point) {\n\t    if (h.closeEnough(p, point.x / this._rect, this._eps)) {\n\t      return this._resolveY(point);\n\t    }\n\t  };\n\n\t  PathEasing.prototype._approximate = function(start, end, p) {\n\t    var deltaP, percentP;\n\t    deltaP = end.point.x - start.point.x;\n\t    percentP = (p - (start.point.x / this._rect)) / (deltaP / this._rect);\n\t    return start.length + percentP * (end.length - start.length);\n\t  };\n\n\t  PathEasing.prototype._findApproximate = function(p, start, end, approximateMax) {\n\t    var approximation, args, newPoint, point, x;\n\t    if (approximateMax == null) {\n\t      approximateMax = this._approximateMax;\n\t    }\n\t    approximation = this._approximate(start, end, p);\n\t    point = this.path.getPointAtLength(approximation);\n\t    x = point.x / this._rect;\n\t    if (h.closeEnough(p, x, this._eps)) {\n\t      return this._resolveY(point);\n\t    } else {\n\t      if (--approximateMax < 1) {\n\t        return this._resolveY(point);\n\t      }\n\t      newPoint = {\n\t        point: point,\n\t        length: approximation\n\t      };\n\t      args = p < x ? [p, start, newPoint, approximateMax] : [p, newPoint, end, approximateMax];\n\t      return this._findApproximate.apply(this, args);\n\t    }\n\t  };\n\n\t  PathEasing.prototype._resolveY = function(point) {\n\t    return 1 - (point.y / this._rect);\n\t  };\n\n\t  PathEasing.prototype._normalizePath = function(path) {\n\t    var commands, endIndex, normalizedPath, points, startIndex, svgCommandsRegexp;\n\t    svgCommandsRegexp = /[M|L|H|V|C|S|Q|T|A]/gim;\n\t    points = path.split(svgCommandsRegexp);\n\t    points.shift();\n\t    commands = path.match(svgCommandsRegexp);\n\t    startIndex = 0;\n\t    points[startIndex] = this._normalizeSegment(points[startIndex]);\n\t    endIndex = points.length - 1;\n\t    points[endIndex] = this._normalizeSegment(points[endIndex], this._rect || 100);\n\t    return normalizedPath = this._joinNormalizedPath(commands, points);\n\t  };\n\n\t  PathEasing.prototype._joinNormalizedPath = function(commands, points) {\n\t    var command, i, j, len1, normalizedPath, space;\n\t    normalizedPath = '';\n\t    for (i = j = 0, len1 = commands.length; j < len1; i = ++j) {\n\t      command = commands[i];\n\t      space = i === 0 ? '' : ' ';\n\t      normalizedPath += \"\" + space + command + (points[i].trim());\n\t    }\n\t    return normalizedPath;\n\t  };\n\n\t  PathEasing.prototype._normalizeSegment = function(segment, value) {\n\t    var i, j, lastPoint, len1, nRgx, pairs, parsedX, point, space, x;\n\t    if (value == null) {\n\t      value = 0;\n\t    }\n\t    segment = segment.trim();\n\t    nRgx = /(-|\\+)?((\\d+(\\.(\\d|\\e(-|\\+)?)+)?)|(\\.?(\\d|\\e|(\\-|\\+))+))/gim;\n\t    pairs = this._getSegmentPairs(segment.match(nRgx));\n\t    lastPoint = pairs[pairs.length - 1];\n\t    x = lastPoint[0];\n\t    parsedX = Number(x);\n\t    if (parsedX !== value) {\n\t      segment = '';\n\t      lastPoint[0] = value;\n\t      for (i = j = 0, len1 = pairs.length; j < len1; i = ++j) {\n\t        point = pairs[i];\n\t        space = i === 0 ? '' : ' ';\n\t        segment += \"\" + space + point[0] + \",\" + point[1];\n\t      }\n\t    }\n\t    return segment;\n\t  };\n\n\t  PathEasing.prototype._getSegmentPairs = function(array) {\n\t    var i, j, len1, newArray, pair, value;\n\t    if (array.length % 2 !== 0) {\n\t      h.error('Failed to parse the path - segment pairs are not even.', array);\n\t    }\n\t    newArray = [];\n\t    for (i = j = 0, len1 = array.length; j < len1; i = j += 2) {\n\t      value = array[i];\n\t      pair = [array[i], array[i + 1]];\n\t      newArray.push(pair);\n\t    }\n\t    return newArray;\n\t  };\n\n\t  PathEasing.prototype.create = function(path, o) {\n\t    var handler;\n\t    handler = new PathEasing(path, o);\n\t    handler.sample.path = handler.path;\n\t    return handler.sample;\n\t  };\n\n\t  return PathEasing;\n\n\t})();\n\n\tmodule.exports = PathEasing;\n\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports) {\n\n\tvar create, easing, getNearest, mix, parseIfEasing, sort,\n\t  slice = [].slice;\n\n\teasing = null;\n\n\tparseIfEasing = function(item) {\n\t  if (typeof item.value === 'number') {\n\t    return item.value;\n\t  } else {\n\t    return easing.parseEasing(item.value);\n\t  }\n\t};\n\n\tsort = function(a, b) {\n\t  var returnValue;\n\t  a.value = parseIfEasing(a);\n\t  b.value = parseIfEasing(b);\n\t  returnValue = 0;\n\t  a.to < b.to && (returnValue = -1);\n\t  a.to > b.to && (returnValue = 1);\n\t  return returnValue;\n\t};\n\n\tgetNearest = function(array, progress) {\n\t  var i, index, j, len, value;\n\t  index = 0;\n\t  for (i = j = 0, len = array.length; j < len; i = ++j) {\n\t    value = array[i];\n\t    index = i;\n\t    if (value.to > progress) {\n\t      break;\n\t    }\n\t  }\n\t  return index;\n\t};\n\n\tmix = function() {\n\t  var args;\n\t  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t  if (args.length > 1) {\n\t    args = args.sort(sort);\n\t  } else {\n\t    args[0].value = parseIfEasing(args[0]);\n\t  }\n\t  return function(progress) {\n\t    var index, value;\n\t    index = getNearest(args, progress);\n\t    if (index !== -1) {\n\t      value = args[index].value;\n\t      if (index === args.length - 1 && progress > args[index].to) {\n\t        return 1;\n\t      }\n\t      if (typeof value === 'function') {\n\t        return value(progress);\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\t  };\n\t};\n\n\tcreate = function(e) {\n\t  easing = e;\n\t  return mix;\n\t};\n\n\tmodule.exports = create;\n\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(3);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  Method to bootstrap approximation function.\n\t  @private\n\t  @param   {Object} Samples Object.\n\t  @returns {Function} Approximate function.\n\t*/\n\tvar _proximate = function _proximate(samples) {\n\t  var n = samples.base,\n\t      samplesAmount = Math.pow(10, n),\n\t      samplesStep = 1 / samplesAmount;\n\n\t  function RoundNumber(input, numberDecimals) {\n\t    numberDecimals = +numberDecimals || 0; // +var magic!\n\n\t    var multiplyer = Math.pow(10.0, numberDecimals);\n\n\t    return Math.round(input * multiplyer) / multiplyer;\n\t  }\n\n\t  var cached = function cached(p) {\n\t    var newKey = RoundNumber(p, n),\n\t        sample = samples[newKey.toString()];\n\n\t    if (Math.abs(p - newKey) < samplesStep) {\n\t      return sample;\n\t    }\n\n\t    if (p > newKey) {\n\t      var nextIndex = newKey + samplesStep;\n\t      var nextValue = samples[nextIndex];\n\t    } else {\n\t      var nextIndex = newKey - samplesStep;\n\t      var nextValue = samples[nextIndex];\n\t    }\n\n\t    var dLength = nextIndex - newKey;\n\t    var dValue = nextValue - sample;\n\t    if (dValue < samplesStep) {\n\t      return sample;\n\t    }\n\n\t    var progressScale = (p - newKey) / dLength;\n\t    var coef = nextValue > sample ? -1 : 1;\n\t    var scaledDifference = coef * progressScale * dValue;\n\n\t    return sample + scaledDifference;\n\t  };\n\n\t  cached.getSamples = function () {\n\t    return samples;\n\t  };\n\n\t  return cached;\n\t};\n\t/*\n\t    Method to take samples of the function and call the _proximate\n\t    method with the dunction and samples. Or if samples passed - pipe\n\t    them to the _proximate method without sampling.\n\t    @private\n\t    @param {Function} Function to sample.\n\t    @param {Number, Object, String} Precision or precomputed samples.\n\t  */\n\tvar _sample = function _sample(fn) {\n\t  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n\n\n\t  var nType = typeof n === 'undefined' ? 'undefined' : (0, _typeof3.default)(n);\n\n\t  var samples = {};\n\t  if (nType === 'number') {\n\t    var p = 0,\n\t        samplesCount = Math.pow(10, n),\n\t        step = 1 / samplesCount;\n\n\t    samples[0] = fn(0);\n\t    for (var i = 0; i < samplesCount - 1; i++) {\n\t      p += step;\n\n\t      var index = parseFloat(p.toFixed(n));\n\t      samples[index] = fn(p);\n\t    }\n\t    samples[1] = fn(1);\n\n\t    samples.base = n;\n\t  } else if (nType === 'object') {\n\t    samples = n;\n\t  } else if (nType === 'string') {\n\t    samples = JSON.parse(n);\n\t  }\n\n\t  return Approximate._sample._proximate(samples);\n\t};\n\n\tvar Approximate = { _sample: _sample, _proximate: _proximate };\n\tApproximate._sample._proximate = Approximate._proximate;\n\n\texports.default = Approximate._sample;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _getIterator2 = __webpack_require__(111);\n\n\tvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _tweener = __webpack_require__(102);\n\n\tvar _tweener2 = _interopRequireDefault(_tweener);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Timeline = function (_Tween) {\n\t  (0, _inherits3.default)(Timeline, _Tween);\n\n\t  /*\n\t    API method to add child tweens/timelines.\n\t    @public\n\t    @param {Object, Array} Tween/Timeline or an array of such.\n\t    @returns {Object} Self.\n\t  */\n\t  Timeline.prototype.add = function add() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    this._pushTimelineArray(args);\n\t    this._calcDimentions();\n\t    return this;\n\t  };\n\t  /*\n\t    API method to append the Tween/Timeline to the end of the\n\t    timeline. Each argument is treated as a new append.\n\t    Array of tweens is treated as a parallel sequence. \n\t    @public\n\t    @param {Object, Array} Tween/Timeline to append or array of such.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Timeline.prototype.append = function append() {\n\t    for (var _len2 = arguments.length, timeline = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      timeline[_key2] = arguments[_key2];\n\t    }\n\n\t    for (var _iterator = timeline, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n\t      var _ref;\n\n\t      if (_isArray) {\n\t        if (_i >= _iterator.length) break;\n\t        _ref = _iterator[_i++];\n\t      } else {\n\t        _i = _iterator.next();\n\t        if (_i.done) break;\n\t        _ref = _i.value;\n\t      }\n\n\t      var tm = _ref;\n\n\t      if (_h2.default.isArray(tm)) {\n\t        this._appendTimelineArray(tm);\n\t      } else {\n\t        this._appendTimeline(tm, this._timelines.length);\n\t      }\n\t      this._calcDimentions();\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    API method to stop the Tween.\n\t    @public\n\t    @param   {Number} Progress [0..1] to set when stopped.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Timeline.prototype.stop = function stop(progress) {\n\t    _Tween.prototype.stop.call(this, progress);\n\t    this._stopChildren(progress);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to reset tween's state and properties.\n\t    @public\n\t    @overrides @ Tween\n\t    @returns this.\n\t  */\n\n\n\t  Timeline.prototype.reset = function reset() {\n\t    _Tween.prototype.reset.call(this);\n\t    this._resetChildren();\n\t    return this;\n\t  };\n\t  /*\n\t    Method to call `reset` method on all children.\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._resetChildren = function _resetChildren() {\n\t    for (var i = 0; i < this._timelines.length; i++) {\n\t      this._timelines[i].reset();\n\t    }\n\t  };\n\t  /*\n\t    Method to call `stop` method on all children.\n\t    @private\n\t    @param   {Number} Progress [0..1] to set when stopped.\n\t  */\n\n\n\t  Timeline.prototype._stopChildren = function _stopChildren(progress) {\n\t    for (var i = this._timelines.length - 1; i >= 0; i--) {\n\t      this._timelines[i].stop(progress);\n\t    }\n\t  };\n\t  /*\n\t    Method to set tween's state to complete.\n\t    @private\n\t    @overrides @ Tween\n\t    @param {Number} Current time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\t  // _complete ( time, isYoyo ) {\n\t  //   // this._updateChildren( 1, time, isYoyo );\n\t  //   // this._setProgress( 1, time, isYoyo );\n\t  //   super._complete( time, isYoyo );\n\t  //   // this._resetChildren();\n\t  // }\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to append Tween/Timeline array or mix of such.\n\t    @private\n\t    @param {Array} Array of Tweens/Timelines.\n\t  */\n\n\n\t  Timeline.prototype._appendTimelineArray = function _appendTimelineArray(timelineArray) {\n\t    var i = timelineArray.length,\n\t        time = this._props.repeatTime - this._props.delay,\n\t        len = this._timelines.length;\n\n\t    while (i--) {\n\t      this._appendTimeline(timelineArray[i], len, time);\n\t    }\n\t  };\n\t  /*\n\t    Method to append a single timeline to the Timeline.\n\t    @private\n\t    @param {Object} Tween/Timline to append.\n\t    @param {Number} Index of the append.\n\t    @param {Number} Shift time.\n\t  */\n\n\n\t  Timeline.prototype._appendTimeline = function _appendTimeline(timeline, index, time) {\n\t    // if timeline is a module with timeline property then extract it\n\t    if (timeline.timeline instanceof Timeline) {\n\t      timeline = timeline.timeline;\n\t    }\n\t    if (timeline.tween instanceof _tween2.default) {\n\t      timeline = timeline.tween;\n\t    }\n\n\t    var shift = time != null ? time : this._props.duration;\n\t    shift += timeline._props.shiftTime || 0;\n\t    timeline.index = index;this._pushTimeline(timeline, shift);\n\t  };\n\t  /*\n\t    PrivateMethod to push Tween/Timeline array.\n\t    @private\n\t    @param {Array} Array of Tweens/Timelines.\n\t  */\n\n\n\t  Timeline.prototype._pushTimelineArray = function _pushTimelineArray(array) {\n\t    for (var i = 0; i < array.length; i++) {\n\t      var tm = array[i];\n\t      // recursive push to handle arrays of arrays\n\t      if (_h2.default.isArray(tm)) {\n\t        this._pushTimelineArray(tm);\n\t      } else {\n\t        this._pushTimeline(tm);\n\t      }\n\t    };\n\t  };\n\t  /*\n\t    Method to push a single Tween/Timeline.\n\t    @private\n\t    @param {Object} Tween or Timeline to push.\n\t    @param {Number} Number of milliseconds to shift the start time\n\t                    of the Tween/Timeline.\n\t  */\n\n\n\t  Timeline.prototype._pushTimeline = function _pushTimeline(timeline, shift) {\n\t    // if timeline is a module with timeline property then extract it\n\t    if (timeline.timeline instanceof Timeline) {\n\t      timeline = timeline.timeline;\n\t    }\n\t    if (timeline.tween instanceof _tween2.default) {\n\t      timeline = timeline.tween;\n\t    }\n\t    // add self delay to the timeline\n\t    shift != null && timeline._setProp({ 'shiftTime': shift });\n\t    this._timelines.push(timeline);\n\t    this._recalcDuration(timeline);\n\t  };\n\t  /*\n\t    Method set progress on self and child Tweens/Timelines.\n\t    @private\n\t    @param {Number} Progress to set.\n\t    @param {Number} Current update time.\n\t  */\n\n\n\t  Timeline.prototype._setProgress = function _setProgress(p, time, isYoyo) {\n\t    // we need to pass self previous time to children\n\t    // to prevent initial _wasUnknownUpdate nested waterfall\n\t    // if not yoyo option set, pass the previous time\n\t    // otherwise, pass previous or next time regarding yoyo period.\n\n\t    // COVER CURRENT SWAPPED ORDER\n\t    this._updateChildren(p, time, isYoyo);\n\n\t    _tween2.default.prototype._setProgress.call(this, p, time);\n\t  };\n\n\t  Timeline.prototype._updateChildren = function _updateChildren(p, time, isYoyo) {\n\t    var coef = time > this._prevTime ? -1 : 1;\n\t    if (this._props.isYoyo && isYoyo) {\n\t      coef *= -1;\n\t    }\n\t    var timeToTimelines = this._props.startTime + p * this._props.duration,\n\t        prevTimeToTimelines = timeToTimelines + coef,\n\t        len = this._timelines.length;\n\n\t    for (var i = 0; i < len; i++) {\n\t      // specify the children's array update loop direction\n\t      // if time > prevTime go from 0->length else from length->0\n\t      // var j = ( time > this._prevTime ) ? i : (len-1) - i ;\n\t      var j = timeToTimelines > prevTimeToTimelines ? i : len - 1 - i;\n\t      this._timelines[j]._update(timeToTimelines, prevTimeToTimelines, this._prevYoyo, this._onEdge);\n\t    }\n\t    this._prevYoyo = isYoyo;\n\t  };\n\t  /*\n\t    Method calculate self duration based on timeline's duration.\n\t    @private\n\t    @param {Object} Tween or Timeline to calculate.\n\t  */\n\n\n\t  Timeline.prototype._recalcDuration = function _recalcDuration(timeline) {\n\t    var p = timeline._props,\n\t        timelineTime = p.repeatTime / p.speed + (p.shiftTime || 0) + timeline._negativeShift;\n\n\t    this._props.duration = Math.max(timelineTime, this._props.duration);\n\t  };\n\t  /*\n\t    Method calculate self duration from skretch.\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._recalcTotalDuration = function _recalcTotalDuration() {\n\t    var i = this._timelines.length;\n\t    this._props.duration = 0;\n\t    while (i--) {\n\t      var tm = this._timelines[i];\n\t      // recalc total duration on child timelines\n\t      tm._recalcTotalDuration && tm._recalcTotalDuration();\n\t      // add the timeline's duration to selft duration\n\t      this._recalcDuration(tm);\n\t    }\n\t    this._calcDimentions();\n\t  };\n\t  /*\n\t    Method set start and end times.\n\t    @private\n\t    @param {Number, Null} Time to start with.\n\t  */\n\n\n\t  Timeline.prototype._setStartTime = function _setStartTime(time) {\n\t    var isReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t    _Tween.prototype._setStartTime.call(this, time);\n\t    this._startTimelines(this._props.startTime, isReset);\n\t  };\n\t  /*\n\t    Method calculate self duration based on timeline's duration.\n\t    @private\n\t    @param {Number, Null} Time to start with.\n\t  */\n\n\n\t  Timeline.prototype._startTimelines = function _startTimelines(time) {\n\t    var isReset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n\t    var p = this._props,\n\t        isStop = this._state === 'stop';\n\n\t    time == null && (time = this._props.startTime);\n\n\t    for (var i = 0; i < this._timelines.length; i++) {\n\t      var tm = this._timelines[i];\n\t      tm._setStartTime(time, isReset);\n\t      // if from `_subPlay` and `_prevTime` is set and state is `stop`\n\t      // prevTime normalizing is for play/pause functionality, so no\n\t      // need to normalize if the timeline is in `stop` state.\n\t      if (!isReset && tm._prevTime != null && !isStop) {\n\t        tm._prevTime = tm._normPrevTimeForward();\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to launch onRefresh callback.\n\t    @method _refresh\n\t    @private\n\t    @overrides @ Tween\n\t    @param {Boolean} If refresh even before start time.\n\t  */\n\n\n\t  Timeline.prototype._refresh = function _refresh(isBefore) {\n\t    var len = this._timelines.length;\n\t    for (var i = 0; i < len; i++) {\n\t      this._timelines[i]._refresh(isBefore);\n\t    }\n\t    _Tween.prototype._refresh.call(this, isBefore);\n\t  };\n\t  /*\n\t    Method do declare defaults by this._defaults object\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._declareDefaults = function _declareDefaults() {\n\t    // if duration was passed on initialization stage, warn user and reset it.\n\t    if (this._o.duration != null) {\n\t      _h2.default.error('Duration can not be declared on Timeline, but \"' + this._o.duration + '\" is. You probably want to use Tween instead.');\n\t      this._o.duration = 0;\n\t    }\n\t    _Tween.prototype._declareDefaults.call(this);\n\t    // remove default \n\t    this._defaults.duration = 0;\n\t    this._defaults.easing = 'Linear.None';\n\t    this._defaults.backwardEasing = 'Linear.None';\n\t    this._defaults.nameBase = 'Timeline';\n\t  };\n\n\t  function Timeline() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Timeline);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tween.call(this, o));\n\t  }\n\t  /*\n\t    Method to declare some vars.\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._vars = function _vars() {\n\t    this._timelines = [];\n\t    _Tween.prototype._vars.call(this);\n\t  };\n\n\t  return Timeline;\n\t}(_tween2.default);\n\n\texports.default = Timeline;\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(112), __esModule: true };\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(50);\n\t__webpack_require__(6);\n\tmodule.exports = __webpack_require__(113);\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(19)\n\t  , get      = __webpack_require__(114);\n\tmodule.exports = __webpack_require__(14).getIterator = function(it){\n\t  var iterFn = get(it);\n\t  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n\t  return anObject(iterFn.call(it));\n\t};\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(115)\n\t  , ITERATOR  = __webpack_require__(47)('iterator')\n\t  , Iterators = __webpack_require__(29);\n\tmodule.exports = __webpack_require__(14).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(37)\n\t  , TAG = __webpack_require__(47)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _thenable = __webpack_require__(99);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Tuneable = function (_Thenable) {\n\t  (0, _inherits3.default)(Tuneable, _Thenable);\n\n\t  function Tuneable() {\n\t    (0, _classCallCheck3.default)(this, Tuneable);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Thenable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to start the animation with optional new options.\n\t    @public\n\t    @param {Object} New options to set on the run.\n\t    @returns {Object} this.\n\t  */\n\t  Tuneable.prototype.tune = function tune(o) {\n\t    // if options object was passed\n\t    if (o && (0, _keys2.default)(o).length) {\n\t      this._transformHistory(o);\n\t      this._tuneNewOptions(o);\n\t      // restore array prop values because _props\n\t      // contain them as parsed arrays\n\t      // but we need the as strings to store in history\n\t      // and merge in history chains\n\t      this._history[0] = _h2.default.cloneObj(this._props);\n\t      for (var key in this._arrayPropertyMap) {\n\t        if (o[key] != null) {\n\t          this._history[0][key] = this._preparsePropValue(key, o[key]);\n\t        }\n\t      }\n\n\t      this._tuneSubModules();\n\t      this._resetTweens();\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to regenerate all the random properties form initial object.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tuneable.prototype.generate = function generate() {\n\t    return this.tune(this._o);\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to preparse options in object.\n\t    @private\n\t    @param {Object} Object to preparse properties on.\n\t    @returns {Object} Passed object with preparsed props.\n\t  */\n\t  // _preParseOptions ( o ) {\n\t  //   for (var key in o) {\n\t  //     o[key] = this._preparsePropValue( key, o[key] );\n\t  //   }\n\t  //   return o;\n\t  // }\n\t  /*\n\t    Method to transform history rewrite new options object chain on run.\n\t    @private\n\t    @param {Object} New options to tune for.\n\t  */\n\n\n\t  Tuneable.prototype._transformHistory = function _transformHistory(o) {\n\t    for (var key in o) {\n\t      var value = o[key];\n\t      // don't transform for childOptions\n\t      // if ( key === 'childOptions' ) { continue; }\n\t      this._transformHistoryFor(key, this._preparsePropValue(key, value));\n\t    }\n\t  };\n\t  /*\n\t    Method to transform history chain for specific key/value.\n\t    @param {String} Name of the property to transform history for.\n\t    @param {Any} The new property's value.\n\t  */\n\n\n\t  Tuneable.prototype._transformHistoryFor = function _transformHistoryFor(key, value) {\n\t    for (var i = 0; i < this._history.length; i++) {\n\t      if (value = this._transformHistoryRecord(i, key, value)) {\n\t        // break if no further history modifications needed\n\t        if (value == null) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to transform history recod with key/value.\n\t    @param {Number} Index of the history record to transform.\n\t    @param {String} Property name to transform.\n\t    @param {Any} Property value to transform to.\n\t    @param {Object} Optional the current history record.\n\t    @param {Object} Optional the next history record.\n\t    @returns {Boolean} Returns true if no further\n\t                       history modifications is needed.\n\t  */\n\n\n\t  Tuneable.prototype._transformHistoryRecord = function _transformHistoryRecord(index, key, newVal, currRecord, nextRecord) {\n\t    // newVal = this._parseProperty( key, newVal );\n\t    if (newVal == null) {\n\t      return null;\n\t    }\n\n\t    // fallback to history records, if wasn't specified\n\t    currRecord = currRecord == null ? this._history[index] : currRecord;\n\t    nextRecord = nextRecord == null ? this._history[index + 1] : nextRecord;\n\n\t    var oldVal = currRecord[key],\n\t        nextVal = nextRecord == null ? null : nextRecord[key];\n\n\t    // if index is 0 - always save the newVal\n\t    // and return non-delta for subsequent modifications\n\t    if (index === 0) {\n\t      currRecord[key] = newVal;\n\t      // always return on tween properties\n\t      if (_h2.default.isTweenProp(key) && key !== 'duration') {\n\t        return null;\n\t      }\n\t      // nontween properties\n\t      var isRewriteNext = this._isRewriteNext(oldVal, nextVal),\n\t          returnVal = this._isDelta(newVal) ? _h2.default.getDeltaEnd(newVal) : newVal;\n\t      return isRewriteNext ? returnVal : null;\n\t    } else {\n\t      // if was delta and came none-deltta - rewrite\n\t      // the start of the delta and stop\n\t      if (this._isDelta(oldVal)) {\n\t        var _currRecord$key;\n\n\t        currRecord[key] = (_currRecord$key = {}, _currRecord$key[newVal] = _h2.default.getDeltaEnd(oldVal), _currRecord$key);\n\t        return null;\n\t      } else {\n\t        // if the old value is not delta and the new one is\n\t        currRecord[key] = newVal;\n\t        // if the next item has the same value - return the\n\t        // item for subsequent modifications or stop\n\t        return this._isRewriteNext(oldVal, nextVal) ? newVal : null;\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to check if the next item should\n\t    be rewrited in transform history operation.\n\t    @private\n\t    @param {Any} Current value.\n\t    @param {Any} Next value.\n\t    @returns {Boolean} If need to rewrite the next value.\n\t  */\n\n\n\t  Tuneable.prototype._isRewriteNext = function _isRewriteNext(currVal, nextVal) {\n\t    // return false if nothing to rewrite next\n\t    if (nextVal == null && currVal != null) {\n\t      return false;\n\t    }\n\n\t    var isEqual = currVal === nextVal,\n\t        isNextDelta = this._isDelta(nextVal),\n\t        isDelta = this._isDelta(currVal),\n\t        isValueDeltaChain = false,\n\t        isDeltaChain = false;\n\n\t    if (isDelta && isNextDelta) {\n\t      if (_h2.default.getDeltaEnd(currVal) == _h2.default.getDeltaStart(nextVal)) {\n\t        isDeltaChain = true;\n\t      }\n\t    } else if (isNextDelta) {\n\t      isValueDeltaChain = _h2.default.getDeltaStart(nextVal) === '' + currVal;\n\t    }\n\n\t    return isEqual || isValueDeltaChain || isDeltaChain;\n\t  };\n\t  /*\n\t    Method to tune new history options to all the submodules.\n\t    @private\n\t  */\n\n\n\t  Tuneable.prototype._tuneSubModules = function _tuneSubModules() {\n\t    for (var i = 1; i < this._modules.length; i++) {\n\t      this._modules[i]._tuneNewOptions(this._history[i]);\n\t    }\n\t  };\n\t  /*\n\t    Method to set new options on run.\n\t    @param {Boolean} If foreign context.\n\t    @private\n\t  */\n\n\n\t  Tuneable.prototype._resetTweens = function _resetTweens() {\n\t    var i = 0,\n\t        shift = 0,\n\t        tweens = this.timeline._timelines;\n\n\t    // if `isTimelineLess` return\n\t    if (tweens == null) {\n\t      return;\n\t    }\n\n\t    for (var i = 0; i < tweens.length; i++) {\n\t      var tween = tweens[i],\n\t          prevTween = tweens[i - 1];\n\n\t      shift += prevTween ? prevTween._props.repeatTime : 0;\n\t      this._resetTween(tween, this._history[i], shift);\n\t    }\n\t    this.timeline._setProp(this._props.timeline);\n\t    this.timeline._recalcTotalDuration();\n\t  };\n\t  /*\n\t    Method to reset tween with new options.\n\t    @param {Object} Tween to reset.\n\t    @param {Object} Tween's to reset tween with.\n\t    @param {Number} Optional number to shift tween start time.\n\t  */\n\n\n\t  Tuneable.prototype._resetTween = function _resetTween(tween, o) {\n\t    var shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t    o.shiftTime = shift;tween._setProp(o);\n\t  };\n\n\t  return Tuneable;\n\t}(_thenable2.default);\n\n\texports.default = Tuneable;\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _shape = __webpack_require__(94);\n\n\tvar _shape2 = _interopRequireDefault(_shape);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  *TODO:*\n\t  ---\n\t  - tweak then chains\n\t*/\n\n\tvar ShapeSwirl = function (_Shape) {\n\t  (0, _inherits3.default)(ShapeSwirl, _Shape);\n\n\t  function ShapeSwirl() {\n\t    (0, _classCallCheck3.default)(this, ShapeSwirl);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Shape.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare _defaults and other default objects.\n\t    @private\n\t    @override @ Shape\n\t  */\n\t  ShapeSwirl.prototype._declareDefaults = function _declareDefaults() {\n\t    _Shape.prototype._declareDefaults.call(this);\n\n\t    /* _DEFAULTS ARE - Shape DEFAULTS + THESE: */\n\n\t    /* [boolean] :: If shape should follow sinusoidal path. */\n\t    this._defaults.isSwirl = true;\n\t    /* ∆ :: [number > 0] :: Degree size of the sinusoidal path. */\n\t    this._defaults.swirlSize = 10;\n\t    /* ∆ :: [number > 0] :: Frequency of the sinusoidal path. */\n\t    this._defaults.swirlFrequency = 3;\n\t    /* ∆ :: [number > 0] :: Sinusoidal path length scale. */\n\t    this._defaults.pathScale = 1;\n\t    /* ∆ :: [number] :: Degree shift for the sinusoidal path. */\n\t    this._defaults.degreeShift = 0;\n\t    /* ∆ :: [number] :: Radius of the shape. */\n\t    this._defaults.radius = 5;\n\t    // ∆ :: Units :: Possible values: [ number, string ]\n\t    this._defaults.x = 0;\n\t    // ∆ :: Units :: Possible values: [ number, string ]\n\t    this._defaults.y = 0;\n\t    // ∆ :: Possible values: [ number ]\n\t    this._defaults.scale = { 1: 0 };\n\t    /* [number: -1, 1] :: Directon of Swirl. */\n\t    this._defaults.direction = 1;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to copy _o options to _props with\n\t    fallback to _defaults.\n\t    @private\n\t    @override @ Module\n\t  */\n\n\n\t  ShapeSwirl.prototype._extendDefaults = function _extendDefaults() {\n\t    _Shape.prototype._extendDefaults.call(this);\n\t    this._calcPosData();\n\t  };\n\t  /*\n\t    Method to tune new oprions to _o and _props object.\n\t    @private\n\t    @overrides @ Module\n\t    @param {Object} Options object to tune to.\n\t  */\n\n\n\t  ShapeSwirl.prototype._tuneNewOptions = function _tuneNewOptions(o) {\n\t    if (o == null) {\n\t      return;\n\t    }\n\n\t    _Shape.prototype._tuneNewOptions.call(this, o);\n\t    if (o.x != null || o.y != null) {\n\t      this._calcPosData();\n\t    }\n\t  };\n\t  /*\n\t    Method to calculate Swirl's position data.\n\t    @private\n\t  */\n\n\n\t  ShapeSwirl.prototype._calcPosData = function _calcPosData() {\n\t    var x = this._getPosValue('x'),\n\t        y = this._getPosValue('y'),\n\t        angle = 90 + Math.atan(y.delta / x.delta || 0) * _h2.default.RAD_TO_DEG;\n\n\t    this._posData = {\n\t      radius: Math.sqrt(x.delta * x.delta + y.delta * y.delta),\n\t      angle: x.delta < 0 ? angle + 180 : angle,\n\t      x: x, y: y\n\t    };\n\t    // set the last position to _props\n\t    // this._calcSwirlXY( 1 );\n\t  };\n\t  /*\n\t    Gets `x` or `y` position value.\n\t    @private\n\t    @param {String} Name of the property.\n\t  */\n\n\n\t  ShapeSwirl.prototype._getPosValue = function _getPosValue(name) {\n\t    var delta = this._deltas[name];\n\t    if (delta) {\n\t      // delete from deltas to prevent normal\n\t      delete this._deltas[name];\n\t      return {\n\t        start: delta.start.value,\n\t        end: delta.end.value,\n\t        delta: delta.delta,\n\t        units: delta.end.unit\n\t      };\n\t    } else {\n\t      var pos = _h2.default.parseUnit(this._props[name]);\n\t      return { start: pos.value, end: pos.value, delta: 0, units: pos.unit };\n\t    }\n\t  };\n\t  /*\n\t    Method to calculate the progress of the Swirl.\n\t    @private\n\t    @overrides @ Shape\n\t    @param {Numer} Eased progress of the Swirl in range of [0..1]\n\t    @param {Numer} Progress of the Swirl in range of [0..1]\n\t  */\n\n\n\t  ShapeSwirl.prototype._setProgress = function _setProgress(easedProgress, progress) {\n\t    this._progress = easedProgress;\n\t    this._calcCurrentProps(easedProgress, progress);\n\t    this._calcSwirlXY(easedProgress);\n\t    // this._calcOrigin();\n\t    this._draw(easedProgress);\n\t  };\n\t  /*\n\t    Method to calculate x/y for Swirl's progress\n\t    @private\n\t    @mutates _props\n\t    @param {Number} Current progress in [0...1]\n\t  */\n\n\n\t  ShapeSwirl.prototype._calcSwirlXY = function _calcSwirlXY(proc) {\n\t    var p = this._props,\n\t        angle = this._posData.angle + p.degreeShift,\n\t        point = _h2.default.getRadialPoint({\n\t      angle: p.isSwirl ? angle + this._getSwirl(proc) : angle,\n\t      radius: proc * this._posData.radius * p.pathScale,\n\t      center: {\n\t        x: this._posData.x.start,\n\t        y: this._posData.y.start\n\t      }\n\t    });\n\t    // if foreign svg canvas - set position without units\n\t    var x = point.x,\n\t        y = point.y,\n\t        smallNumber = 0.000001;\n\n\t    // remove very small numbers to prevent exponential forms\n\t    if (x > 0 && x < smallNumber) {\n\t      x = smallNumber;\n\t    }\n\t    if (y > 0 && y < smallNumber) {\n\t      y = smallNumber;\n\t    }\n\t    if (x < 0 && x > -smallNumber) {\n\t      x = -smallNumber;\n\t    }\n\t    if (y < 0 && y > -smallNumber) {\n\t      y = -smallNumber;\n\t    }\n\n\t    p.x = this._o.ctx ? x : '' + x + this._posData.x.units;\n\t    p.y = this._o.ctx ? y : '' + y + this._posData.y.units;\n\t  };\n\t  /*\n\t    Method to get progress of the swirl.\n\t    @private\n\t    @param {Number} Progress of the Swirl.\n\t    @returns {Number} Progress of the swirl.\n\t  */\n\n\n\t  ShapeSwirl.prototype._getSwirl = function _getSwirl(proc) {\n\t    var p = this._props;\n\t    return p.direction * p.swirlSize * Math.sin(p.swirlFrequency * proc);\n\t  };\n\t  /*\n\t    Method to draw shape.\n\t    If !isWithShape - draw self el only, but not shape.\n\t    @private\n\t    @overrides @ Shape.\n\t  */\n\n\n\t  ShapeSwirl.prototype._draw = function _draw() {\n\t    // call _draw or just _drawEl @ Shape depending if there is `shape`\n\t    var methodName = this._props.isWithShape ? '_draw' : '_drawEl';\n\t    _shape2.default.prototype[methodName].call(this);\n\t  };\n\n\t  return ShapeSwirl;\n\t}(_shape2.default);\n\n\texports.default = ShapeSwirl;\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _shapeSwirl = __webpack_require__(117);\n\n\tvar _shapeSwirl2 = _interopRequireDefault(_shapeSwirl);\n\n\tvar _tunable = __webpack_require__(116);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t// import Shape    from './shape';\n\tvar Burst = function (_Tunable) {\n\t  (0, _inherits3.default)(Burst, _Tunable);\n\n\t  function Burst() {\n\t    (0, _classCallCheck3.default)(this, Burst);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tunable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare defaults.\n\t    @override @ ShapeSwirl.\n\t  */\n\t  Burst.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      /* [number > 0] :: Quantity of Burst particles. */\n\t      count: 5,\n\t      /* [0 < number < 360] :: Degree of the Burst. */\n\t      degree: 360,\n\t      /* ∆ :: [number > 0] :: Radius of the Burst. */\n\t      radius: { 0: 50 },\n\t      /* ∆ :: [number > 0] :: X radius of the Burst. */\n\t      radiusX: null,\n\t      /* ∆ :: [number > 0] :: Y radius of the Burst. */\n\t      radiusY: null,\n\t      /* [number >= 0] :: width of the main swirl. */\n\t      width: 0,\n\t      /* [number >= 0] :: height of the main swirl. */\n\t      height: 0\n\t    };\n\t  };\n\t  /*\n\t    Method to create a then record for the module.\n\t    @public\n\t    overrides @ Thenable\n\t    @param    {Object} Options for the next animation.\n\t    @returns  {Object} this.\n\t  */\n\n\n\t  Burst.prototype.then = function then(o) {\n\t    // remove tween properties (not callbacks)\n\t    this._removeTweenProperties(o);\n\n\t    var newMaster = this._masterThen(o),\n\t        newSwirls = this._childThen(o);\n\n\t    this._setSwirlDuration(newMaster, this._calcPackTime(newSwirls));\n\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\n\t    Method to start the animation with optional new options.\n\t    @public\n\t    @param {Object} New options to set on the run.\n\t    @returns {Object} this.\n\t  */\n\n\n\t  Burst.prototype.tune = function tune(o) {\n\t    if (o == null) {\n\t      return this;\n\t    }\n\t    // save timeline options to _timelineOptions\n\t    // and delete the timeline options on o\n\t    // cuz masterSwirl should not get them\n\t    this._saveTimelineOptions(o);\n\n\t    // add new timeline properties to timeline\n\t    this.timeline._setProp(this._timelineOptions);\n\n\t    // remove tween options (not callbacks)\n\t    this._removeTweenProperties(o);\n\n\t    // tune _props\n\t    this._tuneNewOptions(o);\n\n\t    // tune master swirl\n\t    this.masterSwirl.tune(o);\n\n\t    // tune child swirls\n\t    this._tuneSwirls(o);\n\n\t    // recalc time for modules\n\t    this._recalcModulesTime();\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHODS ^\n\t  // v PRIVATE METHODS v\n\n\t  /*\n\t    Method to copy `_o` options to `_props` object\n\t    with fallback to `_defaults`.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Burst.prototype._extendDefaults = function _extendDefaults() {\n\t    // remove tween properties (not callbacks)\n\t    this._removeTweenProperties(this._o);\n\t    _Tunable.prototype._extendDefaults.call(this);\n\t  };\n\t  /*\n\t    Method to remove all tween (excluding\n\t    callbacks) props from object.\n\t    @private\n\t    @param {Object} Object which should be cleaned\n\t                    up from tween properties.\n\t  */\n\n\n\t  Burst.prototype._removeTweenProperties = function _removeTweenProperties(o) {\n\t    for (var key in _h2.default.tweenOptionMap) {\n\t      // remove all items that are not declared in _defaults\n\t      if (this._defaults[key] == null) {\n\t        delete o[key];\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to recalc modules chain tween\n\t    times after tuning new options.\n\t    @private\n\t  */\n\n\n\t  Burst.prototype._recalcModulesTime = function _recalcModulesTime() {\n\t    var modules = this.masterSwirl._modules,\n\t        swirls = this._swirls,\n\t        shiftTime = 0;\n\n\t    for (var i = 0; i < modules.length; i++) {\n\t      var tween = modules[i].tween,\n\t          packTime = this._calcPackTime(swirls[i]);\n\t      tween._setProp({ 'duration': packTime, 'shiftTime': shiftTime });\n\t      shiftTime += packTime;\n\t    }\n\n\t    this.timeline._recalcTotalDuration();\n\t  };\n\t  /*\n\t    Method to tune Swirls with new options.\n\t    @private\n\t    @param {Object} New options.\n\t  */\n\n\n\t  Burst.prototype._tuneSwirls = function _tuneSwirls(o) {\n\t    // get swirls in first pack\n\t    var pack0 = this._swirls[0];\n\t    for (var i = 0; i < pack0.length; i++) {\n\t      var swirl = pack0[i],\n\t          option = this._getChildOption(o || {}, i);\n\n\t      // since the `degreeShift` participate in\n\t      // children position calculations, we need to keep\n\t      // the old `degreeShift` value if new not set\n\t      var isDegreeShift = option.degreeShift != null;\n\t      if (!isDegreeShift) {\n\t        option.degreeShift = this._swirls[0][i]._props.degreeShift;\n\t      }\n\n\t      this._addBurstProperties(option, i);\n\n\t      // after burst position calculation - delete the old `degreeShift`\n\t      // from the options, since anyways we have copied it from the swirl\n\t      if (!isDegreeShift) {\n\t        delete option.degreeShift;\n\t      }\n\n\t      swirl.tune(option);\n\t      this._refreshBurstOptions(swirl._modules, i);\n\t    }\n\t  };\n\t  /*\n\t    Method to refresh burst x/y/angle options on further chained \n\t    swirls, because they will be overriden after `tune` call on\n\t    very first swirl.\n\t    @param {Array} Chained modules array\n\t    param {Number} Index of the first swirl in the chain.\n\t  */\n\n\n\t  Burst.prototype._refreshBurstOptions = function _refreshBurstOptions(modules, i) {\n\t    for (var j = 1; j < modules.length; j++) {\n\t      var module = modules[j],\n\t          options = {};\n\t      this._addBurstProperties(options, i, j);\n\t      module._tuneNewOptions(options);\n\t    }\n\t  };\n\t  /*\n\t    Method to call then on masterSwirl.\n\t    @param {Object} Then options.\n\t    @returns {Object} New master swirl.\n\t  */\n\n\n\t  Burst.prototype._masterThen = function _masterThen(o) {\n\t    this.masterSwirl.then(o);\n\t    // get the latest master swirl in then chain\n\t    var newMasterSwirl = _h2.default.getLastItem(this.masterSwirl._modules);\n\t    // save to masterSwirls\n\t    this._masterSwirls.push(newMasterSwirl);\n\t    return newMasterSwirl;\n\t  };\n\t  /*\n\t    Method to call then on child swilrs.\n\t    @param {Object} Then options.\n\t    @return {Array} Array of new Swirls.\n\t  */\n\n\n\t  Burst.prototype._childThen = function _childThen(o) {\n\t    var pack = this._swirls[0],\n\t        newPack = [];\n\n\t    for (var i = 0; i < pack.length; i++) {\n\t      // get option by modulus\n\t      var options = this._getChildOption(o, i);\n\t      var swirl = pack[i];\n\t      var lastSwirl = _h2.default.getLastItem(swirl._modules);\n\t      // add new Master Swirl as parent of new childswirl\n\t      options.parent = this.el;\n\n\t      this._addBurstProperties(options, i, this._masterSwirls.length - 1);\n\n\t      swirl.then(options);\n\n\t      // save the new item in `then` chain\n\t      newPack.push(_h2.default.getLastItem(swirl._modules));\n\t    }\n\t    // save the pack to _swirls object\n\t    this._swirls[this._masterSwirls.length - 1] = newPack;\n\t    return newPack;\n\t  };\n\t  /*\n\t    Method to initialize properties.\n\t    @private\n\t    @overrides @ Thenable\n\t  */\n\n\n\t  Burst.prototype._vars = function _vars() {\n\t    _Tunable.prototype._vars.call(this);\n\t    // just buffer timeline for calculations\n\t    this._bufferTimeline = new _timeline2.default();\n\t  };\n\t  /*\n\t    Method for initial render of the module.\n\t  */\n\n\n\t  Burst.prototype._render = function _render() {\n\t    this._o.isWithShape = false;\n\t    this._o.isSwirl = this._props.isSwirl;\n\t    this._o.callbacksContext = this;\n\t    // save timeline options and remove from _o\n\t    // cuz the master swirl should not get them\n\t    this._saveTimelineOptions(this._o);\n\n\t    this.masterSwirl = new MainSwirl(this._o);\n\t    this._masterSwirls = [this.masterSwirl];\n\t    this.el = this.masterSwirl.el;\n\n\t    this._renderSwirls();\n\t  };\n\t  /*\n\t    Method for initial render of swirls.\n\t    @private\n\t  */\n\n\n\t  Burst.prototype._renderSwirls = function _renderSwirls() {\n\t    var p = this._props,\n\t        pack = [];\n\n\t    for (var i = 0; i < p.count; i++) {\n\t      var option = this._getChildOption(this._o, i);\n\t      pack.push(new ChildSwirl(this._addOptionalProps(option, i)));\n\t    }\n\t    this._swirls = { 0: pack };\n\t    this._setSwirlDuration(this.masterSwirl, this._calcPackTime(pack));\n\t  };\n\t  /*\n\t    Method to save timeline options to _timelineOptions\n\t    and delete the property on the object.\n\t    @private\n\t    @param {Object} The object to save the timeline options from.\n\t  */\n\n\n\t  Burst.prototype._saveTimelineOptions = function _saveTimelineOptions(o) {\n\t    this._timelineOptions = o.timeline;\n\t    delete o.timeline;\n\t  };\n\t  /*\n\t    Method to calculate total time of array of\n\t    concurrent tweens.\n\t    @param   {Array}  Pack to calculate the total time for.\n\t    @returns {Number} Total pack duration.\n\t  */\n\n\n\t  Burst.prototype._calcPackTime = function _calcPackTime(pack) {\n\t    var maxTime = 0;\n\t    for (var i = 0; i < pack.length; i++) {\n\t      var tween = pack[i].tween,\n\t          p = tween._props;\n\n\t      maxTime = Math.max(p.repeatTime / p.speed, maxTime);\n\t    }\n\n\t    return maxTime;\n\t  };\n\t  /*\n\t    Method to set duration for Swirl.\n\t    @param {Object} Swirl instance to set the duration to.\n\t    @param {Number} Duration to set.\n\t  */\n\n\n\t  Burst.prototype._setSwirlDuration = function _setSwirlDuration(swirl, duration) {\n\t    swirl.tween._setProp('duration', duration);\n\t    var isRecalc = swirl.timeline && swirl.timeline._recalcTotalDuration;\n\t    isRecalc && swirl.timeline._recalcTotalDuration();\n\t  };\n\t  /*\n\t    Method to get childOption form object call by modulus.\n\t    @private\n\t    @param   {Object} Object to look in.\n\t    @param   {Number} Index of the current Swirl.\n\t    @returns {Object} Options for the current swirl.\n\t  */\n\n\n\t  Burst.prototype._getChildOption = function _getChildOption(obj, i) {\n\t    var options = {};\n\t    for (var key in obj.children) {\n\t      options[key] = this._getPropByMod(key, i, obj.children);\n\t    }\n\t    return options;\n\t  };\n\t  /*\n\t    Method to get property by modulus.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Number} Index for the modulus.\n\t    @param {Object} Source object to check in.\n\t    @returns {Any} Property.\n\t  */\n\n\n\t  Burst.prototype._getPropByMod = function _getPropByMod(name, index) {\n\t    var sourceObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t    var prop = sourceObj[name];\n\t    return _h2.default.isArray(prop) ? prop[index % prop.length] : prop;\n\t  };\n\t  /*\n\t    Method to add optional Swirls' properties to passed object.\n\t    @private\n\t    @param {Object} Object to add the properties to.\n\t    @param {Number} Index of the property.\n\t  */\n\n\n\t  Burst.prototype._addOptionalProps = function _addOptionalProps(options, index) {\n\t    options.index = index;\n\t    options.parent = this.masterSwirl.el;\n\n\t    this._addBurstProperties(options, index);\n\n\t    return options;\n\t  };\n\t  /*\n\t    Method to add Burst options to object.\n\t    @private\n\t    @param {Object} Options to add the properties to.\n\t    @param {Number} Index of the Swirl.\n\t    @param {Number} Index of the main swirl.\n\t  */\n\n\n\t  Burst.prototype._addBurstProperties = function _addBurstProperties(options, index, i) {\n\t    // save index of the module\n\t    var mainIndex = this._index;\n\t    // temporary change the index to parse index based properties like stagger\n\t    this._index = index;\n\t    // parse degree shift for the bit\n\t    var degreeShift = this._parseProperty('degreeShift', options.degreeShift || 0);\n\t    // put the index of the module back\n\t    this._index = mainIndex;\n\n\t    var p = this._props,\n\t        degreeCnt = p.degree % 360 === 0 ? p.count : p.count - 1 || 1,\n\t        step = p.degree / degreeCnt,\n\t        pointStart = this._getSidePoint('start', index * step + degreeShift, i),\n\t        pointEnd = this._getSidePoint('end', index * step + degreeShift, i);\n\n\t    options.x = this._getDeltaFromPoints('x', pointStart, pointEnd);\n\t    options.y = this._getDeltaFromPoints('y', pointStart, pointEnd);\n\n\t    options.angle = this._getBitAngle(options.angle || 0, degreeShift, index);\n\t  };\n\t  /* \n\t    Method to get shapes angle in burst so\n\t    it will follow circular shape.\n\t     \n\t     @param    {Number, Object} Base angle.\n\t     @param    {Number}         Angle shift for the bit\n\t     @param    {Number}         Shape's index in burst.\n\t     @returns  {Number}         Angle in burst.\n\t  */\n\n\n\t  Burst.prototype._getBitAngle = function _getBitAngle() {\n\t    var angleProperty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t    var angleShift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t    var i = arguments[2];\n\n\t    var p = this._props,\n\t        degCnt = p.degree % 360 === 0 ? p.count : p.count - 1 || 1,\n\t        step = p.degree / degCnt,\n\t        angle = i * step + 90;\n\n\t    angle += angleShift;\n\t    // if not delta option\n\t    if (!this._isDelta(angleProperty)) {\n\t      angleProperty += angle;\n\t    } else {\n\t      var delta = {},\n\t          keys = (0, _keys2.default)(angleProperty),\n\t          start = keys[0],\n\t          end = angleProperty[start];\n\n\t      start = _h2.default.parseStringOption(start, i);\n\t      end = _h2.default.parseStringOption(end, i);\n\t      // new start = newEnd\n\t      delta[parseFloat(start) + angle] = parseFloat(end) + angle;\n\n\t      angleProperty = delta;\n\t    }\n\t    return angleProperty;\n\t  };\n\t  /*\n\t    Method to get radial point on `start` or `end`.\n\t    @private\n\t    @param {String} Name of the side - [start, end].\n\t    @param {Number} Angle of the radial point.\n\t    @param {Number} Index of the main swirl.\n\t    @returns radial point.\n\t  */\n\n\n\t  Burst.prototype._getSidePoint = function _getSidePoint(side, angle, i) {\n\t    var p = this._props,\n\t        sideRadius = this._getSideRadius(side, i);\n\n\t    return _h2.default.getRadialPoint({\n\t      radius: sideRadius.radius,\n\t      radiusX: sideRadius.radiusX,\n\t      radiusY: sideRadius.radiusY,\n\t      angle: angle,\n\t      // center:  { x: p.center, y: p.center }\n\t      center: { x: 0, y: 0 }\n\t    });\n\t  };\n\t  /*\n\t    Method to get radius of the side.\n\t    @private\n\t    @param {String} Name of the side - [start, end].\n\t    @param {Number} Index of the main swirl.\n\t    @returns {Object} Radius.\n\t  */\n\n\n\t  Burst.prototype._getSideRadius = function _getSideRadius(side, i) {\n\t    return {\n\t      radius: this._getRadiusByKey('radius', side, i),\n\t      radiusX: this._getRadiusByKey('radiusX', side, i),\n\t      radiusY: this._getRadiusByKey('radiusY', side, i)\n\t    };\n\t  };\n\t  /*\n\t    Method to get radius from ∆ or plain property.\n\t    @private\n\t    @param {String} Key name.\n\t    @param {String} Side name - [start, end].\n\t    @param {Number} Index of the main swirl.\n\t    @returns {Number} Radius value.\n\t  */\n\n\n\t  Burst.prototype._getRadiusByKey = function _getRadiusByKey(key, side) {\n\t    var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t    var swirl = this._masterSwirls[i],\n\t        deltas = swirl._deltas,\n\t        props = swirl._props;\n\n\t    if (deltas[key] != null) {\n\t      return deltas[key][side];\n\t    } else if (props[key] != null) {\n\t      return props[key];\n\t    }\n\t  };\n\t  /*\n\t    Method to get delta from start and end position points.\n\t    @private\n\t    @param {String} Key name.\n\t    @param {Object} Start position point.\n\t    @param {Object} End position point.\n\t    @returns {Object} Delta of the end/start.\n\t  */\n\n\n\t  Burst.prototype._getDeltaFromPoints = function _getDeltaFromPoints(key, pointStart, pointEnd) {\n\t    var delta = {};\n\t    if (pointStart[key] === pointEnd[key]) {\n\t      delta = pointStart[key];\n\t    } else {\n\t      delta[pointStart[key]] = pointEnd[key];\n\t    }\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to create timeline.\n\t    @private\n\t    @override @ Tweenable\n\t  */\n\n\n\t  Burst.prototype._makeTimeline = function _makeTimeline() {\n\t    // restore timeline options that were deleted in _render method\n\t    this._o.timeline = this._timelineOptions;\n\t    _Tunable.prototype._makeTimeline.call(this);\n\t    this.timeline.add(this.masterSwirl, this._swirls[0]);\n\t  };\n\t  /*\n\t    Method to make Tween for the module.\n\t    @private\n\t    @override @ Tweenable\n\t  */\n\n\n\t  Burst.prototype._makeTween = function _makeTween() {} /* don't create any tween */\n\t  /*\n\t    Override `_hide` and `_show` methods on module\n\t    since we don't have to hide nor show on the module.\n\t  */\n\t  ;\n\n\t  Burst.prototype._hide = function _hide() {/* do nothing */};\n\n\t  Burst.prototype._show = function _show() {/* do nothing */};\n\n\t  return Burst;\n\t}(_tunable2.default);\n\n\tvar ChildSwirl = function (_ShapeSwirl) {\n\t  (0, _inherits3.default)(ChildSwirl, _ShapeSwirl);\n\n\t  function ChildSwirl() {\n\t    (0, _classCallCheck3.default)(this, ChildSwirl);\n\t    return (0, _possibleConstructorReturn3.default)(this, _ShapeSwirl.apply(this, arguments));\n\t  }\n\n\t  ChildSwirl.prototype._declareDefaults = function _declareDefaults() {\n\t    _ShapeSwirl.prototype._declareDefaults.call(this);\n\t    this._defaults.isSwirl = false;\n\t    this._o.duration = this._o.duration != null ? this._o.duration : 700;\n\t  };\n\t  // disable degreeshift calculations\n\n\n\t  ChildSwirl.prototype._calcSwirlXY = function _calcSwirlXY(proc) {\n\t    var degreeShift = this._props.degreeShift;\n\n\t    this._props.degreeShift = 0;\n\t    _ShapeSwirl.prototype._calcSwirlXY.call(this, proc);\n\t    this._props.degreeShift = degreeShift;\n\t  };\n\n\t  return ChildSwirl;\n\t}(_shapeSwirl2.default);\n\n\tvar MainSwirl = function (_ChildSwirl) {\n\t  (0, _inherits3.default)(MainSwirl, _ChildSwirl);\n\n\t  function MainSwirl() {\n\t    (0, _classCallCheck3.default)(this, MainSwirl);\n\t    return (0, _possibleConstructorReturn3.default)(this, _ChildSwirl.apply(this, arguments));\n\t  }\n\n\t  MainSwirl.prototype._declareDefaults = function _declareDefaults() {\n\t    _ChildSwirl.prototype._declareDefaults.call(this);\n\t    this._defaults.scale = 1;\n\t    this._defaults.width = 0;\n\t    this._defaults.height = 0;\n\t    this._defaults.radius = { 25: 75 };\n\t    // this._defaults.duration = 2000;\n\t  };\n\n\t  return MainSwirl;\n\t}(ChildSwirl);\n\n\tBurst.ChildSwirl = ChildSwirl;\n\tBurst.MainSwirl = MainSwirl;\n\n\texports.default = Burst;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _extends4 = __webpack_require__(120);\n\n\tvar _extends5 = _interopRequireDefault(_extends4);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _thenable = __webpack_require__(99);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _deltas = __webpack_require__(125);\n\n\tvar _deltas2 = _interopRequireDefault(_deltas);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar h = __webpack_require__(71);\n\n\n\t// get tween properties\n\tvar obj = {};\n\t_tween2.default.prototype._declareDefaults.call(obj);\n\tvar keys = (0, _keys2.default)(obj._defaults);\n\tfor (var i = 0; i < keys.length; i++) {\n\t  obj._defaults[keys[i]] = 1;\n\t}\n\tobj._defaults['timeline'] = 1;\n\tvar TWEEN_PROPERTIES = obj._defaults;\n\n\t/*\n\t  TODO:\n\n\t    - change _props to _propsObj for animations\n\t    - current values in deltas\n\t*/\n\n\tvar Html = function (_Thenable) {\n\t  (0, _inherits3.default)(Html, _Thenable);\n\n\t  function Html() {\n\t    (0, _classCallCheck3.default)(this, Html);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Thenable.apply(this, arguments));\n\t  }\n\n\t  Html.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      x: 0,\n\t      y: 0,\n\t      z: 0,\n\n\t      skewX: 0,\n\t      skewY: 0,\n\n\t      // angle:      0,\n\t      angleX: 0,\n\t      angleY: 0,\n\t      angleZ: 0,\n\n\t      scale: 1,\n\t      scaleX: 1,\n\t      scaleY: 1,\n\n\t      isSoftHide: true,\n\t      isShowStart: true,\n\t      isShowEnd: true,\n\t      isForce3d: false,\n\t      isRefreshState: true\n\n\t    };\n\t    // exclude from automatic drawing\n\t    this._drawExclude = { el: 1 };\n\t    // properties that cause 3d layer\n\t    this._3dProperties = ['angleX', 'angleY', 'z'];\n\t    // properties that have array values\n\t    this._arrayPropertyMap = { transformOrigin: 1, backgroundPosition: 1 };\n\t    // properties that have no units\n\t    this._numberPropertyMap = {\n\t      opacity: 1, scale: 1, scaleX: 1, scaleY: 1,\n\t      // angle: 1,\n\t      angleX: 1, angleY: 1, angleZ: 1,\n\t      skewX: 1, skewY: 1\n\t    };\n\t    // properties that should be prefixed \n\t    this._prefixPropertyMap = { transform: 1, transformOrigin: 1 };\n\t    // save prefix\n\t    this._prefix = h.prefix.css;\n\t  };\n\n\t  Html.prototype.then = function then(o) {\n\t    // return if nothing was passed\n\t    if (o == null || !(0, _keys2.default)(o).length) {\n\t      return 1;\n\t    }\n\n\t    // get the last item in `then` chain\n\t    var prevModule = h.getLastItem(this._modules);\n\t    // set deltas to the finish state\n\t    prevModule.deltas.refresh(false);\n\t    // copy finish state to the last history record\n\t    this._history[this._history.length - 1] = prevModule._o;\n\t    // call super\n\t    _Thenable.prototype.then.call(this, o);\n\t    // restore the _props\n\t    prevModule.deltas.restore();\n\n\t    return this;\n\t  };\n\t  /*\n\t    Method to pipe startValue of the delta.\n\t    @private\n\t    @ovarrides @ Thenable\n\t    @param {String} Start property name.\n\t    @param {Any} Start property value.\n\t    @returns {Any} Start property value.\n\t  */\n\n\n\t  Html.prototype._checkStartValue = function _checkStartValue(key, value) {\n\t    if (value == null) {\n\t      // return default value for transforms\n\t      if (this._defaults[key] != null) {\n\t        return this._defaults[key];\n\t      }\n\t      // return default value from _customProps\n\t      if (this._customProps[key] != null) {\n\t        return this._customProps[key];\n\t      }\n\t      // try to get the default value\n\t      if (h.defaultStyles[key] != null) {\n\t        return h.defaultStyles[key];\n\t      }\n\t      // at the end return 0\n\t      return 0;\n\t    }\n\n\t    return value;\n\t  };\n\t  /*\n\t    Method to draw _props to el.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._draw = function _draw() {\n\t    var p = this._props;\n\t    for (var i = 0; i < this._drawProps.length; i++) {\n\t      var name = this._drawProps[i];\n\t      this._setStyle(name, p[name]);\n\t    }\n\t    // draw transforms\n\t    this._drawTransform();\n\t    // call custom transform callback if exist\n\t    this._customDraw && this._customDraw(this._props.el, this._props);\n\t  };\n\t  /*\n\t    Method to set transform on element.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._drawTransform = function _drawTransform() {\n\t    var p = this._props;\n\t    var string = !this._is3d ? 'translate(' + p.x + ', ' + p.y + ')\\n          rotate(' + p.angleZ + 'deg)\\n          skew(' + p.skewX + 'deg, ' + p.skewY + 'deg)\\n          scale(' + p.scaleX + ', ' + p.scaleY + ')' : 'translate3d(' + p.x + ', ' + p.y + ', ' + p.z + ')\\n          rotateX(' + p.angleX + 'deg)\\n          rotateY(' + p.angleY + 'deg)\\n          rotateZ(' + p.angleZ + 'deg)\\n          skew(' + p.skewX + 'deg, ' + p.skewY + 'deg)\\n          scale(' + p.scaleX + ', ' + p.scaleY + ')';\n\n\t    this._setStyle('transform', string);\n\t  };\n\t  /*\n\t    Method to render on initialization.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Html.prototype._render = function _render() {\n\t    // return immediately if not the first in `then` chain\n\t    if (this._o.prevChainModule) {\n\t      return;\n\t    }\n\n\t    var p = this._props;\n\n\t    for (var i = 0; i < this._renderProps.length; i++) {\n\t      var name = this._renderProps[i],\n\t          value = p[name];\n\n\t      value = typeof value === 'number' ? value + 'px' : value;\n\t      this._setStyle(name, value);\n\t    }\n\n\t    this._draw();\n\n\t    if (!p.isShowStart) {\n\t      this._hide();\n\t    }\n\t  };\n\t  /*\n\t    Method to set style on el.\n\t    @private\n\t    @param {String} Style property name.\n\t    @param {String} Style property value.\n\t  */\n\n\n\t  Html.prototype._setStyle = function _setStyle(name, value) {\n\t    if (this._state[name] !== value) {\n\t      var style = this._props.el.style;\n\t      // set style\n\t      style[name] = value;\n\t      // if prefix needed - set it\n\t      if (this._prefixPropertyMap[name]) {\n\t        style['' + this._prefix + name] = value;\n\t      }\n\t      // cache the last set value\n\t      this._state[name] = value;\n\t    }\n\t  };\n\t  /*\n\t    Method to copy `_o` options to `_props` object.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._extendDefaults = function _extendDefaults() {\n\t    this._props = this._o.props || {};\n\t    // props for intial render only\n\t    this._renderProps = [];\n\t    // props for draw on every frame update\n\t    this._drawProps = [];\n\t    // save custom properties if present\n\t    this._saveCustomProperties(this._o);\n\t    // copy the options\n\t    var o = (0, _extends5.default)({}, this._o);\n\t    // extend options with defaults\n\t    o = this._addDefaults(o);\n\n\t    var keys = (0, _keys2.default)(o);\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      // include the property if it is not in drawExclude object\n\t      // and not in defaults = not a transform\n\t      var isInclude = !this._drawExclude[key] && // not in exclude map\n\t      this._defaults[key] == null && // not transform property\n\t      !TWEEN_PROPERTIES[key]; // not tween property\n\n\t      var isCustom = this._customProps[key];\n\t      // copy all non-delta properties to the props\n\t      // if not delta then add the property to render\n\t      // list that is called on initialization\n\t      // otherwise add it to the draw list that will\n\t      // be drawed on each frame\n\t      if (!h.isDelta(o[key]) && !TWEEN_PROPERTIES[key]) {\n\t        this._parseOption(key, o[key]);\n\t        if (key === 'el') {\n\t          this._props.el = h.parseEl(o.el);\n\t          this.el = this._props.el;\n\t        }\n\t        if (isInclude && !isCustom) {\n\t          this._renderProps.push(key);\n\t        }\n\t        // copy delta prop but not transforms\n\t        // otherwise push it to draw list that gets traversed on every draw\n\t      } else if (isInclude && !isCustom) {\n\t        this._drawProps.push(key);\n\t      }\n\t    }\n\n\t    this._createDeltas(o);\n\t  };\n\t  /*\n\t    Method to save customProperties to _customProps.\n\t    @param {Object} Options of the module.\n\t  */\n\n\n\t  Html.prototype._saveCustomProperties = function _saveCustomProperties() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t    this._customProps = o.customProperties || {};\n\t    this._customProps = (0, _extends5.default)({}, this._customProps);\n\t    this._customDraw = this._customProps.draw;\n\t    delete this._customProps.draw;\n\t    delete o.customProperties;\n\n\t    this._copyDefaultCustomProps();\n\n\t    // if ( this._customProps ) {}\n\t    // this._customProps = this._customProps || {};\n\t  };\n\n\t  Html.prototype._copyDefaultCustomProps = function _copyDefaultCustomProps() {\n\t    for (var key in this._customProps) {\n\t      if (this._o[key] == null) {\n\t        this._o[key] = this._customProps[key];\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to reset some flags on merged options object.\n\t    @private\n\t    @overrides @ Thenable\n\t    @param   {Object} Options object.\n\t    @returns {Object} Options object.\n\t  */\n\n\n\t  Html.prototype._resetMergedFlags = function _resetMergedFlags(o) {\n\t    _Thenable.prototype._resetMergedFlags.call(this, o);\n\t    o.props = this._props;\n\t    o.customProperties = this._customProps;\n\t    return o;\n\t  };\n\t  /*\n\t    Method to parse option value.\n\t    @private\n\t    @param {String} Option name.\n\t    @param {Any} Option value.\n\t  */\n\n\n\t  Html.prototype._parseOption = function _parseOption(key, value) {\n\t    _Thenable.prototype._parseOption.call(this, key, value);\n\t    // at this point the property is parsed\n\t    var parsed = this._props[key];\n\t    // cast it to string if it is array\n\t    if (h.isArray(parsed)) {\n\t      this._props[key] = this._arrToString(parsed);\n\t    }\n\t  };\n\t  /*\n\t    Method cast array to string value.\n\t    @private\n\t    @param {Array} Array of parsed numbers with units.\n\t    @returns {String} Casted array.\n\t  */\n\n\n\t  Html.prototype._arrToString = function _arrToString(arr) {\n\t    var string = '';\n\t    for (var i = 0; i < arr.length; i++) {\n\t      string += arr[i].string + ' ';\n\t    }\n\t    return string;\n\t  };\n\t  /*\n\t    Method to add defauls to passed object.\n\t    @private\n\t    @param {Object} Object to add defaults to.\n\t  */\n\n\n\t  Html.prototype._addDefaults = function _addDefaults(obj) {\n\t    // flag that after all defaults are set will indicate\n\t    // if user have set the 3d transform\n\t    this._is3d = false;\n\n\t    for (var key in this._defaults) {\n\t      // skip property if it is listed in _skipProps\n\t      // if (this._skipProps && this._skipProps[key]) { continue; }\n\n\t      // copy the properties to the _o object\n\t      // if it's null - set the default value\n\t      if (obj[key] == null) {\n\t        // scaleX and scaleY should fallback to scale\n\t        if (key === 'scaleX' || key === 'scaleY') {\n\t          obj[key] = obj['scale'] != null ? obj['scale'] : this._defaults['scale'];\n\t        } else {\n\t          obj[key] = this._defaults[key];\n\t        }\n\t      } else {\n\t        // get if 3d property was set.\n\t        if (this._3dProperties.indexOf(key) !== -1) {\n\t          this._is3d = true;\n\t        }\n\t      }\n\t    }\n\n\t    if (this._o.isForce3d) {\n\t      this._is3d = true;\n\t    }\n\n\t    return obj;\n\t  };\n\t  /*\n\t    Lifecycle method to declare variables.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._vars = function _vars() {\n\t    // set deltas to the last value, so the _props with\n\t    // end values will be copied to the _history, it is\n\t    // crucial for `then` chaining\n\t    this.deltas.refresh(false);\n\t    // call super vars\n\t    _Thenable.prototype._vars.call(this);\n\t    // state of set properties\n\t    this._state = {};\n\t    // restore delta values that we have refreshed before\n\t    this.deltas.restore(false);\n\t  };\n\t  /*\n\t    Method to create deltas from passed object.\n\t    @private\n\t    @param {Object} Options object to pass to the Deltas.\n\t  */\n\n\n\t  Html.prototype._createDeltas = function _createDeltas(options) {\n\t    this.deltas = new _deltas2.default({\n\t      options: options,\n\t      props: this._props,\n\t      arrayPropertyMap: this._arrayPropertyMap,\n\t      numberPropertyMap: this._numberPropertyMap,\n\t      customProps: this._customProps,\n\t      callbacksContext: options.callbacksContext || this,\n\t      isChained: !!this._o.prevChainModule\n\t    });\n\n\t    // if chained module set timeline to deltas' timeline \n\t    if (this._o.prevChainModule) {\n\t      this.timeline = this.deltas.timeline;\n\t    }\n\t  };\n\t  /* @overrides @ Tweenable */\n\n\n\t  Html.prototype._makeTween = function _makeTween() {};\n\n\t  Html.prototype._makeTimeline = function _makeTimeline() {\n\t    // do not create timeline if module if chained\n\t    if (this._o.prevChainModule) {\n\t      return;\n\t    }\n\t    // add callbacks overrides\n\t    this._o.timeline = this._o.timeline || {};\n\t    this._addCallbackOverrides(this._o.timeline);\n\t    _Thenable.prototype._makeTimeline.call(this);\n\t    this.timeline.add(this.deltas);\n\t  };\n\t  /*\n\t    Method to add callback overrides to passed object object.\n\t    @param {Object} Object to add overrides on.\n\t  */\n\n\n\t  Html.prototype._addCallbackOverrides = function _addCallbackOverrides(o) {\n\t    var it = this;\n\t    var p = this._props;\n\t    o.callbackOverrides = {\n\t      onUpdate: this._draw,\n\t      onRefresh: this._props.isRefreshState ? this._draw : void 0,\n\t      onStart: function onStart(isFwd) {\n\t        // don't touch main `el` onStart in chained elements\n\t        if (it._isChained) {\n\t          return;\n\t        };\n\t        // show if was hidden at start\n\t        if (isFwd && !p.isShowStart) {\n\t          it._show();\n\t        }\n\t        // hide if should be hidden at start\n\t        else {\n\t            if (!p.isShowStart) {\n\t              it._hide();\n\t            }\n\t          }\n\t      },\n\t      onComplete: function onComplete(isFwd) {\n\t        // don't touch main `el` if not the last in `then` chain\n\t        if (it._isChained) {\n\t          return;\n\t        }\n\t        if (isFwd) {\n\t          if (!p.isShowEnd) {\n\t            it._hide();\n\t          }\n\t        } else if (!p.isShowEnd) {\n\t          it._show();\n\t        }\n\t      }\n\t    };\n\t  };\n\n\t  /*\n\t    Method that gets called on `soft` show of the module,\n\t    it should restore transform styles of the module.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Html.prototype._showByTransform = function _showByTransform() {\n\t    this._drawTransform();\n\t  };\n\n\t  /*\n\t    Method to merge `start` and `end` for a property in then record.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Start value of the property.\n\t    @param {Any}    End value of the property.\n\t  */\n\t  // !! COVER !!\n\n\n\t  Html.prototype._mergeThenProperty = function _mergeThenProperty(key, startValue, endValue) {\n\t    // if isnt tween property\n\t    var isBoolean = typeof endValue === 'boolean',\n\t        curve,\n\t        easing;\n\n\t    if (!h.isTweenProp(key) && !this._nonMergeProps[key] && !isBoolean) {\n\n\t      var TWEEN_PROPS = {};\n\t      if (h.isObject(endValue) && endValue.to != null) {\n\t        for (var _key in endValue) {\n\t          if (TWEEN_PROPERTIES[_key] || _key === 'curve') {\n\t            TWEEN_PROPS[_key] = endValue[_key];\n\t            delete endValue[_key];\n\t          }\n\t        }\n\t        // curve    = endValue.curve;\n\t        // easing   = endValue.easing;\n\t        endValue = endValue.to;\n\t      }\n\n\t      // if end value is delta - just save it\n\t      if (this._isDelta(endValue)) {\n\n\t        var _TWEEN_PROPS = {};\n\t        for (var _key2 in endValue) {\n\t          if (TWEEN_PROPERTIES[_key2] || _key2 === 'curve') {\n\t            _TWEEN_PROPS[_key2] = endValue[_key2];\n\t            delete endValue[_key2];\n\t          }\n\t        }\n\t        var result = this._parseDeltaValues(key, endValue);\n\n\t        return (0, _extends5.default)({}, result, _TWEEN_PROPS);\n\t      } else {\n\t        var parsedEndValue = this._parsePreArrayProperty(key, endValue);\n\t        // if end value is not delta - merge with start value\n\t        if (this._isDelta(startValue)) {\n\t          var _extends2;\n\n\t          // if start value is delta - take the end value\n\t          // as start value of the new delta\n\t          return (0, _extends5.default)((_extends2 = {}, _extends2[h.getDeltaEnd(startValue)] = parsedEndValue, _extends2), TWEEN_PROPS);\n\t          // if both start and end value are not ∆ - make ∆\n\t        } else {\n\t          var _extends3;\n\n\t          return (0, _extends5.default)((_extends3 = {}, _extends3[startValue] = parsedEndValue, _extends3), TWEEN_PROPS);\n\t        }\n\t      }\n\t      // copy the tween values unattended\n\t    } else {\n\t      return endValue;\n\t    }\n\t  };\n\n\t  return Html;\n\t}(_thenable2.default);\n\n\texports.default = Html;\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _assign = __webpack_require__(121);\n\n\tvar _assign2 = _interopRequireDefault(_assign);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _assign2.default || function (target) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    var source = arguments[i];\n\n\t    for (var key in source) {\n\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t        target[key] = source[key];\n\t      }\n\t    }\n\t  }\n\n\t  return target;\n\t};\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(122), __esModule: true };\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(123);\n\tmodule.exports = __webpack_require__(14).Object.assign;\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(12);\n\n\t$export($export.S + $export.F, 'Object', {assign: __webpack_require__(124)});\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar getKeys  = __webpack_require__(33)\n\t  , gOPS     = __webpack_require__(62)\n\t  , pIE      = __webpack_require__(63)\n\t  , toObject = __webpack_require__(49)\n\t  , IObject  = __webpack_require__(36)\n\t  , $assign  = Object.assign;\n\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = !$assign || __webpack_require__(23)(function(){\n\t  var A = {}\n\t    , B = {}\n\t    , S = Symbol()\n\t    , K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function(k){ B[k] = k; });\n\t  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n\t}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n\t  var T     = toObject(target)\n\t    , aLen  = arguments.length\n\t    , index = 1\n\t    , getSymbols = gOPS.f\n\t    , isEnum     = pIE.f;\n\t  while(aLen > index){\n\t    var S      = IObject(arguments[index++])\n\t      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n\t      , length = keys.length\n\t      , j      = 0\n\t      , key;\n\t    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n\t  } return T;\n\t} : $assign;\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _extends2 = __webpack_require__(120);\n\n\tvar _extends3 = _interopRequireDefault(_extends2);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _delta = __webpack_require__(126);\n\n\tvar _delta2 = _interopRequireDefault(_delta);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  This module's target is to parse options object,\n\t  find deltas in it and send them to `Delta` classes.\n\t  The `Delta` class is dull - they expect actual parsed deltas\n\t  and separated tween options, so we should parse them here.\n\t  The timeline of the module controls the `Delta` modules' tweens.\n\n\t  @param {Object} props Object to set deltas result to (pass to the Delta classes).\n\t  @param {Object} options Object to parse the deltas from.\n\t  @param {Function} onUpdate onUpdate callback.\n\t  @param optional {Object} arrayPropertyMap List of properties with truthy\n\t                                            values which describe properties\n\t                                            that should be parsed as arrays.\n\t  @param optional {Object} numberPropertyMap List of properties with truthy\n\t                                            values which describe properties\n\t                                            that should be parsed as numbers\n\t                                            without units.\n\t*/\n\n\t// TODO:\n\t// - colors with curves change alpha level too\n\t// const html = new mojs.Html({\n\t//   el: '#js-el',\n\t//   x: { 0: 100 },\n\t//   onUpdate () {\n\t//     console.log(this._props.originX);\n\t//   },\n\t//   originX: { 'white': 'black', curve: 'M0,100 L100, 0' },\n\t//   customProperties: {\n\t//     originX: {\n\t//       type: 'color',\n\t//       default: 'cyan'\n\t//     },\n\t//     draw() { console.log('draw'); }\n\t//   }\n\t// });\n\n\n\tvar easing = __webpack_require__(105);\n\tvar h = __webpack_require__(71);\n\n\n\t// get tween properties\n\tvar obj = {};\n\t_tween2.default.prototype._declareDefaults.call(obj);\n\tvar keys = (0, _keys2.default)(obj._defaults);\n\tfor (var i = 0; i < keys.length; i++) {\n\t  obj._defaults[keys[i]] = 1;\n\t}\n\tobj._defaults['timeline'] = 1;\n\tvar TWEEN_PROPERTIES = obj._defaults;\n\n\tvar Deltas = function () {\n\t  function Deltas() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Deltas);\n\n\t    this._o = o;\n\n\t    this._shortColors = {\n\t      transparent: 'rgba(0,0,0,0)',\n\t      none: 'rgba(0,0,0,0)',\n\t      aqua: 'rgb(0,255,255)',\n\t      black: 'rgb(0,0,0)',\n\t      blue: 'rgb(0,0,255)',\n\t      fuchsia: 'rgb(255,0,255)',\n\t      gray: 'rgb(128,128,128)',\n\t      green: 'rgb(0,128,0)',\n\t      lime: 'rgb(0,255,0)',\n\t      maroon: 'rgb(128,0,0)',\n\t      navy: 'rgb(0,0,128)',\n\t      olive: 'rgb(128,128,0)',\n\t      purple: 'rgb(128,0,128)',\n\t      red: 'rgb(255,0,0)',\n\t      silver: 'rgb(192,192,192)',\n\t      teal: 'rgb(0,128,128)',\n\t      white: 'rgb(255,255,255)',\n\t      yellow: 'rgb(255,255,0)',\n\t      orange: 'rgb(255,128,0)'\n\t    };\n\n\t    this._ignoreDeltasMap = { prevChainModule: 1, masterModule: 1 };\n\n\t    this._parseDeltas(o.options);\n\t    this._createDeltas();\n\t    this._createTimeline(this._mainTweenOptions);\n\t  }\n\t  /*\n\t    Method to call `refresh` on all child `delta` objects.\n\t    @public\n\t    @param {Boolean} If before start time (true) or after end time (false).\n\t  */\n\n\n\t  Deltas.prototype.refresh = function refresh(isBefore) {\n\t    for (var i = 0; i < this._deltas.length; i++) {\n\t      this._deltas[i].refresh(isBefore);\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to call `restore` on all child `delta` objects.\n\t    @public\n\t  */\n\n\n\t  Deltas.prototype.restore = function restore() {\n\t    for (var i = 0; i < this._deltas.length; i++) {\n\t      this._deltas[i].restore();\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to create Timeline.\n\t    @private\n\t    @param {Object} Timeline options.\n\t  */\n\n\n\t  Deltas.prototype._createTimeline = function _createTimeline() {\n\t    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t    // const o = this._o;\n\t    // opts.timeline = opts.timeline || {};\n\t    // opts.timeline.callbackOverrides = {\n\t    //   onUpdate:   o.onUpdate,\n\t    //   onRefresh:  o.onUpdate\n\t    // }\n\t    // send callbacksContext to timeline if set\n\t    // o.callbacksContext && (opts.timeline.callbacksContext = o.callbacksContext);\n\t    // opts.timeline\n\t    this.timeline = new _timeline2.default();\n\t    this.timeline.add(this._deltas);\n\t  };\n\t  /*\n\t    Method to create Deltas from parsed options.\n\t    @private\n\t  */\n\n\n\t  Deltas.prototype._createDeltas = function _createDeltas() {\n\t    this._deltas = [];\n\n\t    // create main delta object\n\t    this._deltas.push(this._createDelta(this._mainDeltas, this._mainTweenOptions));\n\n\t    // create child delta object\n\t    for (var i = 0; i < this._childDeltas.length; i++) {\n\t      var delta = this._childDeltas[i];\n\t      this._deltas.push(this._createDelta([delta.delta], delta.tweenOptions));\n\t    }\n\t  };\n\t  /*\n\t    Method to create Delta object with passed options.\n\t    @private\n\t    @param {Array} Array of deltas.\n\t    @param {Object} Tween properties.\n\t    @returns {Object} Delta object\n\t  */\n\n\n\t  Deltas.prototype._createDelta = function _createDelta(deltas, tweenOptions) {\n\t    var o = this._o;\n\t    return new _delta2.default({\n\t      deltas: deltas, tweenOptions: tweenOptions,\n\t      props: o.props,\n\t      isChained: o.isChained,\n\t      callbacksContext: o.callbacksContext\n\t    });\n\t  };\n\t  /*\n\t    Method to parse delta objects from options.\n\t    @private\n\t    @param {Object} Options object to parse the deltas from.\n\t  */\n\n\n\t  Deltas.prototype._parseDeltas = function _parseDeltas(obj) {\n\t    // spilt main animation properties and main tween properties\n\t    var mainSplit = this._splitTweenOptions(obj);\n\t    // main animation properties\n\t    var opts = mainSplit.delta;\n\t    // main tween properties\n\t    this._mainTweenOptions = mainSplit.tweenOptions;\n\n\t    this._mainDeltas = [];\n\t    this._childDeltas = [];\n\t    var keys = (0, _keys2.default)(opts);\n\t    // loop thru all properties without tween ones\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      // is property is delta - parse it\n\t      if (this._isDelta(opts[key]) && !this._ignoreDeltasMap[key]) {\n\t        var delta = this._splitAndParseDelta(key, opts[key]);\n\t        // if parsed object has no tween values - it's delta of the main object\n\t        if (!delta.tweenOptions) {\n\t          this._mainDeltas.push(delta.delta);\n\t        }\n\t        // otherwise it is distinct delta object\n\t        else {\n\t            this._childDeltas.push(delta);\n\t          }\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to split tween values and parse single delta record.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @returns {Object} Split object.\n\t                @param {Object} tweenOptions Tween properties.\n\t                @param {Object} delta Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._splitAndParseDelta = function _splitAndParseDelta(name, object) {\n\t    var split = this._splitTweenOptions(object);\n\t    // parse delta in the object\n\t    split.delta = this._parseDelta(name, split.delta);\n\t    return split;\n\t  };\n\t  /*\n\t    Method to parse delta by delegating the variables to _parse*Delta methods.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @param {Number} Module index.\n\t  */\n\n\n\t  Deltas.prototype._parseDelta = function _parseDelta(name, object, index) {\n\t    // if name is in _o.customProps - parse it regarding the type\n\t    return this._o.customProps && this._o.customProps[name] != null ? this._parseDeltaByCustom(name, object, index) : this._parseDeltaByGuess(name, object, index);\n\t  };\n\t  /**\n\t    Method to parse delta by taking the type from the customProps object.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @param {Number} Module index.\n\t  */\n\n\n\t  Deltas.prototype._parseDeltaByCustom = function _parseDeltaByCustom(name, object, index) {\n\t    return this._parseNumberDelta(name, object, index);\n\t    // const customRecord = this._o.customProps[name];\n\t    // switch ( customRecord.type.toLowerCase() ) {\n\t    //   case 'color':  { return this._parseColorDelta( name, object ); }\n\t    //   case 'array':  { return this._parseArrayDelta( name, object ); }\n\t    //   case 'number': { return this._parseNumberDelta( name, object, index ); }\n\t    //   case 'unit':   { return this._parseUnitDelta( name, object, index ); }\n\t    // }\n\t  };\n\t  /**\n\t    Method to parse delta by reasoning about it's value.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @param {Number} Module index.\n\t  */\n\n\n\t  Deltas.prototype._parseDeltaByGuess = function _parseDeltaByGuess(name, object, index) {\n\t    var _preparseDelta2 = this._preparseDelta(object),\n\t        start = _preparseDelta2.start;\n\n\t    var o = this._o;\n\n\t    // color values\n\t    if (isNaN(parseFloat(start)) && !start.match(/rand\\(/) && !start.match(/stagger\\(/)) {\n\t      return this._parseColorDelta(name, object);\n\t      // array values\n\t    } else if (o.arrayPropertyMap && o.arrayPropertyMap[name]) {\n\t      return this._parseArrayDelta(name, object);\n\t      // unit or number values\n\t    } else {\n\t      return o.numberPropertyMap && o.numberPropertyMap[name] ?\n\t      // if the property is in the number property map - parse it like number\n\t      this._parseNumberDelta(name, object, index)\n\t      // otherwise - like number with units\n\t      : this._parseUnitDelta(name, object, index);\n\t    }\n\t  };\n\t  /*\n\t    Method to separate tween options from delta properties.\n\t    @param {Object} Object for separation.\n\t    @returns {Object} Object that contains 2 objects\n\t                        - one delta options\n\t                        - one tween options ( could be empty if no tween opts )\n\t  */\n\n\n\t  Deltas.prototype._splitTweenOptions = function _splitTweenOptions(delta) {\n\t    delta = (0, _extends3.default)({}, delta);\n\n\t    var keys = (0, _keys2.default)(delta),\n\t        tweenOptions = {};\n\t    var isTween = null;\n\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      if (TWEEN_PROPERTIES[key]) {\n\t        if (delta[key] != null) {\n\t          tweenOptions[key] = delta[key];\n\t          isTween = true;\n\t        }\n\t        delete delta[key];\n\t      }\n\t    }\n\t    return {\n\t      delta: delta,\n\t      tweenOptions: isTween ? tweenOptions : undefined\n\t    };\n\t  };\n\t  /*\n\t    Method to check if the property is delta property.\n\t    @private\n\t    @param {Any} Parameter value to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Deltas.prototype._isDelta = function _isDelta(optionsValue) {\n\t    var isObject = h.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || h.isArray(optionsValue) || h.isDOM(optionsValue));\n\t  };\n\t  /*\n\t    Method to parse color delta values.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseColorDelta = function _parseColorDelta(key, value) {\n\t    if (key === 'strokeLinecap') {\n\t      h.warn('Sorry, stroke-linecap property is not animatable yet, using the start(#{start}) value instead', value);\n\t      return {};\n\t    }\n\t    var preParse = this._preparseDelta(value);\n\n\t    var startColorObj = this._makeColorObj(preParse.start),\n\t        endColorObj = this._makeColorObj(preParse.end);\n\n\t    var delta = {\n\t      type: 'color',\n\t      name: key,\n\t      start: startColorObj,\n\t      end: endColorObj,\n\t      curve: preParse.curve,\n\t      delta: {\n\t        r: endColorObj.r - startColorObj.r,\n\t        g: endColorObj.g - startColorObj.g,\n\t        b: endColorObj.b - startColorObj.b,\n\t        a: endColorObj.a - startColorObj.a\n\t      }\n\t    };\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to parse array delta values.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseArrayDelta = function _parseArrayDelta(key, value) {\n\t    var preParse = this._preparseDelta(value);\n\n\t    var startArr = this._strToArr(preParse.start),\n\t        endArr = this._strToArr(preParse.end);\n\n\t    h.normDashArrays(startArr, endArr);\n\n\t    for (var i = 0; i < startArr.length; i++) {\n\t      var end = endArr[i];\n\t      h.mergeUnits(startArr[i], end, key);\n\t    }\n\n\t    var delta = {\n\t      type: 'array',\n\t      name: key,\n\t      start: startArr,\n\t      end: endArr,\n\t      delta: h.calcArrDelta(startArr, endArr),\n\t      curve: preParse.curve\n\t    };\n\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to parse numeric delta values with units.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @param {Number} Index of the module.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseUnitDelta = function _parseUnitDelta(key, value, index) {\n\t    var preParse = this._preparseDelta(value);\n\n\t    var end = h.parseUnit(h.parseStringOption(preParse.end, index)),\n\t        start = h.parseUnit(h.parseStringOption(preParse.start, index));\n\n\t    h.mergeUnits(start, end, key);\n\t    var delta = {\n\t      type: 'unit',\n\t      name: key,\n\t      start: start,\n\t      end: end,\n\t      delta: end.value - start.value,\n\t      curve: preParse.curve\n\t    };\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to parse numeric delta values without units.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @param {Number} Index of the module.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseNumberDelta = function _parseNumberDelta(key, value, index) {\n\t    var preParse = this._preparseDelta(value);\n\n\t    var end = parseFloat(h.parseStringOption(preParse.end, index)),\n\t        start = parseFloat(h.parseStringOption(preParse.start, index));\n\n\t    var delta = {\n\t      type: 'number',\n\t      name: key,\n\t      start: start,\n\t      end: end,\n\t      delta: end - start,\n\t      curve: preParse.curve\n\t    };\n\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to extract `curve` and `start`/`end` values.\n\t    @private\n\t    @param {Object} Delta object.\n\t    @returns {Object} Preparsed delta.\n\t              @property {String} Start value.\n\t              @property {String, Number} End value.\n\t  */\n\n\n\t  Deltas.prototype._preparseDelta = function _preparseDelta(value) {\n\t    // clone value object\n\t    value = (0, _extends3.default)({}, value);\n\t    // parse curve if exist\n\t    var curve = value.curve;\n\t    if (curve != null) {\n\t      curve = easing.parseEasing(curve);\n\t      curve._parent = this;\n\t    }\n\t    delete value.curve;\n\t    // parse start and end values\n\t    var start = (0, _keys2.default)(value)[0],\n\t        end = value[start];\n\n\t    return { start: start, end: end, curve: curve };\n\t  };\n\t  /*\n\t    Method to parse color into usable object.\n\t    @private\n\t    @param {String} Color string.\n\t    @returns {Object} Parsed color value.\n\t  */\n\n\n\t  Deltas.prototype._makeColorObj = function _makeColorObj(color) {\n\t    // HEX\n\t    var colorObj = {};\n\t    if (color[0] === '#') {\n\t      var result = /^#?([a-f\\d]{1,2})([a-f\\d]{1,2})([a-f\\d]{1,2})$/i.exec(color);\n\t      if (result) {\n\t        var r = result[1].length === 2 ? result[1] : result[1] + result[1],\n\t            g = result[2].length === 2 ? result[2] : result[2] + result[2],\n\t            b = result[3].length === 2 ? result[3] : result[3] + result[3];\n\n\t        colorObj = {\n\t          r: parseInt(r, 16), g: parseInt(g, 16), b: parseInt(b, 16), a: 1\n\t        };\n\t      }\n\t    }\n\n\t    // not HEX\n\t    // shorthand color and rgb()\n\t    if (color[0] !== '#') {\n\t      var isRgb = color[0] === 'r' && color[1] === 'g' && color[2] === 'b';\n\t      var rgbColor = void 0;\n\t      // rgb color\n\t      if (isRgb) {\n\t        rgbColor = color;\n\t      };\n\t      // shorthand color name\n\t      if (!isRgb) {\n\t        if (!this._shortColors[color]) {\n\t          h.div.style.color = color;\n\t          rgbColor = h.computedStyle(h.div).color;\n\t        } else {\n\t          rgbColor = this._shortColors[color];\n\t        }\n\t      }\n\n\t      var regexString1 = '^rgba?\\\\((\\\\d{1,3}),\\\\s?(\\\\d{1,3}),',\n\t          regexString2 = '\\\\s?(\\\\d{1,3}),?\\\\s?(\\\\d{1}|0?\\\\.\\\\d{1,})?\\\\)$',\n\t          _result = new RegExp(regexString1 + regexString2, 'gi').exec(rgbColor),\n\t          alpha = parseFloat(_result[4] || 1);\n\n\t      if (_result) {\n\t        colorObj = {\n\t          r: parseInt(_result[1], 10),\n\t          g: parseInt(_result[2], 10),\n\t          b: parseInt(_result[3], 10),\n\t          a: alpha != null && !isNaN(alpha) ? alpha : 1\n\t        };\n\t      }\n\t    }\n\n\t    return colorObj;\n\t  };\n\t  /*\n\t    Method to parse string into array.\n\t    @private\n\t    @param {String, Number} String or number to parse.\n\t    @returns {Array} Parsed array.\n\t  */\n\n\n\t  Deltas.prototype._strToArr = function _strToArr(string) {\n\t    var arr = [];\n\t    // plain number\n\t    if (typeof string === 'number' && !isNaN(string)) {\n\t      arr.push(h.parseUnit(string));\n\t      return arr;\n\t    }\n\t    // string array\n\t    string.trim().split(/\\s+/gim).forEach(function (str) {\n\t      arr.push(h.parseUnit(h.parseIfRand(str)));\n\t    });\n\t    return arr;\n\t  };\n\n\t  return Deltas;\n\t}();\n\n\texports.default = Deltas;\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar h = __webpack_require__(71);\n\n\tvar Delta = function () {\n\t  function Delta() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Delta);\n\n\t    this._o = o;\n\t    this._createTween(o.tweenOptions);\n\t    // initial properties render\n\t    !this._o.isChained && this.refresh(true);\n\t  }\n\t  /*\n\t    Method to call `_refresh` method on `tween`.\n\t    Use switch between `0` and `1` progress for delta value.\n\t    @public\n\t    @param {Boolean} If refresh before start time or after.\n\t    @returns this.\n\t  */\n\n\n\t  Delta.prototype.refresh = function refresh(isBefore) {\n\t    this._previousValues = [];\n\n\t    var deltas = this._o.deltas;\n\t    for (var i = 0; i < deltas.length; i++) {\n\t      var name = deltas[i].name;\n\t      this._previousValues.push({\n\t        name: name, value: this._o.props[name]\n\t      });\n\t    }\n\n\t    this.tween._refresh(isBefore);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to restore all saved properties from `_previousValues` array.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Delta.prototype.restore = function restore() {\n\t    var prev = this._previousValues;\n\t    for (var i = 0; i < prev.length; i++) {\n\t      var record = prev[i];\n\t      this._o.props[record.name] = record.value;\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to create tween of the delta.\n\t    @private\n\t    @param {Object} Options object.\n\t  */\n\n\n\t  Delta.prototype._createTween = function _createTween() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t    var it = this;\n\t    o.callbackOverrides = {\n\t      onUpdate: function onUpdate(ep, p) {\n\t        it._calcCurrentProps(ep, p);\n\t      }\n\t    };\n\n\t    // if not chained - add the onRefresh callback\n\t    // to refresh the tween when needed\n\t    if (!this._o.isChained) {\n\t      o.callbackOverrides.onRefresh = function (isBefore, ep, p) {\n\t        it._calcCurrentProps(ep, p);\n\t      };\n\t    }\n\n\t    o.callbacksContext = this._o.callbacksContext;\n\t    this.tween = new _tween2.default(o);\n\t  };\n\t  /*\n\t    Method to calculate current progress of the deltas.\n\t    @private\n\t    @param {Number} Eased progress to calculate - [0..1].\n\t    @param {Number} Progress to calculate - [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrentProps = function _calcCurrentProps(easedProgress, p) {\n\t    var deltas = this._o.deltas;\n\t    for (var i = 0; i < deltas.length; i++) {\n\t      var type = deltas[i].type;\n\t      this['_calcCurrent_' + type](deltas[i], easedProgress, p);\n\t    }\n\t  };\n\t  /*\n\t    Method to calc the current color delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_color = function _calcCurrent_color(delta, ep, p) {\n\t    var r,\n\t        g,\n\t        b,\n\t        a,\n\t        start = delta.start,\n\t        d = delta.delta;\n\t    if (!delta.curve) {\n\t      r = parseInt(start.r + ep * d.r, 10);\n\t      g = parseInt(start.g + ep * d.g, 10);\n\t      b = parseInt(start.b + ep * d.b, 10);\n\t      a = parseFloat(start.a + ep * d.a);\n\t    } else {\n\t      var cp = delta.curve(p);\n\t      r = parseInt(cp * (start.r + p * d.r), 10);\n\t      g = parseInt(cp * (start.g + p * d.g), 10);\n\t      b = parseInt(cp * (start.b + p * d.b), 10);\n\t      a = parseFloat(cp * (start.a + p * d.a));\n\t    }\n\t    this._o.props[delta.name] = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t  };\n\t  /*\n\t    Method to calc the current number delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_number = function _calcCurrent_number(delta, ep, p) {\n\t    this._o.props[delta.name] = !delta.curve ? delta.start + ep * delta.delta : delta.curve(p) * (delta.start + p * delta.delta);\n\t  };\n\t  /*\n\t    Method to calc the current number with units delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_unit = function _calcCurrent_unit(delta, ep, p) {\n\t    var currentValue = !delta.curve ? delta.start.value + ep * delta.delta : delta.curve(p) * (delta.start.value + p * delta.delta);\n\n\t    this._o.props[delta.name] = '' + currentValue + delta.end.unit;\n\t  };\n\t  /*\n\t    Method to calc the current array delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_array = function _calcCurrent_array(delta, ep, p) {\n\t    // var arr,\n\t    var name = delta.name,\n\t        props = this._o.props,\n\t        string = '';\n\n\t    // to prevent GC bothering with arrays garbage\n\t    // if ( h.isArray( props[name] ) ) {\n\t    //   arr = props[name];\n\t    //   arr.length = 0;\n\t    // } else { arr = []; }\n\n\t    // just optimization to prevent curve\n\t    // calculations on every array item\n\t    var proc = delta.curve ? delta.curve(p) : null;\n\n\t    for (var i = 0; i < delta.delta.length; i++) {\n\t      var item = delta.delta[i],\n\t          dash = !delta.curve ? delta.start[i].value + ep * item.value : proc * (delta.start[i].value + p * item.value);\n\n\t      string += '' + dash + item.unit + ' ';\n\t      // arr.push({\n\t      //   string: `${dash}${item.unit}`,\n\t      //   value:  dash,\n\t      //   unit:   item.unit,\n\t      // });\n\t    }\n\t    props[name] = string;\n\t  };\n\n\t  return Delta;\n\t}();\n\n\texports.default = Delta;\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _keys = __webpack_require__(95);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(75);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(76);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _tunable = __webpack_require__(116);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Stagger = function (_Tunable) {\n\t  (0, _inherits3.default)(Stagger, _Tunable);\n\n\t  function Stagger(options, Module) {\n\t    var _ret;\n\n\t    (0, _classCallCheck3.default)(this, Stagger);\n\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, _Tunable.call(this));\n\n\t    return _ret = _this._init(options, Module), (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t  /*\r\n\t    Method to create then chain on child modules.\r\n\t    @param {Object} Then options.\r\n\t    @return {Object} this.\r\n\t  */\n\n\n\t  Stagger.prototype.then = function then(o) {\n\t    if (o == null) {\n\t      return this;\n\t    }\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      // get child module's option and pass to the child `then`\n\t      this._modules[i].then(this._getOptionByIndex(i, o));\n\t    }\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to tune child modules.\r\n\t    @param {Object} Tune options.\r\n\t    @return {Object} this.\r\n\t  */\n\n\n\t  Stagger.prototype.tune = function tune(o) {\n\t    if (o == null) {\n\t      return this;\n\t    }\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      // get child module's option and pass to the child `then`\n\t      this._modules[i].tune(this._getOptionByIndex(i, o));\n\t    }\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to generate child modules.\r\n\t    @return {Object} this.\r\n\t  */\n\n\n\t  Stagger.prototype.generate = function generate() {\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      // get child module's option and pass to the child `then`\n\t      this._modules[i].generate();\n\t    }\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to get an option by modulo and name.\r\n\t    @param {String} Name of the property to get.\r\n\t    @param {Number} Index for the modulo calculation.\r\n\t    @param {Object} Options hash to look in.\r\n\t    @return {Any} Property.\r\n\t  */\n\n\n\t  Stagger.prototype._getOptionByMod = function _getOptionByMod(name, i, store) {\n\t    var props = store[name];\n\t    // if not dom list then clone it to array\n\t    if (props + '' === '[object NodeList]' || props + '' === '[object HTMLCollection]') props = Array.prototype.slice.call(props, 0);\n\t    // get the value in array or return the value itself\n\t    var value = _h2.default.isArray(props) ? props[i % props.length] : props;\n\t    // check if value has the stagger expression, if so parse it\n\t    return _h2.default.parseIfStagger(value, i);\n\t  };\n\t  /*\r\n\t    Method to get option by modulo of index.\r\n\t    @param {Number} Index for modulo calculations.\r\n\t    @param {Object} Options hash to look in.\r\n\t  */\n\n\n\t  Stagger.prototype._getOptionByIndex = function _getOptionByIndex(i, store) {\n\t    var _this2 = this;\n\n\t    var options = {};\n\t    (0, _keys2.default)(store).forEach(function (key) {\n\t      return options[key] = _this2._getOptionByMod(key, i, store);\n\t    });\n\t    return options;\n\t  };\n\t  /*\r\n\t    Method to get total child modules quantity.\r\n\t    @param  {String} Name of quantifier in options hash.\r\n\t    @param  {Object} Options hash object.\r\n\t    @return {Number} Number of child object that should be defined.\r\n\t  */\n\n\n\t  Stagger.prototype._getChildQuantity = function _getChildQuantity(name, store) {\n\t    // if number was set\n\t    if (typeof name === 'number') {\n\t      return name;\n\t    }\n\n\t    var quantifier = store[name];\n\t    if (_h2.default.isArray(quantifier)) {\n\t      return quantifier.length;\n\t    } else if (quantifier + '' === '[object NodeList]') {\n\t      return quantifier.length;\n\t    } else if (quantifier + '' === '[object HTMLCollection]') {\n\t      return Array.prototype.slice.call(quantifier, 0).length;\n\t    } else if (quantifier instanceof HTMLElement) {\n\t      return 1;\n\t    } else if (typeof quantifier == 'string') {\n\t      return 1;\n\t    }\n\t  };\n\t  /*\r\n\t    Method to make stagger form options\r\n\t    @param {Object} Options.\r\n\t    @param {Object} Child class.\r\n\t  */\n\n\n\t  Stagger.prototype._init = function _init(options, Module) {\n\t    var count = this._getChildQuantity(options.quantifier || 'el', options);\n\t    this._createTimeline(options);this._modules = [];\n\t    for (var i = 0; i < count; i++) {\n\t      // get child module's option\n\t      var option = this._getOptionByIndex(i, options);\n\t      option.isRunLess = true;\n\t      // set index of the module\n\t      option.index = i;\n\t      // create child module\n\t      var module = new Module(option);this._modules.push(module);\n\t      // add child module's timeline to the self timeline\n\t      this.timeline.add(module);\n\t    }\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to create timeline.\r\n\t    @param {Object} Timeline options.\r\n\t  */\n\n\n\t  Stagger.prototype._createTimeline = function _createTimeline() {\n\t    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t    this.timeline = new _timeline2.default(options.timeline);\n\t  };\n\n\t  /* @overrides @ Tweenable */\n\n\n\t  Stagger.prototype._makeTween = function _makeTween() {};\n\n\t  Stagger.prototype._makeTimeline = function _makeTimeline() {};\n\n\t  return Stagger;\n\t}(_tunable2.default);\n\n\tmodule.exports = function (Module) {\n\t  return function (options) {\n\t    return new Stagger(options, Module);\n\t  };\n\t};\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(74);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _h = __webpack_require__(71);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _tween = __webpack_require__(101);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(110);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\r\n\t  Class for toggling opacity on bunch of elements\r\n\t  @class Spriter\r\n\t  @todo\r\n\t    - add isForce3d option\r\n\t    - add run new option merging\r\n\t    - add then chains\r\n\t*/\n\tvar Spriter = function () {\n\t  /*\r\n\t    Defaults/APIs\r\n\t  */\n\t  Spriter.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      /*\r\n\t        Duration\r\n\t        @property duration\r\n\t        @type     {Number}\r\n\t      */\n\t      duration: 500,\n\t      /*\r\n\t        Delay\r\n\t        @property delay\r\n\t        @type     {Number}\r\n\t      */\n\t      delay: 0,\n\t      /*\r\n\t        Easing. Please see the \r\n\t        [timeline module parseEasing function](timeline.coffee.html#parseEasing)\r\n\t        for all avaliable options.\r\n\t          @property easing\r\n\t        @type     {String, Function}\r\n\t      */\n\t      easing: 'linear.none',\n\t      /*\r\n\t        Repeat times count\r\n\t        \r\n\t        @property repeat\r\n\t        @type     {Number}\r\n\t      */\n\t      repeat: 0,\n\t      /*\r\n\t        Yoyo option defines if animation should be altered on repeat.\r\n\t        \r\n\t        @property yoyo\r\n\t        @type     {Boolean}\r\n\t      */\n\t      yoyo: false,\n\t      /*\r\n\t        isRunLess option prevents animation from running immediately after\r\n\t        initialization.\r\n\t        \r\n\t        @property isRunLess\r\n\t        @type     {Boolean}\r\n\t      */\n\t      isRunLess: false,\n\t      /*\r\n\t        isShowEnd option defines if the last frame should be shown when\r\n\t        animation completed.\r\n\t        \r\n\t        @property isShowEnd\r\n\t        @type     {Boolean}\r\n\t      */\n\t      isShowEnd: false,\n\t      /*\r\n\t        onStart callback will be called once on animation start.\r\n\t        \r\n\t        @property onStart\r\n\t        @type     {Function}\r\n\t      */\n\t      onStart: null,\n\t      /*\r\n\t        onUpdate callback will be called on every frame of the animation.\r\n\t        The current progress in range **[0,1]** will be passed to the callback.\r\n\t        \r\n\t        @property onUpdate\r\n\t        @type     {Function}\r\n\t      */\n\t      onUpdate: null,\n\t      /*\r\n\t        onComplete callback will be called once on animation complete.\r\n\t        \r\n\t        @property onComplete\r\n\t        @type     {Function}\r\n\t      */\n\t      onComplete: null\n\t    };\n\t  };\n\n\t  function Spriter() {\n\t    var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t    (0, _classCallCheck3.default)(this, Spriter);\n\n\t    this.o = o;\n\t    if (!this.o.el) {\n\t      return _h2.default.error('No \"el\" option specified, aborting');\n\t    }\n\t    this._vars();this._declareDefaults();this._extendDefaults();this._parseFrames();\n\t    if (this._frames.length <= 2) _h2.default.warn('Spriter: only ' + this._frames.length + ' frames found');\n\t    if (this._frames.length < 1) _h2.default.error(\"Spriter: there is no frames to animate, aborting\");\n\t    this._createTween();\n\t    return this;\n\t  }\n\t  /*\r\n\t    Method to declare some variables.\r\n\t    \r\n\t    @method run\r\n\t    @param  {Object} New options\r\n\t    @todo   Implement new object merging\r\n\t  */\n\n\n\t  Spriter.prototype._vars = function _vars() {\n\t    this._props = _h2.default.cloneObj(this.o);\n\t    this.el = this.o.el;\n\t    this._frames = [];\n\t  };\n\t  /*\r\n\t    Method to run the spriter on demand.\r\n\t    \r\n\t    @method run\r\n\t    @param  {Object} New options\r\n\t    @todo   Implement new object merging\r\n\t  */\n\n\n\t  Spriter.prototype.run = function run(o) {\n\t    return this.timeline.play();\n\t  };\n\t  /*\r\n\t    Method to extend _props by options(this.o)\r\n\t    \r\n\t    @method _extendDefaults\r\n\t  */\n\n\n\t  Spriter.prototype._extendDefaults = function _extendDefaults() {\n\t    return _h2.default.extend(this._props, this._defaults);\n\t  };\n\t  /*\r\n\t    Method to parse frames as child nodes of el.\r\n\t    \r\n\t    @method _parseFrames\r\n\t  */\n\n\n\t  Spriter.prototype._parseFrames = function _parseFrames() {\n\t    this._frames = Array.prototype.slice.call(this.el.children, 0);\n\t    this._frames.forEach(function (frame, i) {\n\t      return frame.style.opacity = 0;\n\t    });\n\t    this._frameStep = 1 / this._frames.length;\n\t  };\n\n\t  /*\r\n\t    Method to create tween and timeline and supply callbacks.\r\n\t    \r\n\t    @method _createTween\r\n\t  */\n\n\n\t  Spriter.prototype._createTween = function _createTween() {\n\t    var _this = this;\n\n\t    this._tween = new _tween2.default({\n\t      duration: this._props.duration,\n\t      delay: this._props.delay,\n\t      yoyo: this._props.yoyo,\n\t      repeat: this._props.repeat,\n\t      easing: this._props.easing,\n\t      onStart: function onStart() {\n\t        return _this._props.onStart && _this._props.onStart();\n\t      },\n\t      onComplete: function onComplete() {\n\t        return _this._props.onComplete && _this._props.onComplete();\n\t      },\n\t      onUpdate: function onUpdate(p) {\n\t        return _this._setProgress(p);\n\t      }\n\t    });\n\t    this.timeline = new _timeline2.default();this.timeline.add(this._tween);\n\t    if (!this._props.isRunLess) this._startTween();\n\t  };\n\n\t  /*\r\n\t    Method to start tween\r\n\t    \r\n\t    @method _startTween\r\n\t  */\n\n\n\t  Spriter.prototype._startTween = function _startTween() {\n\t    var _this2 = this;\n\n\t    setTimeout(function () {\n\t      return _this2.timeline.play();\n\t    }, 1);\n\t  };\n\t  /*\r\n\t    Method to set progress of the sprite\r\n\t    \r\n\t    @method _setProgress\r\n\t    @param  {Number} Progress in range **[0,1]**\r\n\t  */\n\n\n\t  Spriter.prototype._setProgress = function _setProgress(p) {\n\t    // get the frame number\n\t    var proc = Math.floor(p / this._frameStep);\n\t    // react only if frame changes\n\t    if (this._prevFrame != this._frames[proc]) {\n\t      // if previous frame isnt current one, hide it\n\t      if (this._prevFrame) {\n\t        this._prevFrame.style.opacity = 0;\n\t      }\n\t      // if end of animation and isShowEnd flag was specified\n\t      // then show the last frame else show current frame\n\t      var currentNum = p === 1 && this._props.isShowEnd ? proc - 1 : proc;\n\t      // show the current frame\n\t      if (this._frames[currentNum]) {\n\t        this._frames[currentNum].style.opacity = 1;\n\t      }\n\t      // set previous frame as current\n\t      this._prevFrame = this._frames[proc];\n\t    }\n\t    if (this._props.onUpdate) {\n\t      this._props.onUpdate(p);\n\t    }\n\t  };\n\n\t  return Spriter;\n\t}();\n\n\texports.default = Spriter;\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar MotionPath, Timeline, Tween, h, resize,\n\t  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n\th = __webpack_require__(71);\n\n\tresize = __webpack_require__(130);\n\n\tTween = __webpack_require__(101)[\"default\"];\n\n\tTimeline = __webpack_require__(110)[\"default\"];\n\n\tMotionPath = (function() {\n\t  MotionPath.prototype.defaults = {\n\t    path: null,\n\t    curvature: {\n\t      x: '75%',\n\t      y: '50%'\n\t    },\n\t    isCompositeLayer: true,\n\t    delay: 0,\n\t    duration: 1000,\n\t    easing: null,\n\t    repeat: 0,\n\t    yoyo: false,\n\t    onStart: null,\n\t    onComplete: null,\n\t    onUpdate: null,\n\t    offsetX: 0,\n\t    offsetY: 0,\n\t    angleOffset: null,\n\t    pathStart: 0,\n\t    pathEnd: 1,\n\t    motionBlur: 0,\n\t    transformOrigin: null,\n\t    isAngle: false,\n\t    isReverse: false,\n\t    isRunLess: false,\n\t    isPresetPosition: true\n\t  };\n\n\t  function MotionPath(o1) {\n\t    this.o = o1 != null ? o1 : {};\n\t    this.calcHeight = bind(this.calcHeight, this);\n\t    if (this.vars()) {\n\t      return;\n\t    }\n\t    this.createTween();\n\t    this;\n\t  }\n\n\t  MotionPath.prototype.vars = function() {\n\t    this.getScaler = h.bind(this.getScaler, this);\n\t    this.resize = resize;\n\t    this.props = h.cloneObj(this.defaults);\n\t    this.extendOptions(this.o);\n\t    this.isMotionBlurReset = h.isSafari || h.isIE;\n\t    this.isMotionBlurReset && (this.props.motionBlur = 0);\n\t    this.history = [h.cloneObj(this.props)];\n\t    return this.postVars();\n\t  };\n\n\t  MotionPath.prototype.curveToPath = function(o) {\n\t    var angle, curvature, curvatureX, curvatureY, curvePoint, curveXPoint, dX, dY, endPoint, path, percent, radius, start;\n\t    path = document.createElementNS(h.NS, 'path');\n\t    start = o.start;\n\t    endPoint = {\n\t      x: start.x + o.shift.x,\n\t      y: start.x + o.shift.y\n\t    };\n\t    curvature = o.curvature;\n\t    dX = o.shift.x;\n\t    dY = o.shift.y;\n\t    radius = Math.sqrt(dX * dX + dY * dY);\n\t    percent = radius / 100;\n\t    angle = Math.atan(dY / dX) * (180 / Math.PI) + 90;\n\t    if (o.shift.x < 0) {\n\t      angle = angle + 180;\n\t    }\n\t    curvatureX = h.parseUnit(curvature.x);\n\t    curvatureX = curvatureX.unit === '%' ? curvatureX.value * percent : curvatureX.value;\n\t    curveXPoint = h.getRadialPoint({\n\t      center: {\n\t        x: start.x,\n\t        y: start.y\n\t      },\n\t      radius: curvatureX,\n\t      angle: angle\n\t    });\n\t    curvatureY = h.parseUnit(curvature.y);\n\t    curvatureY = curvatureY.unit === '%' ? curvatureY.value * percent : curvatureY.value;\n\t    curvePoint = h.getRadialPoint({\n\t      center: {\n\t        x: curveXPoint.x,\n\t        y: curveXPoint.y\n\t      },\n\t      radius: curvatureY,\n\t      angle: angle + 90\n\t    });\n\t    path.setAttribute('d', \"M\" + start.x + \",\" + start.y + \" Q\" + curvePoint.x + \",\" + curvePoint.y + \" \" + endPoint.x + \",\" + endPoint.y);\n\t    return path;\n\t  };\n\n\t  MotionPath.prototype.postVars = function() {\n\t    this.props.pathStart = h.clamp(this.props.pathStart, 0, 1);\n\t    this.props.pathEnd = h.clamp(this.props.pathEnd, this.props.pathStart, 1);\n\t    this.angle = 0;\n\t    this.speedX = 0;\n\t    this.speedY = 0;\n\t    this.blurX = 0;\n\t    this.blurY = 0;\n\t    this.prevCoords = {};\n\t    this.blurAmount = 20;\n\t    this.props.motionBlur = h.clamp(this.props.motionBlur, 0, 1);\n\t    this.onUpdate = this.props.onUpdate;\n\t    if (!this.o.el) {\n\t      h.error('Missed \"el\" option. It could be a selector, DOMNode or another module.');\n\t      return true;\n\t    }\n\t    this.el = this.parseEl(this.props.el);\n\t    this.props.motionBlur > 0 && this.createFilter();\n\t    this.path = this.getPath();\n\t    if (!this.path.getAttribute('d')) {\n\t      h.error('Path has no coordinates to work with, aborting');\n\t      return true;\n\t    }\n\t    this.len = this.path.getTotalLength();\n\t    this.slicedLen = this.len * (this.props.pathEnd - this.props.pathStart);\n\t    this.startLen = this.props.pathStart * this.len;\n\t    this.fill = this.props.fill;\n\t    if (this.fill != null) {\n\t      this.container = this.parseEl(this.props.fill.container);\n\t      this.fillRule = this.props.fill.fillRule || 'all';\n\t      this.getScaler();\n\t      if (this.container != null) {\n\t        this.removeEvent(this.container, 'onresize', this.getScaler);\n\t        return this.addEvent(this.container, 'onresize', this.getScaler);\n\t      }\n\t    }\n\t  };\n\n\t  MotionPath.prototype.addEvent = function(el, type, handler) {\n\t    return el.addEventListener(type, handler, false);\n\t  };\n\n\t  MotionPath.prototype.removeEvent = function(el, type, handler) {\n\t    return el.removeEventListener(type, handler, false);\n\t  };\n\n\t  MotionPath.prototype.createFilter = function() {\n\t    var div, svg;\n\t    div = document.createElement('div');\n\t    this.filterID = \"filter-\" + (h.getUniqID());\n\t    div.innerHTML = \"<svg id=\\\"svg-\" + this.filterID + \"\\\"\\n    style=\\\"visibility:hidden; width:0px; height:0px\\\">\\n  <filter id=\\\"\" + this.filterID + \"\\\" y=\\\"-20\\\" x=\\\"-20\\\" width=\\\"40\\\" height=\\\"40\\\">\\n    <feOffset\\n      id=\\\"blur-offset\\\" in=\\\"SourceGraphic\\\"\\n      dx=\\\"0\\\" dy=\\\"0\\\" result=\\\"offset2\\\"></feOffset>\\n    <feGaussianblur\\n      id=\\\"blur\\\" in=\\\"offset2\\\"\\n      stdDeviation=\\\"0,0\\\" result=\\\"blur2\\\"></feGaussianblur>\\n    <feMerge>\\n      <feMergeNode in=\\\"SourceGraphic\\\"></feMergeNode>\\n      <feMergeNode in=\\\"blur2\\\"></feMergeNode>\\n    </feMerge>\\n  </filter>\\n</svg>\";\n\t    svg = div.querySelector(\"#svg-\" + this.filterID);\n\t    this.filter = svg.querySelector('#blur');\n\t    this.filterOffset = svg.querySelector('#blur-offset');\n\t    document.body.insertBefore(svg, document.body.firstChild);\n\t    this.el.style['filter'] = \"url(#\" + this.filterID + \")\";\n\t    return this.el.style[h.prefix.css + \"filter\"] = \"url(#\" + this.filterID + \")\";\n\t  };\n\n\t  MotionPath.prototype.parseEl = function(el) {\n\t    if (typeof el === 'string') {\n\t      return document.querySelector(el);\n\t    }\n\t    if (el instanceof HTMLElement) {\n\t      return el;\n\t    }\n\t    if (el._setProp != null) {\n\t      this.isModule = true;\n\t      return el;\n\t    }\n\t  };\n\n\t  MotionPath.prototype.getPath = function() {\n\t    var path;\n\t    path = h.parsePath(this.props.path);\n\t    if (path) {\n\t      return path;\n\t    }\n\t    if (this.props.path.x || this.props.path.y) {\n\t      return this.curveToPath({\n\t        start: {\n\t          x: 0,\n\t          y: 0\n\t        },\n\t        shift: {\n\t          x: this.props.path.x || 0,\n\t          y: this.props.path.y || 0\n\t        },\n\t        curvature: {\n\t          x: this.props.curvature.x || this.defaults.curvature.x,\n\t          y: this.props.curvature.y || this.defaults.curvature.y\n\t        }\n\t      });\n\t    }\n\t  };\n\n\t  MotionPath.prototype.getScaler = function() {\n\t    var end, size, start;\n\t    this.cSize = {\n\t      width: this.container.offsetWidth || 0,\n\t      height: this.container.offsetHeight || 0\n\t    };\n\t    start = this.path.getPointAtLength(0);\n\t    end = this.path.getPointAtLength(this.len);\n\t    size = {};\n\t    this.scaler = {};\n\t    size.width = end.x >= start.x ? end.x - start.x : start.x - end.x;\n\t    size.height = end.y >= start.y ? end.y - start.y : start.y - end.y;\n\t    switch (this.fillRule) {\n\t      case 'all':\n\t        this.calcWidth(size);\n\t        return this.calcHeight(size);\n\t      case 'width':\n\t        this.calcWidth(size);\n\t        return this.scaler.y = this.scaler.x;\n\t      case 'height':\n\t        this.calcHeight(size);\n\t        return this.scaler.x = this.scaler.y;\n\t    }\n\t  };\n\n\t  MotionPath.prototype.calcWidth = function(size) {\n\t    this.scaler.x = this.cSize.width / size.width;\n\t    return !isFinite(this.scaler.x) && (this.scaler.x = 1);\n\t  };\n\n\t  MotionPath.prototype.calcHeight = function(size) {\n\t    this.scaler.y = this.cSize.height / size.height;\n\t    return !isFinite(this.scaler.y) && (this.scaler.y = 1);\n\t  };\n\n\t  MotionPath.prototype.run = function(o) {\n\t    var fistItem, key, value;\n\t    if (o) {\n\t      fistItem = this.history[0];\n\t      for (key in o) {\n\t        value = o[key];\n\t        if (h.callbacksMap[key] || h.tweenOptionMap[key]) {\n\t          h.warn(\"the property \\\"\" + key + \"\\\" property can not be overridden on run yet\");\n\t          delete o[key];\n\t        } else {\n\t          this.history[0][key] = value;\n\t        }\n\t      }\n\t      this.tuneOptions(o);\n\t    }\n\t    return this.startTween();\n\t  };\n\n\t  MotionPath.prototype.createTween = function() {\n\t    this.tween = new Tween({\n\t      duration: this.props.duration,\n\t      delay: this.props.delay,\n\t      yoyo: this.props.yoyo,\n\t      repeat: this.props.repeat,\n\t      easing: this.props.easing,\n\t      onStart: (function(_this) {\n\t        return function() {\n\t          var ref;\n\t          return (ref = _this.props.onStart) != null ? ref.apply(_this) : void 0;\n\t        };\n\t      })(this),\n\t      onComplete: (function(_this) {\n\t        return function() {\n\t          var ref;\n\t          _this.props.motionBlur && _this.setBlur({\n\t            blur: {\n\t              x: 0,\n\t              y: 0\n\t            },\n\t            offset: {\n\t              x: 0,\n\t              y: 0\n\t            }\n\t          });\n\t          return (ref = _this.props.onComplete) != null ? ref.apply(_this) : void 0;\n\t        };\n\t      })(this),\n\t      onUpdate: (function(_this) {\n\t        return function(p) {\n\t          return _this.setProgress(p);\n\t        };\n\t      })(this),\n\t      onFirstUpdate: (function(_this) {\n\t        return function(isForward, isYoyo) {\n\t          if (!isForward) {\n\t            return _this.history.length > 1 && _this.tuneOptions(_this.history[0]);\n\t          }\n\t        };\n\t      })(this)\n\t    });\n\t    this.timeline = new Timeline;\n\t    this.timeline.add(this.tween);\n\t    !this.props.isRunLess && this.startTween();\n\t    return this.props.isPresetPosition && this.setProgress(0, true);\n\t  };\n\n\t  MotionPath.prototype.startTween = function() {\n\t    return setTimeout(((function(_this) {\n\t      return function() {\n\t        var ref;\n\t        return (ref = _this.timeline) != null ? ref.play() : void 0;\n\t      };\n\t    })(this)), 1);\n\t  };\n\n\t  MotionPath.prototype.setProgress = function(p, isInit) {\n\t    var len, point, x, y;\n\t    len = this.startLen + (!this.props.isReverse ? p * this.slicedLen : (1 - p) * this.slicedLen);\n\t    point = this.path.getPointAtLength(len);\n\t    x = point.x + this.props.offsetX;\n\t    y = point.y + this.props.offsetY;\n\t    this._getCurrentAngle(point, len, p);\n\t    this._setTransformOrigin(p);\n\t    this._setTransform(x, y, p, isInit);\n\t    return this.props.motionBlur && this.makeMotionBlur(x, y);\n\t  };\n\n\t  MotionPath.prototype.setElPosition = function(x, y, p) {\n\t    var composite, isComposite, rotate, transform;\n\t    rotate = this.angle !== 0 ? \"rotate(\" + this.angle + \"deg)\" : '';\n\t    isComposite = this.props.isCompositeLayer && h.is3d;\n\t    composite = isComposite ? 'translateZ(0)' : '';\n\t    transform = \"translate(\" + x + \"px,\" + y + \"px) \" + rotate + \" \" + composite;\n\t    return h.setPrefixedStyle(this.el, 'transform', transform);\n\t  };\n\n\t  MotionPath.prototype.setModulePosition = function(x, y) {\n\t    this.el._setProp({\n\t      shiftX: x + \"px\",\n\t      shiftY: y + \"px\",\n\t      angle: this.angle\n\t    });\n\t    return this.el._draw();\n\t  };\n\n\t  MotionPath.prototype._getCurrentAngle = function(point, len, p) {\n\t    var atan, isTransformFunOrigin, prevPoint, x1, x2;\n\t    isTransformFunOrigin = typeof this.props.transformOrigin === 'function';\n\t    if (this.props.isAngle || (this.props.angleOffset != null) || isTransformFunOrigin) {\n\t      prevPoint = this.path.getPointAtLength(len - 1);\n\t      x1 = point.y - prevPoint.y;\n\t      x2 = point.x - prevPoint.x;\n\t      atan = Math.atan(x1 / x2);\n\t      !isFinite(atan) && (atan = 0);\n\t      this.angle = atan * h.RAD_TO_DEG;\n\t      if ((typeof this.props.angleOffset) !== 'function') {\n\t        return this.angle += this.props.angleOffset || 0;\n\t      } else {\n\t        return this.angle = this.props.angleOffset.call(this, this.angle, p);\n\t      }\n\t    } else {\n\t      return this.angle = 0;\n\t    }\n\t  };\n\n\t  MotionPath.prototype._setTransform = function(x, y, p, isInit) {\n\t    var transform;\n\t    if (this.scaler) {\n\t      x *= this.scaler.x;\n\t      y *= this.scaler.y;\n\t    }\n\t    transform = null;\n\t    if (!isInit) {\n\t      transform = typeof this.onUpdate === \"function\" ? this.onUpdate(p, {\n\t        x: x,\n\t        y: y,\n\t        angle: this.angle\n\t      }) : void 0;\n\t    }\n\t    if (this.isModule) {\n\t      return this.setModulePosition(x, y);\n\t    } else {\n\t      if (typeof transform !== 'string') {\n\t        return this.setElPosition(x, y, p);\n\t      } else {\n\t        return h.setPrefixedStyle(this.el, 'transform', transform);\n\t      }\n\t    }\n\t  };\n\n\t  MotionPath.prototype._setTransformOrigin = function(p) {\n\t    var isTransformFunOrigin, tOrigin;\n\t    if (this.props.transformOrigin) {\n\t      isTransformFunOrigin = typeof this.props.transformOrigin === 'function';\n\t      tOrigin = !isTransformFunOrigin ? this.props.transformOrigin : this.props.transformOrigin(this.angle, p);\n\t      return h.setPrefixedStyle(this.el, 'transform-origin', tOrigin);\n\t    }\n\t  };\n\n\t  MotionPath.prototype.makeMotionBlur = function(x, y) {\n\t    var absoluteAngle, coords, dX, dY, signX, signY, tailAngle;\n\t    tailAngle = 0;\n\t    signX = 1;\n\t    signY = 1;\n\t    if ((this.prevCoords.x == null) || (this.prevCoords.y == null)) {\n\t      this.speedX = 0;\n\t      this.speedY = 0;\n\t    } else {\n\t      dX = x - this.prevCoords.x;\n\t      dY = y - this.prevCoords.y;\n\t      if (dX > 0) {\n\t        signX = -1;\n\t      }\n\t      if (signX < 0) {\n\t        signY = -1;\n\t      }\n\t      this.speedX = Math.abs(dX);\n\t      this.speedY = Math.abs(dY);\n\t      tailAngle = Math.atan(dY / dX) * (180 / Math.PI) + 90;\n\t    }\n\t    absoluteAngle = tailAngle - this.angle;\n\t    coords = this.angToCoords(absoluteAngle);\n\t    this.blurX = h.clamp((this.speedX / 16) * this.props.motionBlur, 0, 1);\n\t    this.blurY = h.clamp((this.speedY / 16) * this.props.motionBlur, 0, 1);\n\t    this.setBlur({\n\t      blur: {\n\t        x: 3 * this.blurX * this.blurAmount * Math.abs(coords.x),\n\t        y: 3 * this.blurY * this.blurAmount * Math.abs(coords.y)\n\t      },\n\t      offset: {\n\t        x: 3 * signX * this.blurX * coords.x * this.blurAmount,\n\t        y: 3 * signY * this.blurY * coords.y * this.blurAmount\n\t      }\n\t    });\n\t    this.prevCoords.x = x;\n\t    return this.prevCoords.y = y;\n\t  };\n\n\t  MotionPath.prototype.setBlur = function(o) {\n\t    if (!this.isMotionBlurReset) {\n\t      this.filter.setAttribute('stdDeviation', o.blur.x + \",\" + o.blur.y);\n\t      this.filterOffset.setAttribute('dx', o.offset.x);\n\t      return this.filterOffset.setAttribute('dy', o.offset.y);\n\t    }\n\t  };\n\n\t  MotionPath.prototype.extendDefaults = function(o) {\n\t    var key, results, value;\n\t    results = [];\n\t    for (key in o) {\n\t      value = o[key];\n\t      results.push(this[key] = value);\n\t    }\n\t    return results;\n\t  };\n\n\t  MotionPath.prototype.extendOptions = function(o) {\n\t    var key, results, value;\n\t    results = [];\n\t    for (key in o) {\n\t      value = o[key];\n\t      results.push(this.props[key] = value);\n\t    }\n\t    return results;\n\t  };\n\n\t  MotionPath.prototype.then = function(o) {\n\t    var it, key, opts, prevOptions, value;\n\t    prevOptions = this.history[this.history.length - 1];\n\t    opts = {};\n\t    for (key in prevOptions) {\n\t      value = prevOptions[key];\n\t      if (!h.callbacksMap[key] && !h.tweenOptionMap[key] || key === 'duration') {\n\t        if (o[key] == null) {\n\t          o[key] = value;\n\t        }\n\t      } else {\n\t        if (o[key] == null) {\n\t          o[key] = void 0;\n\t        }\n\t      }\n\t      if (h.tweenOptionMap[key]) {\n\t        opts[key] = key !== 'duration' ? o[key] : o[key] != null ? o[key] : prevOptions[key];\n\t      }\n\t    }\n\t    this.history.push(o);\n\t    it = this;\n\t    opts.onUpdate = (function(_this) {\n\t      return function(p) {\n\t        return _this.setProgress(p);\n\t      };\n\t    })(this);\n\t    opts.onStart = (function(_this) {\n\t      return function() {\n\t        var ref;\n\t        return (ref = _this.props.onStart) != null ? ref.apply(_this) : void 0;\n\t      };\n\t    })(this);\n\t    opts.onComplete = (function(_this) {\n\t      return function() {\n\t        var ref;\n\t        return (ref = _this.props.onComplete) != null ? ref.apply(_this) : void 0;\n\t      };\n\t    })(this);\n\t    opts.onFirstUpdate = function() {\n\t      return it.tuneOptions(it.history[this.index]);\n\t    };\n\t    opts.isChained = !o.delay;\n\t    this.timeline.append(new Tween(opts));\n\t    return this;\n\t  };\n\n\t  MotionPath.prototype.tuneOptions = function(o) {\n\t    this.extendOptions(o);\n\t    return this.postVars();\n\t  };\n\n\t  MotionPath.prototype.angToCoords = function(angle) {\n\t    var radAngle, x, y;\n\t    angle = angle % 360;\n\t    radAngle = ((angle - 90) * Math.PI) / 180;\n\t    x = Math.cos(radAngle);\n\t    y = Math.sin(radAngle);\n\t    x = x < 0 ? Math.max(x, -0.7) : Math.min(x, .7);\n\t    y = y < 0 ? Math.max(y, -0.7) : Math.min(y, .7);\n\t    return {\n\t      x: x * 1.428571429,\n\t      y: y * 1.428571429\n\t    };\n\t  };\n\n\t  return MotionPath;\n\n\t})();\n\n\tmodule.exports = MotionPath;\n\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\t/*!\n\t  LegoMushroom @legomushroom http://legomushroom.com\n\t  MIT License 2014\n\t */\n\n\t/* istanbul ignore next */\n\t(function() {\n\t  var Main;\n\t  Main = (function() {\n\t    function Main(o) {\n\t      this.o = o != null ? o : {};\n\t      if (window.isAnyResizeEventInited) {\n\t        return;\n\t      }\n\t      this.vars();\n\t      this.redefineProto();\n\t    }\n\n\t    Main.prototype.vars = function() {\n\t      window.isAnyResizeEventInited = true;\n\t      this.allowedProtos = [HTMLDivElement, HTMLFormElement, HTMLLinkElement, HTMLBodyElement, HTMLParagraphElement, HTMLFieldSetElement, HTMLLegendElement, HTMLLabelElement, HTMLButtonElement, HTMLUListElement, HTMLOListElement, HTMLLIElement, HTMLHeadingElement, HTMLQuoteElement, HTMLPreElement, HTMLBRElement, HTMLFontElement, HTMLHRElement, HTMLModElement, HTMLParamElement, HTMLMapElement, HTMLTableElement, HTMLTableCaptionElement, HTMLImageElement, HTMLTableCellElement, HTMLSelectElement, HTMLInputElement, HTMLTextAreaElement, HTMLAnchorElement, HTMLObjectElement, HTMLTableColElement, HTMLTableSectionElement, HTMLTableRowElement];\n\t      return this.timerElements = {\n\t        img: 1,\n\t        textarea: 1,\n\t        input: 1,\n\t        embed: 1,\n\t        object: 1,\n\t        svg: 1,\n\t        canvas: 1,\n\t        tr: 1,\n\t        tbody: 1,\n\t        thead: 1,\n\t        tfoot: 1,\n\t        a: 1,\n\t        select: 1,\n\t        option: 1,\n\t        optgroup: 1,\n\t        dl: 1,\n\t        dt: 1,\n\t        br: 1,\n\t        basefont: 1,\n\t        font: 1,\n\t        col: 1,\n\t        iframe: 1\n\t      };\n\t    };\n\n\t    Main.prototype.redefineProto = function() {\n\t      var i, it, proto, t;\n\t      it = this;\n\t      return t = (function() {\n\t        var j, len, ref, results;\n\t        ref = this.allowedProtos;\n\t        results = [];\n\t        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n\t          proto = ref[i];\n\t          if (proto.prototype == null) {\n\t            continue;\n\t          }\n\t          results.push((function(proto) {\n\t            var listener, remover;\n\t            listener = proto.prototype.addEventListener || proto.prototype.attachEvent;\n\t            (function(listener) {\n\t              var wrappedListener;\n\t              wrappedListener = function() {\n\t                var option;\n\t                if (this !== window || this !== document) {\n\t                  option = arguments[0] === 'onresize' && !this.isAnyResizeEventInited;\n\t                  option && it.handleResize({\n\t                    args: arguments,\n\t                    that: this\n\t                  });\n\t                }\n\t                return listener.apply(this, arguments);\n\t              };\n\t              if (proto.prototype.addEventListener) {\n\t                return proto.prototype.addEventListener = wrappedListener;\n\t              } else if (proto.prototype.attachEvent) {\n\t                return proto.prototype.attachEvent = wrappedListener;\n\t              }\n\t            })(listener);\n\t            remover = proto.prototype.removeEventListener || proto.prototype.detachEvent;\n\t            return (function(remover) {\n\t              var wrappedRemover;\n\t              wrappedRemover = function() {\n\t                this.isAnyResizeEventInited = false;\n\t                this.iframe && this.removeChild(this.iframe);\n\t                return remover.apply(this, arguments);\n\t              };\n\t              if (proto.prototype.removeEventListener) {\n\t                return proto.prototype.removeEventListener = wrappedRemover;\n\t              } else if (proto.prototype.detachEvent) {\n\t                return proto.prototype.detachEvent = wrappedListener;\n\t              }\n\t            })(remover);\n\t          })(proto));\n\t        }\n\t        return results;\n\t      }).call(this);\n\t    };\n\n\t    Main.prototype.handleResize = function(args) {\n\t      var computedStyle, el, iframe, isEmpty, isNoPos, isStatic, ref;\n\t      el = args.that;\n\t      if (!this.timerElements[el.tagName.toLowerCase()]) {\n\t        iframe = document.createElement('iframe');\n\t        el.appendChild(iframe);\n\t        iframe.style.width = '100%';\n\t        iframe.style.height = '100%';\n\t        iframe.style.position = 'absolute';\n\t        iframe.style.zIndex = -999;\n\t        iframe.style.opacity = 0;\n\t        iframe.style.top = 0;\n\t        iframe.style.left = 0;\n\t        computedStyle = window.getComputedStyle ? getComputedStyle(el) : el.currentStyle;\n\t        isNoPos = el.style.position === '';\n\t        isStatic = computedStyle.position === 'static' && isNoPos;\n\t        isEmpty = computedStyle.position === '' && el.style.position === '';\n\t        if (isStatic || isEmpty) {\n\t          el.style.position = 'relative';\n\t        }\n\t        if ((ref = iframe.contentWindow) != null) {\n\t          ref.onresize = (function(_this) {\n\t            return function(e) {\n\t              return _this.dispatchEvent(el);\n\t            };\n\t          })(this);\n\t        }\n\t        el.iframe = iframe;\n\t      } else {\n\t        this.initTimer(el);\n\t      }\n\t      return el.isAnyResizeEventInited = true;\n\t    };\n\n\t    Main.prototype.initTimer = function(el) {\n\t      var height, width;\n\t      width = 0;\n\t      height = 0;\n\t      return this.interval = setInterval((function(_this) {\n\t        return function() {\n\t          var newHeight, newWidth;\n\t          newWidth = el.offsetWidth;\n\t          newHeight = el.offsetHeight;\n\t          if (newWidth !== width || newHeight !== height) {\n\t            _this.dispatchEvent(el);\n\t            width = newWidth;\n\t            return height = newHeight;\n\t          }\n\t        };\n\t      })(this), this.o.interval || 62.5);\n\t    };\n\n\t    Main.prototype.dispatchEvent = function(el) {\n\t      var e;\n\t      if (document.createEvent) {\n\t        e = document.createEvent('HTMLEvents');\n\t        e.initEvent('onresize', false, false);\n\t        return el.dispatchEvent(e);\n\t      } else if (document.createEventObject) {\n\t        e = document.createEventObject();\n\t        return el.fireEvent('onresize', e);\n\t      } else {\n\t        return false;\n\t      }\n\t    };\n\n\t    Main.prototype.destroy = function() {\n\t      var i, it, j, len, proto, ref, results;\n\t      clearInterval(this.interval);\n\t      this.interval = null;\n\t      window.isAnyResizeEventInited = false;\n\t      it = this;\n\t      ref = this.allowedProtos;\n\t      results = [];\n\t      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n\t        proto = ref[i];\n\t        if (proto.prototype == null) {\n\t          continue;\n\t        }\n\t        results.push((function(proto) {\n\t          var listener;\n\t          listener = proto.prototype.addEventListener || proto.prototype.attachEvent;\n\t          if (proto.prototype.addEventListener) {\n\t            proto.prototype.addEventListener = Element.prototype.addEventListener;\n\t          } else if (proto.prototype.attachEvent) {\n\t            proto.prototype.attachEvent = Element.prototype.attachEvent;\n\t          }\n\t          if (proto.prototype.removeEventListener) {\n\t            return proto.prototype.removeEventListener = Element.prototype.removeEventListener;\n\t          } else if (proto.prototype.detachEvent) {\n\t            return proto.prototype.detachEvent = Element.prototype.detachEvent;\n\t          }\n\t        })(proto));\n\t      }\n\t      return results;\n\t    };\n\n\t    return Main;\n\n\t  })();\n\t  if (true) {\n\t    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return new Main;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if ((typeof module === \"object\") && (typeof module.exports === \"object\")) {\n\t    return module.exports = new Main;\n\t  } else {\n\t    if (typeof window !== \"undefined\" && window !== null) {\n\t      window.AnyResizeEvent = Main;\n\t    }\n\t    return typeof window !== \"undefined\" && window !== null ? window.anyResizeEvent = new Main : void 0;\n\t  }\n\t})();\n\n\n/***/ })\n/******/ ])\n});\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW8tanMvYnVpbGQvbW8uanM/ZDBkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsaUVBQWlFLDhDQUE4Qzs7QUFFL0c7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQ0FBc0MsaUNBQWlDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxVQUFVLElBQUksVUFBVSxJQUFJO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxJQUFJLFdBQVcsSUFBSTtBQUN4RCxnQ0FBZ0MsSUFBSSxZQUFZLEVBQUUsVUFBVSxHQUFHO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQixHQUFHLEtBQUs7QUFDdkMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLEVBQUU7QUFDZjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxvRUFBb0UsYUFBYTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0EsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQSwySkFBMko7QUFDM0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25COzs7QUFHQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQixFQUFFOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksVUFBVTtBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7OztBQUdBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakIsYUFBYSxJQUFJO0FBQ2pCLGVBQWUsUUFBUTtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsWUFBWSxPQUFPO0FBQ25COzs7QUFHQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsTUFBTTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsSUFBSTtBQUNuQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGVBQWU7QUFDaEMsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDLDZDQUE2Qzs7QUFFN0M7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsZUFBZSxJQUFJO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxVQUFVOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsVUFBVTtBQUNWOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxpQ0FBaUM7O0FBRTVFLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxFQUFFO0FBQy9DLG9CQUFvQixzQ0FBc0M7QUFDMUQsRUFBRSxvQ0FBb0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7O0FBRUYsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7OztBQUdBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qix5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUE4QztBQUN4RSwwQkFBMEIsOENBQThDO0FBQ3hFLDBCQUEwQixzREFBc0Q7QUFDaEYsMEJBQTBCLG9EQUFvRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQixlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxJQUFJO0FBQ2pCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBLHVGQUF1RixNQUFNO0FBQzdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsSUFBSTtBQUNqQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEIsMEJBQTBCLE9BQU87QUFDakMsMEJBQTBCLGVBQWU7QUFDekM7OztBQUdBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSxVQUFVLElBQUksVUFBVSxJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLElBQUksV0FBVyxJQUFJO0FBQzVELG9DQUFvQyxJQUFJLFlBQVksRUFBRSxVQUFVLEdBQUc7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixlQUFlLE1BQU07QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCOztBQUU5Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU8sVUFBVTs7QUFFMUI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssRUFBRSxVQUFVO0FBQ3hDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBdUMsdUNBQXVDLGdCQUFnQjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLElBQUk7QUFDbEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLHVDQUF1QyxnQkFBZ0I7O0FBRTlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQixnQ0FBZ0MsR0FBRzs7QUFFakY7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFdBQVc7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFFOztBQUVGOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkLFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRixPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIm1vanNcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibW9qc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtb2pzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImJ1aWxkL1wiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHsndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3NoYXBlc01hcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuXG5cdHZhciBfc2hhcGVzTWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlc01hcCk7XG5cblx0dmFyIF9zaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQpO1xuXG5cdHZhciBfc2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGUpO1xuXG5cdHZhciBfc2hhcGVTd2lybCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3KTtcblxuXHR2YXIgX3NoYXBlU3dpcmwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGVTd2lybCk7XG5cblx0dmFyIF9idXJzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4KTtcblxuXHR2YXIgX2J1cnN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1cnN0KTtcblxuXHR2YXIgX2h0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOSk7XG5cblx0dmFyIF9odG1sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2h0bWwpO1xuXG5cdHZhciBfc3RhZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3KTtcblxuXHR2YXIgX3N0YWdnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhZ2dlcik7XG5cblx0dmFyIF9zcHJpdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpO1xuXG5cdHZhciBfc3ByaXRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcHJpdGVyKTtcblxuXHR2YXIgX21vdGlvblBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyOSk7XG5cblx0dmFyIF9tb3Rpb25QYXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vdGlvblBhdGgpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHR2YXIgX3R3ZWVuZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMik7XG5cblx0dmFyIF90d2VlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuZXIpO1xuXG5cdHZhciBfdHdlZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xuXG5cdHZhciBfdHdlZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuYWJsZSk7XG5cblx0dmFyIF90aGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuXG5cdHZhciBfdGhlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbmFibGUpO1xuXG5cdHZhciBfdHVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxuXHR2YXIgX3R1bmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHVuYWJsZSk7XG5cblx0dmFyIF9kZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI2KTtcblxuXHR2YXIgX2RlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbHRhKTtcblxuXHR2YXIgX2RlbHRhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTI1KTtcblxuXHR2YXIgX2RlbHRhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWx0YXMpO1xuXG5cdHZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cblx0dmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuXHR2YXIgX2Vhc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcblxuXHR2YXIgX2Vhc2luZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYXNpbmcpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIG1vanMgPSB7XG5cdCAgcmV2aXNpb246ICcwLjI4OC4yJywgaXNEZWJ1ZzogdHJ1ZSwgaGVscGVyczogX2gyLmRlZmF1bHQsXG5cdCAgU2hhcGU6IF9zaGFwZTIuZGVmYXVsdCwgU2hhcGVTd2lybDogX3NoYXBlU3dpcmwyLmRlZmF1bHQsIEJ1cnN0OiBfYnVyc3QyLmRlZmF1bHQsIEh0bWw6IF9odG1sMi5kZWZhdWx0LCBzdGFnZ2VyOiBfc3RhZ2dlcjIuZGVmYXVsdCwgU3ByaXRlcjogX3Nwcml0ZXIyLmRlZmF1bHQsIE1vdGlvblBhdGg6IF9tb3Rpb25QYXRoMi5kZWZhdWx0LFxuXHQgIFR3ZWVuOiBfdHdlZW4yLmRlZmF1bHQsIFRpbWVsaW5lOiBfdGltZWxpbmUyLmRlZmF1bHQsIFR3ZWVuYWJsZTogX3R3ZWVuYWJsZTIuZGVmYXVsdCwgVGhlbmFibGU6IF90aGVuYWJsZTIuZGVmYXVsdCwgVHVuYWJsZTogX3R1bmFibGUyLmRlZmF1bHQsIE1vZHVsZTogX21vZHVsZTIuZGVmYXVsdCxcblx0ICB0d2VlbmVyOiBfdHdlZW5lcjIuZGVmYXVsdCwgZWFzaW5nOiBfZWFzaW5nMi5kZWZhdWx0LCBzaGFwZXNNYXA6IF9zaGFwZXNNYXAyLmRlZmF1bHQsIF9wb29sOiB7IERlbHRhOiBfZGVsdGEyLmRlZmF1bHQsIERlbHRhczogX2RlbHRhczIuZGVmYXVsdCB9XG5cdH07XG5cblx0Ly8gZnVuY3Rpb25zIGFsaWFzXG5cdG1vanMuaCA9IG1vanMuaGVscGVycztcblx0bW9qcy5kZWx0YSA9IG1vanMuaC5kZWx0YTtcblx0Ly8gY3VzdG9tIHNoYXBlIGFkZCBmdW5jdGlvbiBhbmQgY2xhc3Ncblx0bW9qcy5hZGRTaGFwZSA9IG1vanMuc2hhcGVzTWFwLmFkZFNoYXBlO1xuXHRtb2pzLkN1c3RvbVNoYXBlID0gbW9qcy5zaGFwZXNNYXAuY3VzdG9tO1xuXHQvLyBtb2R1bGUgYWxpYXNcblx0bW9qcy5UcmFuc2l0ID0gbW9qcy5TaGFwZTtcblx0bW9qcy5Td2lybCA9IG1vanMuU2hhcGVTd2lybDtcblxuXHQvLyBUT0RPOlxuXHQvKlxuXHQgIEgvViBpbiBwYXRoc1xuXG5cdCAgcmFuZCBmb3IgZGlyZWN0aW9uXG5cdCAgYnVyc3QgY2hpbGRyZW4gYW5nbGUgYWZ0ZXIgdHVuZVxuXHQgIGJ1cnN0IHBhdGhTY2FsZSBhZnRlciB0dW5lXG5cdCAgc3dpcmwgdGhlbiBpc3N1ZVxuXHQgICdyYW5kJyBhbmdsZSBmbGljayB3aXRoIGB0aGVuYFxuXHQgIG5vdCBhYmxlIHRvIGBwbGF5KClgIGluIGBvbkNvbXBsZXRlYCBjYWxsYmFja1xuXHQgIC0tLVxuXHQgIG1vZHVsZSBuYW1lc1xuXHQgIHN3aXJscyBpbiB0aGVuIGNoYWlucyBmb3IgeC95XG5cdCAgcGFyc2UgcmFuZChzdGFnZ2VyKDIwLCAxMCksIDIwKSB2YWx1ZXNcblx0ICBwZXJjZW50YWdlIGZvciByYWRpdXNcblx0Ki9cblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXHRpZiAodHJ1ZSkge1xuXHQgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBtb2pzO1xuXHQgIH0uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0fVxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXHRpZiAoKCBmYWxzZSA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKG1vZHVsZSkpID09PSBcIm9iamVjdFwiICYmICgwLCBfdHlwZW9mMy5kZWZhdWx0KShtb2R1bGUuZXhwb3J0cykgPT09IFwib2JqZWN0XCIpIHtcblx0ICBtb2R1bGUuZXhwb3J0cyA9IG1vanM7XG5cdH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBtb2pzO1xuXG5cblx0dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5tb2pzID0gbW9qcyk7XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1vZHVsZTtcclxuXHR9XHJcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cdHZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG5cdHZhciBfc3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XG5cblx0dmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxuXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xuXHR9IDogZnVuY3Rpb24gKG9iaikge1xuXHQgIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpLmYoJ2l0ZXJhdG9yJyk7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0dmFyICRhdCAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKHRydWUpO1xuXG5cdC8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMCkoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuXHQgIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcblx0ICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuXHQvLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG5cdH0sIGZ1bmN0aW9uKCl7XG5cdCAgdmFyIE8gICAgID0gdGhpcy5fdFxuXHQgICAgLCBpbmRleCA9IHRoaXMuX2lcblx0ICAgICwgcG9pbnQ7XG5cdCAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcblx0ICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG5cdCAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG5cdCAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcblx0fSk7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpXG5cdCAgLCBkZWZpbmVkICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQvLyB0cnVlICAtPiBTdHJpbmcjYXRcblx0Ly8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oVE9fU1RSSU5HKXtcblx0ICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcblx0ICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG5cdCAgICAgICwgaSA9IHRvSW50ZWdlcihwb3MpXG5cdCAgICAgICwgbCA9IHMubGVuZ3RoXG5cdCAgICAgICwgYSwgYjtcblx0ICAgIGlmKGkgPCAwIHx8IGkgPj0gbClyZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG5cdCAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuXHQgICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcblx0ICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcblx0ICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gNy4xLjQgVG9JbnRlZ2VyXG5cdHZhciBjZWlsICA9IE1hdGguY2VpbFxuXHQgICwgZmxvb3IgPSBNYXRoLmZsb29yO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0Ly8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciBMSUJSQVJZICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpXG5cdCAgLCAkZXhwb3J0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXG5cdCAgLCByZWRlZmluZSAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpXG5cdCAgLCBoaWRlICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpXG5cdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCBJdGVyYXRvcnMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXG5cdCAgLCAkaXRlckNyZWF0ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXG5cdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpXG5cdCAgLCBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpXG5cdCAgLCBJVEVSQVRPUiAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpKCdpdGVyYXRvcicpXG5cdCAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG5cdCAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuXHQgICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcblx0ICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cblx0dmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG5cdCAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuXHQgIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcblx0ICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcblx0ICAgIHN3aXRjaChraW5kKXtcblx0ICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuXHQgICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuXHQgICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuXHQgIH07XG5cdCAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcblx0ICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG5cdCAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuXHQgICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcblx0ICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuXHQgICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcblx0ICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcblx0ICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcblx0ICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcblx0ICAvLyBGaXggbmF0aXZlXG5cdCAgaWYoJGFueU5hdGl2ZSl7XG5cdCAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuXHQgICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuXHQgICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG5cdCAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuXHQgICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcblx0ICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuXHQgIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG5cdCAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcblx0ICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG5cdCAgfVxuXHQgIC8vIERlZmluZSBpdGVyYXRvclxuXHQgIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcblx0ICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG5cdCAgfVxuXHQgIC8vIFBsdWcgZm9yIGxpYnJhcnlcblx0ICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcblx0ICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuXHQgIGlmKERFRkFVTFQpe1xuXHQgICAgbWV0aG9kcyA9IHtcblx0ICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG5cdCAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcblx0ICAgICAgZW50cmllczogJGVudHJpZXNcblx0ICAgIH07XG5cdCAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcblx0ICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG5cdCAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuXHQgIH1cblx0ICByZXR1cm4gbWV0aG9kcztcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBnbG9iYWwgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKVxuXHQgICwgY29yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNClcblx0ICAsIGN0eCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpXG5cdCAgLCBoaWRlICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KVxuXHQgICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cblx0dmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuXHQgIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG5cdCAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkdcblx0ICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuXHQgICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG5cdCAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcblx0ICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xuXHQgICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuXHQgICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cblx0ICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuXHQgICAgLCBrZXksIG93biwgb3V0O1xuXHQgIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuXHQgIGZvcihrZXkgaW4gc291cmNlKXtcblx0ICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuXHQgICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcblx0ICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcblx0ICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG5cdCAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuXHQgICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG5cdCAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuXHQgICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcblx0ICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG5cdCAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuXHQgICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcblx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbihhLCBiLCBjKXtcblx0ICAgICAgICBpZih0aGlzIGluc3RhbmNlb2YgQyl7XG5cdCAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG5cdCAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDO1xuXHQgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcblx0ICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG5cdCAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcblx0ICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgIH07XG5cdCAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcblx0ICAgICAgcmV0dXJuIEY7XG5cdCAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcblx0ICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcblx0ICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuXHQgICAgaWYoSVNfUFJPVE8pe1xuXHQgICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG5cdCAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG5cdCAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuXHQgICAgfVxuXHQgIH1cblx0fTtcblx0Ly8gdHlwZSBiaXRtYXBcblx0JGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcblx0JGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcblx0JGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcblx0JGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuXHQkZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcblx0JGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG5cdCRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuXHQkZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5cdG1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5cdHZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0aWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5cdGlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cdHZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcblx0ICBhRnVuY3Rpb24oZm4pO1xuXHQgIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG5cdCAgc3dpdGNoKGxlbmd0aCl7XG5cdCAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuXHQgIHJldHVybiBpdDtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBkUCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOClcblx0ICAsIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG5cdCAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcblx0fSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG5cdCAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICByZXR1cm4gb2JqZWN0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGFuT2JqZWN0ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSlcblx0ICAsIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSlcblx0ICAsIHRvUHJpbWl0aXZlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSlcblx0ICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5cdGV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuXHQgIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG5cdCAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG5cdCAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXHQgIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuXHQgIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcblx0ICByZXR1cm4gTztcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSAhX193ZWJwYWNrX3JlcXVpcmVfXygyMikgJiYgIV9fd2VicGFja19yZXF1aXJlX18oMjMpKGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSgnZGl2JyksICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG5cdH0pO1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxuXHRtb2R1bGUuZXhwb3J0cyA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKShmdW5jdGlvbigpe1xuXHQgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG5cdH0pO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuICEhZXhlYygpO1xuXHQgIH0gY2F0Y2goZSl7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKVxuXHQgICwgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5kb2N1bWVudFxuXHQgIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuXHQgICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcblx0dmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdC8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG5cdC8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuXHQgIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuXHQgIHZhciBmbiwgdmFsO1xuXHQgIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcblx0ICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG5cdCAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcblx0ICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuXHQgIHJldHVybiB7XG5cdCAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG5cdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG5cdCAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG5cdCAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciBjcmVhdGUgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpXG5cdCAgLCBkZXNjcmlwdG9yICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpXG5cdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpXG5cdCAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG5cdC8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTcpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuXHQgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcblx0ICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuXHR2YXIgYW5PYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuXHQgICwgZFBzICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKVxuXHQgICwgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KVxuXHQgICwgSUVfUFJPVE8gICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSgnSUVfUFJPVE8nKVxuXHQgICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG5cdCAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG5cdC8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcblx0dmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuXHQgIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG5cdCAgdmFyIGlmcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpKCdpZnJhbWUnKVxuXHQgICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcblx0ICAgICwgbHQgICAgID0gJzwnXG5cdCAgICAsIGd0ICAgICA9ICc+J1xuXHQgICAgLCBpZnJhbWVEb2N1bWVudDtcblx0ICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHQgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcblx0ICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuXHQgIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcblx0ICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuXHQgIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcblx0ICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG5cdCAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcblx0ICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcblx0ICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG5cdCAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuXHQgIHZhciByZXN1bHQ7XG5cdCAgaWYoTyAhPT0gbnVsbCl7XG5cdCAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG5cdCAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG5cdCAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcblx0ICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcblx0ICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuXHQgIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG5cdCAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZFAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KVxuXHQgICwgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuXHQgICwgZ2V0S2V5cyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuXHQgIGFuT2JqZWN0KE8pO1xuXHQgIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG5cdCAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cdCAgICAsIGkgPSAwXG5cdCAgICAsIFA7XG5cdCAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuXHQgIHJldHVybiBPO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG5cdHZhciAka2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpXG5cdCAgLCBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcblx0ICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGhhcyAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCB0b0lPYmplY3QgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVxuXHQgICwgYXJyYXlJbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCkoZmFsc2UpXG5cdCAgLCBJRV9QUk9UTyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKSgnSUVfUFJPVE8nKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuXHQgIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuXHQgICAgLCBpICAgICAgPSAwXG5cdCAgICAsIHJlc3VsdCA9IFtdXG5cdCAgICAsIGtleTtcblx0ICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcblx0ICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3Ncblx0dmFyIElPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxuXHQgICwgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5cdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuXHQvLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xuXHR2YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSlcblx0ICAsIHRvTGVuZ3RoICA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpXG5cdCAgLCB0b0luZGV4ICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcblx0ICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG5cdCAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG5cdCAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcblx0ICAgICAgLCB2YWx1ZTtcblx0ICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cblx0ICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcblx0ICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuXHQgICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcblx0ICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3Rcblx0ICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuXHQgICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG5cdCAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDcuMS4xNSBUb0xlbmd0aFxuXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxuXHQgICwgbWluICAgICAgID0gTWF0aC5taW47XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVxuXHQgICwgbWF4ICAgICAgID0gTWF0aC5tYXhcblx0ICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuXHQgIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcblx0ICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKSgna2V5cycpXG5cdCAgLCB1aWQgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuXHQgIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcblx0ICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG5cdCAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcblx0ICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBpZCA9IDBcblx0ICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuXHQgIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5cdG1vZHVsZS5leHBvcnRzID0gKFxuXHQgICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG5cdCkuc3BsaXQoJywnKTtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGRlZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpLmZcblx0ICAsIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSgndG9TdHJpbmdUYWcnKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuXHQgIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBzdG9yZSAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MikoJ3drcycpXG5cdCAgLCB1aWQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mylcblx0ICAsIFN5bWJvbCAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKS5TeW1ib2xcblx0ICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cblx0dmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcblx0ICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cblx0ICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG5cdH07XG5cblx0JGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG5cdHZhciBoYXMgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCB0b09iamVjdCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpXG5cdCAgLCBJRV9QUk9UTyAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpKCdJRV9QUk9UTycpXG5cdCAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24oTyl7XG5cdCAgTyA9IHRvT2JqZWN0KE8pO1xuXHQgIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuXHQgIGlmKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3Ipe1xuXHQgICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuXHQgIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG5cdHZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblx0dmFyIGdsb2JhbCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKVxuXHQgICwgaGlkZSAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpXG5cdCAgLCBJdGVyYXRvcnMgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSlcblx0ICAsIFRPX1NUUklOR19UQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSgndG9TdHJpbmdUYWcnKTtcblxuXHRmb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcblx0ICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG5cdCAgICAsIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV1cblx0ICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5cdCAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuXHQgIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcblx0fVxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpXG5cdCAgLCBzdGVwICAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mylcblx0ICAsIEl0ZXJhdG9ycyAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxuXHQgICwgdG9JT2JqZWN0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG5cdC8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcblx0Ly8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcblx0Ly8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuXHQvLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuXHQgIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcblx0ICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuXHQgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG5cdC8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxuXHR9LCBmdW5jdGlvbigpe1xuXHQgIHZhciBPICAgICA9IHRoaXMuX3Rcblx0ICAgICwga2luZCAgPSB0aGlzLl9rXG5cdCAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuXHQgIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcblx0ICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG5cdCAgICByZXR1cm4gc3RlcCgxKTtcblx0ICB9XG5cdCAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG5cdCAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG5cdCAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xuXHR9LCAndmFsdWVzJyk7XG5cblx0Ly8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuXHRJdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5cdGFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcblx0YWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5cdGFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuXHQgIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cbi8qKiovIH0pLFxuLyogNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oNTYpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5TeW1ib2w7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cblx0dmFyIGdsb2JhbCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMylcblx0ICAsIGhhcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOClcblx0ICAsIERFU0NSSVBUT1JTICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMilcblx0ICAsICRleHBvcnQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMilcblx0ICAsIHJlZGVmaW5lICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNylcblx0ICAsIE1FVEEgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCkuS0VZXG5cdCAgLCAkZmFpbHMgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpXG5cdCAgLCBzaGFyZWQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpXG5cdCAgLCBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpXG5cdCAgLCB1aWQgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpXG5cdCAgLCB3a3MgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpXG5cdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpXG5cdCAgLCB3a3NEZWZpbmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpXG5cdCAgLCBrZXlPZiAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjApXG5cdCAgLCBlbnVtS2V5cyAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpXG5cdCAgLCBpc0FycmF5ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpXG5cdCAgLCBhbk9iamVjdCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpXG5cdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpXG5cdCAgLCB0b1ByaW1pdGl2ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpXG5cdCAgLCBjcmVhdGVEZXNjICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpXG5cdCAgLCBfY3JlYXRlICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpXG5cdCAgLCBnT1BORXh0ICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpXG5cdCAgLCAkR09QRCAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpXG5cdCAgLCAkRFAgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpXG5cdCAgLCAka2V5cyAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpXG5cdCAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcblx0ICAsIGRQICAgICAgICAgICAgID0gJERQLmZcblx0ICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG5cdCAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcblx0ICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cblx0ICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG5cdCAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG5cdCAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG5cdCAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuXHQgICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuXHQgICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG5cdCAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG5cdCAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG5cdCAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG5cdCAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcblx0ICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG5cdC8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xuXHR2YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuXHQvLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcblx0dmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG5cdCAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cblx0ICB9KSkuYSAhPSA3O1xuXHR9KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuXHQgIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuXHQgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcblx0ICBkUChpdCwga2V5LCBEKTtcblx0ICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG5cdH0gOiBkUDtcblxuXHR2YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG5cdCAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcblx0ICBzeW0uX2sgPSB0YWc7XG5cdCAgcmV0dXJuIHN5bTtcblx0fTtcblxuXHR2YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG5cdH0gOiBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcblx0fTtcblxuXHR2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG5cdCAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG5cdCAgYW5PYmplY3QoaXQpO1xuXHQgIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG5cdCAgYW5PYmplY3QoRCk7XG5cdCAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuXHQgICAgaWYoIUQuZW51bWVyYWJsZSl7XG5cdCAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuXHQgICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcblx0ICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG5cdCAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuXHQgIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xuXHR9O1xuXHR2YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcblx0ICBhbk9iamVjdChpdCk7XG5cdCAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuXHQgICAgLCBpICAgID0gMFxuXHQgICAgLCBsID0ga2V5cy5sZW5ndGhcblx0ICAgICwga2V5O1xuXHQgIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuXHQgIHJldHVybiBpdDtcblx0fTtcblx0dmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuXHQgIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcblx0fTtcblx0dmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG5cdCAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcblx0ICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG5cdCAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xuXHR9O1xuXHR2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcblx0ICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuXHQgIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG5cdCAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcblx0ICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG5cdCAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG5cdCAgcmV0dXJuIEQ7XG5cdH07XG5cdHZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuXHQgIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG5cdCAgICAsIHJlc3VsdCA9IFtdXG5cdCAgICAsIGkgICAgICA9IDBcblx0ICAgICwga2V5O1xuXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuXHQgICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG5cdCAgfSByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHR2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG5cdCAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuXHQgICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcblx0ICAgICwgcmVzdWx0ID0gW11cblx0ICAgICwgaSAgICAgID0gMFxuXHQgICAgLCBrZXk7XG5cdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG5cdCAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcblx0ICB9IHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5cdGlmKCFVU0VfTkFUSVZFKXtcblx0ICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG5cdCAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcblx0ICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuXHQgICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcblx0ICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuXHQgICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuXHQgICAgcmV0dXJuIHdyYXAodGFnKTtcblx0ICB9O1xuXHQgIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcblx0ICAgIHJldHVybiB0aGlzLl9rO1xuXHQgIH0pO1xuXG5cdCAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cdCAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcblx0ICBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2MykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cdCAgX193ZWJwYWNrX3JlcXVpcmVfXyg2MikuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblx0ICBpZihERVNDUklQVE9SUyAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygxMSkpe1xuXHQgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG5cdCAgfVxuXG5cdCAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcblx0ICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG5cdCAgfVxuXHR9XG5cblx0JGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5cdGZvcih2YXIgc3ltYm9scyA9IChcblx0ICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuXHQgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcblx0KS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cblx0Zm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG5cdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG5cdCAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG5cdCAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG5cdCAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG5cdCAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuXHQgICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG5cdCAgfSxcblx0ICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcblx0ICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuXHQgICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG5cdCAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG5cdCAgfSxcblx0ICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG5cdCAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxuXHR9KTtcblxuXHQkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuXHQgIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcblx0ICBjcmVhdGU6ICRjcmVhdGUsXG5cdCAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG5cdCAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcblx0ICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuXHQgIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuXHQgIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcblx0ICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG5cdCAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcblx0ICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcblx0ICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG5cdCAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdH0pO1xuXG5cdC8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuXHQkSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcblx0ICB2YXIgUyA9ICRTeW1ib2woKTtcblx0ICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuXHQgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuXHQgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG5cdCAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcblx0fSkpLCAnSlNPTicsIHtcblx0ICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG5cdCAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcblx0ICAgIHZhciBhcmdzID0gW2l0XVxuXHQgICAgICAsIGkgICAgPSAxXG5cdCAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcblx0ICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG5cdCAgICByZXBsYWNlciA9IGFyZ3NbMV07XG5cdCAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcblx0ICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0ICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG5cdCAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuXHQgICAgfTtcblx0ICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcblx0ICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcblx0ICB9XG5cdH0pO1xuXG5cdC8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcblx0JFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygxNykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcblx0Ly8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuXHRzZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG5cdC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcblx0Ly8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgTUVUQSAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKSgnbWV0YScpXG5cdCAgLCBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjApXG5cdCAgLCBoYXMgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCBzZXREZXNjICA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpLmZcblx0ICAsIGlkICAgICAgID0gMDtcblx0dmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gdHJ1ZTtcblx0fTtcblx0dmFyIEZSRUVaRSA9ICFfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKShmdW5jdGlvbigpe1xuXHQgIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG5cdH0pO1xuXHR2YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcblx0ICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcblx0ICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuXHQgICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcblx0ICB9fSk7XG5cdH07XG5cdHZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG5cdCAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuXHQgIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcblx0ICBpZighaGFzKGl0LCBNRVRBKSl7XG5cdCAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuXHQgICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcblx0ICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG5cdCAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG5cdCAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuXHQgICAgc2V0TWV0YShpdCk7XG5cdCAgLy8gcmV0dXJuIG9iamVjdCBJRFxuXHQgIH0gcmV0dXJuIGl0W01FVEFdLmk7XG5cdH07XG5cdHZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG5cdCAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuXHQgICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3Rcblx0ICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuXHQgICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcblx0ICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuXHQgICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcblx0ICAgIHNldE1ldGEoaXQpO1xuXHQgIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG5cdCAgfSByZXR1cm4gaXRbTUVUQV0udztcblx0fTtcblx0Ly8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG5cdHZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXHR2YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIEtFWTogICAgICBNRVRBLFxuXHQgIE5FRUQ6ICAgICBmYWxzZSxcblx0ICBmYXN0S2V5OiAgZmFzdEtleSxcblx0ICBnZXRXZWFrOiAgZ2V0V2Vhayxcblx0ICBvbkZyZWV6ZTogb25GcmVlemVcblx0fTtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBnbG9iYWwgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpXG5cdCAgLCBjb3JlICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXG5cdCAgLCBMSUJSQVJZICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpXG5cdCAgLCB3a3NFeHQgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpXG5cdCAgLCBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpLmY7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG5cdCAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcblx0ICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBnZXRLZXlzICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKVxuXHQgICwgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG5cdCAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG5cdCAgICAsIGtleXMgICA9IGdldEtleXMoTylcblx0ICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcblx0ICAgICwgaW5kZXggID0gMFxuXHQgICAgLCBrZXk7XG5cdCAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG5cdHZhciBnZXRLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMylcblx0ICAsIGdPUFMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKVxuXHQgICwgcElFICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG5cdCAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG5cdCAgaWYoZ2V0U3ltYm9scyl7XG5cdCAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG5cdCAgICAgICwgaXNFbnVtICA9IHBJRS5mXG5cdCAgICAgICwgaSAgICAgICA9IDBcblx0ICAgICAgLCBrZXk7XG5cdCAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcblx0ICB9IHJldHVybiByZXN1bHQ7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKiovIH0pLFxuLyogNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxuXHR2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG5cdCAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5cdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KVxuXHQgICwgZ09QTiAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NikuZlxuXHQgICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cblx0dmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcblx0ICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxuXHR2YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBnT1BOKGl0KTtcblx0ICB9IGNhdGNoKGUpe1xuXHQgICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG5cdCAgfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcblx0ICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xuXHR9O1xuXG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5cdHZhciAka2V5cyAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNClcblx0ICAsIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuXHRleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuXHQgIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBwSUUgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpXG5cdCAgLCBjcmVhdGVEZXNjICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpXG5cdCAgLCB0b0lPYmplY3QgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpXG5cdCAgLCB0b1ByaW1pdGl2ZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpXG5cdCAgLCBoYXMgICAgICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXG5cdCAgLCBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpXG5cdCAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cblx0ZXhwb3J0cy5mID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMikgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuXHQgIE8gPSB0b0lPYmplY3QoTyk7XG5cdCAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuXHQgIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG5cdCAgICByZXR1cm4gZ09QRChPLCBQKTtcblx0ICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cdCAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1OSkoJ2FzeW5jSXRlcmF0b3InKTtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNTkpKCdvYnNlcnZhYmxlJyk7XG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgSGVscGVycywgaDtcblxuXHRIZWxwZXJzID0gKGZ1bmN0aW9uKCkge1xuXHQgIEhlbHBlcnMucHJvdG90eXBlLk5TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmxvZ0JhZGdlQ3NzID0gJ2JhY2tncm91bmQ6IzNBMDgzOTtjb2xvcjojRkY1MTJGO2JvcmRlci1yYWRpdXM6NXB4OyBwYWRkaW5nOiAxcHggNXB4IDJweDsgYm9yZGVyOiAxcHggc29saWQgI0ZGNTEyRjsnO1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuc2hvcnRDb2xvcnMgPSB7XG5cdCAgICB0cmFuc3BhcmVudDogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgbm9uZTogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgYXF1YTogJ3JnYigwLDI1NSwyNTUpJyxcblx0ICAgIGJsYWNrOiAncmdiKDAsMCwwKScsXG5cdCAgICBibHVlOiAncmdiKDAsMCwyNTUpJyxcblx0ICAgIGZ1Y2hzaWE6ICdyZ2IoMjU1LDAsMjU1KScsXG5cdCAgICBncmF5OiAncmdiKDEyOCwxMjgsMTI4KScsXG5cdCAgICBncmVlbjogJ3JnYigwLDEyOCwwKScsXG5cdCAgICBsaW1lOiAncmdiKDAsMjU1LDApJyxcblx0ICAgIG1hcm9vbjogJ3JnYigxMjgsMCwwKScsXG5cdCAgICBuYXZ5OiAncmdiKDAsMCwxMjgpJyxcblx0ICAgIG9saXZlOiAncmdiKDEyOCwxMjgsMCknLFxuXHQgICAgcHVycGxlOiAncmdiKDEyOCwwLDEyOCknLFxuXHQgICAgcmVkOiAncmdiKDI1NSwwLDApJyxcblx0ICAgIHNpbHZlcjogJ3JnYigxOTIsMTkyLDE5MiknLFxuXHQgICAgdGVhbDogJ3JnYigwLDEyOCwxMjgpJyxcblx0ICAgIHdoaXRlOiAncmdiKDI1NSwyNTUsMjU1KScsXG5cdCAgICB5ZWxsb3c6ICdyZ2IoMjU1LDI1NSwwKScsXG5cdCAgICBvcmFuZ2U6ICdyZ2IoMjU1LDEyOCwwKSdcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2hhaW5PcHRpb25NYXAgPSB7fTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNhbGxiYWNrc01hcCA9IHtcblx0ICAgIG9uUmVmcmVzaDogMSxcblx0ICAgIG9uU3RhcnQ6IDEsXG5cdCAgICBvbkNvbXBsZXRlOiAxLFxuXHQgICAgb25GaXJzdFVwZGF0ZTogMSxcblx0ICAgIG9uVXBkYXRlOiAxLFxuXHQgICAgb25Qcm9ncmVzczogMSxcblx0ICAgIG9uUmVwZWF0U3RhcnQ6IDEsXG5cdCAgICBvblJlcGVhdENvbXBsZXRlOiAxLFxuXHQgICAgb25QbGF5YmFja1N0YXJ0OiAxLFxuXHQgICAgb25QbGF5YmFja1BhdXNlOiAxLFxuXHQgICAgb25QbGF5YmFja1N0b3A6IDEsXG5cdCAgICBvblBsYXliYWNrQ29tcGxldGU6IDFcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUudHdlZW5PcHRpb25NYXAgPSB7XG5cdCAgICBkdXJhdGlvbjogMSxcblx0ICAgIGRlbGF5OiAxLFxuXHQgICAgc3BlZWQ6IDEsXG5cdCAgICByZXBlYXQ6IDEsXG5cdCAgICBlYXNpbmc6IDEsXG5cdCAgICBiYWNrd2FyZEVhc2luZzogMSxcblx0ICAgIGlzWW95bzogMSxcblx0ICAgIHNoaWZ0VGltZTogMSxcblx0ICAgIGlzUmV2ZXJzZWQ6IDEsXG5cdCAgICBjYWxsYmFja3NDb250ZXh0OiAxXG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnVuaXRPcHRpb25NYXAgPSB7XG5cdCAgICBsZWZ0OiAxLFxuXHQgICAgdG9wOiAxLFxuXHQgICAgeDogMSxcblx0ICAgIHk6IDEsXG5cdCAgICByeDogMSxcblx0ICAgIHJ5OiAxXG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLlJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xuXG5cdCAgZnVuY3Rpb24gSGVscGVycygpIHtcblx0ICAgIHRoaXMudmFycygpO1xuXHQgIH1cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB1YTtcblx0ICAgIHRoaXMucHJlZml4ID0gdGhpcy5nZXRQcmVmaXgoKTtcblx0ICAgIHRoaXMuZ2V0UmVtQmFzZSgpO1xuXHQgICAgdGhpcy5pc0ZGID0gdGhpcy5wcmVmaXgubG93ZXJjYXNlID09PSAnbW96Jztcblx0ICAgIHRoaXMuaXNJRSA9IHRoaXMucHJlZml4Lmxvd2VyY2FzZSA9PT0gJ21zJztcblx0ICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0ICAgIHRoaXMuaXNPbGRPcGVyYSA9IHVhLm1hdGNoKC9wcmVzdG8vZ2ltKTtcblx0ICAgIHRoaXMuaXNTYWZhcmkgPSB1YS5pbmRleE9mKCdTYWZhcmknKSA+IC0xO1xuXHQgICAgdGhpcy5pc0Nocm9tZSA9IHVhLmluZGV4T2YoJ0Nocm9tZScpID4gLTE7XG5cdCAgICB0aGlzLmlzT3BlcmEgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJvcFwiKSA+IC0xO1xuXHQgICAgdGhpcy5pc0Nocm9tZSAmJiB0aGlzLmlzU2FmYXJpICYmICh0aGlzLmlzU2FmYXJpID0gZmFsc2UpO1xuXHQgICAgKHVhLm1hdGNoKC9QaGFudG9tSlMvZ2ltKSkgJiYgKHRoaXMuaXNTYWZhcmkgPSBmYWxzZSk7XG5cdCAgICB0aGlzLmlzQ2hyb21lICYmIHRoaXMuaXNPcGVyYSAmJiAodGhpcy5pc0Nocm9tZSA9IGZhbHNlKTtcblx0ICAgIHRoaXMuaXMzZCA9IHRoaXMuY2hlY2tJZjNkKCk7XG5cdCAgICB0aGlzLnVuaXFJRHMgPSAtMTtcblx0ICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcblx0ICAgIHJldHVybiB0aGlzLmRlZmF1bHRTdHlsZXMgPSB0aGlzLmNvbXB1dGVkU3R5bGUodGhpcy5kaXYpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jbG9uZU9iaiA9IGZ1bmN0aW9uKG9iaiwgZXhjbHVkZSkge1xuXHQgICAgdmFyIGksIGtleSwga2V5cywgbmV3T2JqO1xuXHQgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdCAgICBuZXdPYmogPSB7fTtcblx0ICAgIGkgPSBrZXlzLmxlbmd0aDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgaWYgKGV4Y2x1ZGUgIT0gbnVsbCkge1xuXHQgICAgICAgIGlmICghZXhjbHVkZVtrZXldKSB7XG5cdCAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3T2JqO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihvYmpUbywgb2JqRnJvbSkge1xuXHQgICAgdmFyIGtleSwgdmFsdWU7XG5cdCAgICBmb3IgKGtleSBpbiBvYmpGcm9tKSB7XG5cdCAgICAgIHZhbHVlID0gb2JqRnJvbVtrZXldO1xuXHQgICAgICBpZiAob2JqVG9ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgb2JqVG9ba2V5XSA9IG9iakZyb21ba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9ialRvO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRSZW1CYXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgaHRtbCwgc3R5bGU7XG5cdCAgICBodG1sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpO1xuXHQgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVtQmFzZSA9IHBhcnNlRmxvYXQoc3R5bGUuZm9udFNpemUpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCkge1xuXHQgICAgaWYgKHZhbHVlIDwgbWluKSB7XG5cdCAgICAgIHJldHVybiBtaW47XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG5cdCAgICAgIHJldHVybiBtYXg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnNldFByZWZpeGVkU3R5bGUgPSBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0ICAgIChuYW1lID09PSAndHJhbnNmb3JtJykgJiYgKGVsLnN0eWxlW1wiXCIgKyB0aGlzLnByZWZpeC5jc3MgKyBuYW1lXSA9IHZhbHVlKTtcblx0ICAgIHJldHVybiBlbC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHQgICAgdmFyIGtleSwga2V5cywgbGVuLCByZXN1bHRzO1xuXHQgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXHQgICAgICBrZXlzID0gT2JqZWN0LmtleXMobmFtZSk7XG5cdCAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgICAgIGtleSA9IGtleXNbbGVuXTtcblx0ICAgICAgICB2YWx1ZSA9IG5hbWVba2V5XTtcblx0ICAgICAgICByZXN1bHRzLnB1c2godGhpcy5zZXRQcmVmaXhlZFN0eWxlKGVsLCBrZXksIHZhbHVlKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5zZXRQcmVmaXhlZFN0eWxlKGVsLCBuYW1lLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnByZXBhcmVGb3JMb2cgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3MpO1xuXHQgICAgYXJncy51bnNoaWZ0KCc6OicpO1xuXHQgICAgYXJncy51bnNoaWZ0KHRoaXMubG9nQmFkZ2VDc3MpO1xuXHQgICAgYXJncy51bnNoaWZ0KCclY21vwrdqcyVjJyk7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAobW9qcy5pc0RlYnVnID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgdGhpcy5wcmVwYXJlRm9yTG9nKGFyZ3VtZW50cykpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAobW9qcy5pc0RlYnVnID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIHRoaXMucHJlcGFyZUZvckxvZyhhcmd1bWVudHMpKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmIChtb2pzLmlzRGVidWcgPT09IGZhbHNlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIHRoaXMucHJlcGFyZUZvckxvZyhhcmd1bWVudHMpKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VVbml0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgIHZhciBhbW91bnQsIGlzU3RyaWN0LCByZWYsIHJlZ2V4LCByZXR1cm5WYWwsIHVuaXQ7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gcmV0dXJuVmFsID0ge1xuXHQgICAgICAgIHVuaXQ6ICdweCcsXG5cdCAgICAgICAgaXNTdHJpY3Q6IGZhbHNlLFxuXHQgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICBzdHJpbmc6IHZhbHVlID09PSAwID8gXCJcIiArIHZhbHVlIDogdmFsdWUgKyBcInB4XCJcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICByZWdleCA9IC9weHwlfHJlbXxlbXxleHxjbXxjaHxtbXxpbnxwdHxwY3x2aHx2d3x2bWlufGRlZy9naW07XG5cdCAgICAgIHVuaXQgPSAocmVmID0gdmFsdWUubWF0Y2gocmVnZXgpKSAhPSBudWxsID8gcmVmWzBdIDogdm9pZCAwO1xuXHQgICAgICBpc1N0cmljdCA9IHRydWU7XG5cdCAgICAgIGlmICghdW5pdCkge1xuXHQgICAgICAgIHVuaXQgPSAncHgnO1xuXHQgICAgICAgIGlzU3RyaWN0ID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdCAgICAgIHJldHVybiByZXR1cm5WYWwgPSB7XG5cdCAgICAgICAgdW5pdDogdW5pdCxcblx0ICAgICAgICBpc1N0cmljdDogaXNTdHJpY3QsXG5cdCAgICAgICAgdmFsdWU6IGFtb3VudCxcblx0ICAgICAgICBzdHJpbmc6IGFtb3VudCA9PT0gMCA/IFwiXCIgKyBhbW91bnQgOiBcIlwiICsgYW1vdW50ICsgdW5pdFxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuXHQgICAgdmFyIGJpbmRBcmdzLCB3cmFwcGVyO1xuXHQgICAgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgYXJncywgdW5zaGlmdEFyZ3M7XG5cdCAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICB1bnNoaWZ0QXJncyA9IGJpbmRBcmdzLmNvbmNhdChhcmdzKTtcblx0ICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgdW5zaGlmdEFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIGJpbmRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0ICAgIHJldHVybiB3cmFwcGVyO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRSYWRpYWxQb2ludCA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBwb2ludCwgcmFkQW5nbGUsIHJhZGl1c1gsIHJhZGl1c1k7XG5cdCAgICBpZiAobyA9PSBudWxsKSB7XG5cdCAgICAgIG8gPSB7fTtcblx0ICAgIH1cblx0ICAgIHJhZEFuZ2xlID0gKG8uYW5nbGUgLSA5MCkgKiAwLjAxNzQ1MzI5MjUxOTk0MzI5NTtcblx0ICAgIHJhZGl1c1ggPSBvLnJhZGl1c1ggIT0gbnVsbCA/IG8ucmFkaXVzWCA6IG8ucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IG8ucmFkaXVzWSAhPSBudWxsID8gby5yYWRpdXNZIDogby5yYWRpdXM7XG5cdCAgICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICAgIHg6IG8uY2VudGVyLnggKyAoTWF0aC5jb3MocmFkQW5nbGUpICogcmFkaXVzWCksXG5cdCAgICAgIHk6IG8uY2VudGVyLnkgKyAoTWF0aC5zaW4ocmFkQW5nbGUpICogcmFkaXVzWSlcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGRvbSwgcHJlLCBzdHlsZXMsIHY7XG5cdCAgICBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIFwiXCIpO1xuXHQgICAgdiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHN0eWxlcykuam9pbihcIlwiKS5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKTtcblx0ICAgIHByZSA9ICh2IHx8IChzdHlsZXMuT0xpbmsgPT09IFwiXCIgJiYgW1wiXCIsIFwib1wiXSkpWzFdO1xuXHQgICAgZG9tID0gXCJXZWJLaXR8TW96fE1TfE9cIi5tYXRjaChuZXcgUmVnRXhwKFwiKFwiICsgcHJlICsgXCIpXCIsIFwiaVwiKSlbMV07XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBkb206IGRvbSxcblx0ICAgICAgbG93ZXJjYXNlOiBwcmUsXG5cdCAgICAgIGNzczogXCItXCIgKyBwcmUgKyBcIi1cIixcblx0ICAgICAganM6IHByZVswXS50b1VwcGVyQ2FzZSgpICsgcHJlLnN1YnN0cigxKVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuc3RyVG9BcnIgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICAgIHZhciBhcnI7XG5cdCAgICBhcnIgPSBbXTtcblx0ICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3RyaW5nKSkge1xuXHQgICAgICBhcnIucHVzaCh0aGlzLnBhcnNlVW5pdChzdHJpbmcpKTtcblx0ICAgICAgcmV0dXJuIGFycjtcblx0ICAgIH1cblx0ICAgIHN0cmluZy50cmltKCkuc3BsaXQoL1xccysvZ2ltKS5mb3JFYWNoKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyci5wdXNoKF90aGlzLnBhcnNlVW5pdChfdGhpcy5wYXJzZUlmUmFuZChzdHIpKSk7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgICByZXR1cm4gYXJyO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jYWxjQXJyRGVsdGEgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdCAgICB2YXIgZGVsdGEsIGksIGosIGxlbjEsIG51bTtcblx0ICAgIGRlbHRhID0gW107XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgbGVuMSA9IGFycjEubGVuZ3RoOyBqIDwgbGVuMTsgaSA9ICsraikge1xuXHQgICAgICBudW0gPSBhcnIxW2ldO1xuXHQgICAgICBkZWx0YVtpXSA9IHRoaXMucGFyc2VVbml0KFwiXCIgKyAoYXJyMltpXS52YWx1ZSAtIGFycjFbaV0udmFsdWUpICsgYXJyMltpXS51bml0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdCAgICByZXR1cm4gdmFyaWFibGUgaW5zdGFuY2VvZiBBcnJheTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUubm9ybURhc2hBcnJheXMgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdCAgICB2YXIgYXJyMUxlbiwgYXJyMkxlbiwgY3Vyckl0ZW0sIGksIGosIGssIGxlbkRpZmYsIHJlZiwgcmVmMSwgc3RhcnRJO1xuXHQgICAgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuXHQgICAgYXJyMkxlbiA9IGFycjIubGVuZ3RoO1xuXHQgICAgaWYgKGFycjFMZW4gPiBhcnIyTGVuKSB7XG5cdCAgICAgIGxlbkRpZmYgPSBhcnIxTGVuIC0gYXJyMkxlbjtcblx0ICAgICAgc3RhcnRJID0gYXJyMi5sZW5ndGg7XG5cdCAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBsZW5EaWZmOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgICBjdXJySXRlbSA9IGkgKyBzdGFydEk7XG5cdCAgICAgICAgYXJyMi5wdXNoKHRoaXMucGFyc2VVbml0KFwiMFwiICsgYXJyMVtjdXJySXRlbV0udW5pdCkpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGFycjJMZW4gPiBhcnIxTGVuKSB7XG5cdCAgICAgIGxlbkRpZmYgPSBhcnIyTGVuIC0gYXJyMUxlbjtcblx0ICAgICAgc3RhcnRJID0gYXJyMS5sZW5ndGg7XG5cdCAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gbGVuRGlmZjsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xuXHQgICAgICAgIGN1cnJJdGVtID0gaSArIHN0YXJ0STtcblx0ICAgICAgICBhcnIxLnB1c2godGhpcy5wYXJzZVVuaXQoXCIwXCIgKyBhcnIyW2N1cnJJdGVtXS51bml0KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBbYXJyMSwgYXJyMl07XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLm1ha2VDb2xvck9iaiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdCAgICB2YXIgYWxwaGEsIGIsIGNvbG9yT2JqLCBnLCBpc1JnYiwgciwgcmVnZXhTdHJpbmcxLCByZWdleFN0cmluZzIsIHJlc3VsdCwgcmdiQ29sb3I7XG5cdCAgICBpZiAoY29sb3JbMF0gPT09ICcjJykge1xuXHQgICAgICByZXN1bHQgPSAvXiM/KFthLWZcXGRdezEsMn0pKFthLWZcXGRdezEsMn0pKFthLWZcXGRdezEsMn0pJC9pLmV4ZWMoY29sb3IpO1xuXHQgICAgICBjb2xvck9iaiA9IHt9O1xuXHQgICAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgICAgciA9IHJlc3VsdFsxXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMV0gOiByZXN1bHRbMV0gKyByZXN1bHRbMV07XG5cdCAgICAgICAgZyA9IHJlc3VsdFsyXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMl0gOiByZXN1bHRbMl0gKyByZXN1bHRbMl07XG5cdCAgICAgICAgYiA9IHJlc3VsdFszXS5sZW5ndGggPT09IDIgPyByZXN1bHRbM10gOiByZXN1bHRbM10gKyByZXN1bHRbM107XG5cdCAgICAgICAgY29sb3JPYmogPSB7XG5cdCAgICAgICAgICByOiBwYXJzZUludChyLCAxNiksXG5cdCAgICAgICAgICBnOiBwYXJzZUludChnLCAxNiksXG5cdCAgICAgICAgICBiOiBwYXJzZUludChiLCAxNiksXG5cdCAgICAgICAgICBhOiAxXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGNvbG9yWzBdICE9PSAnIycpIHtcblx0ICAgICAgaXNSZ2IgPSBjb2xvclswXSA9PT0gJ3InICYmIGNvbG9yWzFdID09PSAnZycgJiYgY29sb3JbMl0gPT09ICdiJztcblx0ICAgICAgaWYgKGlzUmdiKSB7XG5cdCAgICAgICAgcmdiQ29sb3IgPSBjb2xvcjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWlzUmdiKSB7XG5cdCAgICAgICAgcmdiQ29sb3IgPSAhdGhpcy5zaG9ydENvbG9yc1tjb2xvcl0gPyAodGhpcy5kaXYuc3R5bGUuY29sb3IgPSBjb2xvciwgdGhpcy5jb21wdXRlZFN0eWxlKHRoaXMuZGl2KS5jb2xvcikgOiB0aGlzLnNob3J0Q29sb3JzW2NvbG9yXTtcblx0ICAgICAgfVxuXHQgICAgICByZWdleFN0cmluZzEgPSAnXnJnYmE/XFxcXCgoXFxcXGR7MSwzfSksXFxcXHM/KFxcXFxkezEsM30pLCc7XG5cdCAgICAgIHJlZ2V4U3RyaW5nMiA9ICdcXFxccz8oXFxcXGR7MSwzfSksP1xcXFxzPyhcXFxcZHsxfXwwP1xcXFwuXFxcXGR7MSx9KT9cXFxcKSQnO1xuXHQgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nMSArIHJlZ2V4U3RyaW5nMiwgJ2dpJykuZXhlYyhyZ2JDb2xvcik7XG5cdCAgICAgIGNvbG9yT2JqID0ge307XG5cdCAgICAgIGFscGhhID0gcGFyc2VGbG9hdChyZXN1bHRbNF0gfHwgMSk7XG5cdCAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICBjb2xvck9iaiA9IHtcblx0ICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTApLFxuXHQgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxMCksXG5cdCAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDEwKSxcblx0ICAgICAgICAgIGE6IChhbHBoYSAhPSBudWxsKSAmJiAhaXNOYU4oYWxwaGEpID8gYWxwaGEgOiAxXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNvbG9yT2JqO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jb21wdXRlZFN0eWxlID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHRocm93IEVycm9yKCdTdHJpbmcgZXhwZWN0ZWQgLSBub3RoaW5nIHRvIGNhcGl0YWxpemUnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZVJhbmQgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICAgIHZhciByYW5kLCByYW5kQXJyLCB1bml0cztcblx0ICAgIHJhbmRBcnIgPSBzdHJpbmcuc3BsaXQoL3JhbmRcXCh8XFwsfFxcKS8pO1xuXHQgICAgdW5pdHMgPSB0aGlzLnBhcnNlVW5pdChyYW5kQXJyWzJdKTtcblx0ICAgIHJhbmQgPSB0aGlzLnJhbmQocGFyc2VGbG9hdChyYW5kQXJyWzFdKSwgcGFyc2VGbG9hdChyYW5kQXJyWzJdKSk7XG5cdCAgICBpZiAodW5pdHMudW5pdCAmJiByYW5kQXJyWzJdLm1hdGNoKHVuaXRzLnVuaXQpKSB7XG5cdCAgICAgIHJldHVybiByYW5kICsgdW5pdHMudW5pdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiByYW5kO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZVN0YWdnZXIgPSBmdW5jdGlvbihzdHJpbmcsIGluZGV4KSB7XG5cdCAgICB2YXIgYmFzZSwgbnVtYmVyLCBzcGxpdHRlZFZhbHVlLCB1bml0LCB1bml0VmFsdWUsIHZhbHVlO1xuXHQgICAgdmFsdWUgPSBzdHJpbmcuc3BsaXQoL3N0YWdnZXJcXCh8XFwpJC8pWzFdLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBzcGxpdHRlZFZhbHVlID0gdmFsdWUuc3BsaXQoLyhyYW5kXFwoLio/XFwpfFteXFwoLFxcc10rKSg/PVxccyosfFxccyokKS9naW0pO1xuXHQgICAgdmFsdWUgPSBzcGxpdHRlZFZhbHVlLmxlbmd0aCA+IDMgPyAoYmFzZSA9IHRoaXMucGFyc2VVbml0KHRoaXMucGFyc2VJZlJhbmQoc3BsaXR0ZWRWYWx1ZVsxXSkpLCBzcGxpdHRlZFZhbHVlWzNdKSA6IChiYXNlID0gdGhpcy5wYXJzZVVuaXQoMCksIHNwbGl0dGVkVmFsdWVbMV0pO1xuXHQgICAgdmFsdWUgPSB0aGlzLnBhcnNlSWZSYW5kKHZhbHVlKTtcblx0ICAgIHVuaXRWYWx1ZSA9IHRoaXMucGFyc2VVbml0KHZhbHVlKTtcblx0ICAgIG51bWJlciA9IGluZGV4ICogdW5pdFZhbHVlLnZhbHVlICsgYmFzZS52YWx1ZTtcblx0ICAgIHVuaXQgPSBiYXNlLmlzU3RyaWN0ID8gYmFzZS51bml0IDogdW5pdFZhbHVlLmlzU3RyaWN0ID8gdW5pdFZhbHVlLnVuaXQgOiAnJztcblx0ICAgIGlmICh1bml0KSB7XG5cdCAgICAgIHJldHVybiBcIlwiICsgbnVtYmVyICsgdW5pdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlSWZTdGFnZ2VyID0gZnVuY3Rpb24odmFsdWUsIGkpIHtcblx0ICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL3N0YWdnZXIvZykpKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RhZ2dlcih2YWx1ZSwgaSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlSWZSYW5kID0gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyLm1hdGNoKC9yYW5kXFwoLykpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucGFyc2VSYW5kKHN0cik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gc3RyO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZURlbHRhID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgaW5kZXgpIHtcblx0ICAgIHZhciBjdXJ2ZSwgZGVsdGEsIGVhc2luZywgZW5kLCBlbmRBcnIsIGVuZENvbG9yT2JqLCBpLCBqLCBsZW4xLCBzdGFydCwgc3RhcnRBcnIsIHN0YXJ0Q29sb3JPYmo7XG5cdCAgICB2YWx1ZSA9IHRoaXMuY2xvbmVPYmoodmFsdWUpO1xuXHQgICAgZWFzaW5nID0gdmFsdWUuZWFzaW5nO1xuXHQgICAgaWYgKGVhc2luZyAhPSBudWxsKSB7XG5cdCAgICAgIGVhc2luZyA9IG1vanMuZWFzaW5nLnBhcnNlRWFzaW5nKGVhc2luZyk7XG5cdCAgICB9XG5cdCAgICBkZWxldGUgdmFsdWUuZWFzaW5nO1xuXHQgICAgY3VydmUgPSB2YWx1ZS5jdXJ2ZTtcblx0ICAgIGlmIChjdXJ2ZSAhPSBudWxsKSB7XG5cdCAgICAgIGN1cnZlID0gbW9qcy5lYXNpbmcucGFyc2VFYXNpbmcoY3VydmUpO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHZhbHVlLmN1cnZlO1xuXHQgICAgc3RhcnQgPSBPYmplY3Qua2V5cyh2YWx1ZSlbMF07XG5cdCAgICBlbmQgPSB2YWx1ZVtzdGFydF07XG5cdCAgICBkZWx0YSA9IHtcblx0ICAgICAgc3RhcnQ6IHN0YXJ0XG5cdCAgICB9O1xuXHQgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc3RhcnQpKSAmJiAhc3RhcnQubWF0Y2goL3JhbmRcXCgvKSAmJiAhc3RhcnQubWF0Y2goL3N0YWdnZXJcXCgvKSkge1xuXHQgICAgICBpZiAoa2V5ID09PSAnc3Ryb2tlTGluZWNhcCcpIHtcblx0ICAgICAgICB0aGlzLndhcm4oXCJTb3JyeSwgc3Ryb2tlLWxpbmVjYXAgcHJvcGVydHkgaXMgbm90IGFuaW1hdGFibGUgeWV0LCB1c2luZyB0aGUgc3RhcnQoXCIgKyBzdGFydCArIFwiKSB2YWx1ZSBpbnN0ZWFkXCIsIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gZGVsdGE7XG5cdCAgICAgIH1cblx0ICAgICAgc3RhcnRDb2xvck9iaiA9IHRoaXMubWFrZUNvbG9yT2JqKHN0YXJ0KTtcblx0ICAgICAgZW5kQ29sb3JPYmogPSB0aGlzLm1ha2VDb2xvck9iaihlbmQpO1xuXHQgICAgICBkZWx0YSA9IHtcblx0ICAgICAgICB0eXBlOiAnY29sb3InLFxuXHQgICAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgICBzdGFydDogc3RhcnRDb2xvck9iaixcblx0ICAgICAgICBlbmQ6IGVuZENvbG9yT2JqLFxuXHQgICAgICAgIGVhc2luZzogZWFzaW5nLFxuXHQgICAgICAgIGN1cnZlOiBjdXJ2ZSxcblx0ICAgICAgICBkZWx0YToge1xuXHQgICAgICAgICAgcjogZW5kQ29sb3JPYmouciAtIHN0YXJ0Q29sb3JPYmoucixcblx0ICAgICAgICAgIGc6IGVuZENvbG9yT2JqLmcgLSBzdGFydENvbG9yT2JqLmcsXG5cdCAgICAgICAgICBiOiBlbmRDb2xvck9iai5iIC0gc3RhcnRDb2xvck9iai5iLFxuXHQgICAgICAgICAgYTogZW5kQ29sb3JPYmouYSAtIHN0YXJ0Q29sb3JPYmouYVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3Ryb2tlRGFzaGFycmF5JyB8fCBrZXkgPT09ICdzdHJva2VEYXNob2Zmc2V0JyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG5cdCAgICAgIHN0YXJ0QXJyID0gdGhpcy5zdHJUb0FycihzdGFydCk7XG5cdCAgICAgIGVuZEFyciA9IHRoaXMuc3RyVG9BcnIoZW5kKTtcblx0ICAgICAgdGhpcy5ub3JtRGFzaEFycmF5cyhzdGFydEFyciwgZW5kQXJyKTtcblx0ICAgICAgZm9yIChpID0gaiA9IDAsIGxlbjEgPSBzdGFydEFyci5sZW5ndGg7IGogPCBsZW4xOyBpID0gKytqKSB7XG5cdCAgICAgICAgc3RhcnQgPSBzdGFydEFycltpXTtcblx0ICAgICAgICBlbmQgPSBlbmRBcnJbaV07XG5cdCAgICAgICAgdGhpcy5tZXJnZVVuaXRzKHN0YXJ0LCBlbmQsIGtleSk7XG5cdCAgICAgIH1cblx0ICAgICAgZGVsdGEgPSB7XG5cdCAgICAgICAgdHlwZTogJ2FycmF5Jyxcblx0ICAgICAgICBuYW1lOiBrZXksXG5cdCAgICAgICAgc3RhcnQ6IHN0YXJ0QXJyLFxuXHQgICAgICAgIGVuZDogZW5kQXJyLFxuXHQgICAgICAgIGRlbHRhOiB0aGlzLmNhbGNBcnJEZWx0YShzdGFydEFyciwgZW5kQXJyKSxcblx0ICAgICAgICBlYXNpbmc6IGVhc2luZyxcblx0ICAgICAgICBjdXJ2ZTogY3VydmVcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICghdGhpcy5jYWxsYmFja3NNYXBba2V5XSAmJiAhdGhpcy50d2Vlbk9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudW5pdE9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgICAgICBlbmQgPSB0aGlzLnBhcnNlVW5pdCh0aGlzLnBhcnNlU3RyaW5nT3B0aW9uKGVuZCwgaW5kZXgpKTtcblx0ICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wYXJzZVVuaXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihzdGFydCwgaW5kZXgpKTtcblx0ICAgICAgICAgIHRoaXMubWVyZ2VVbml0cyhzdGFydCwgZW5kLCBrZXkpO1xuXHQgICAgICAgICAgZGVsdGEgPSB7XG5cdCAgICAgICAgICAgIHR5cGU6ICd1bml0Jyxcblx0ICAgICAgICAgICAgbmFtZToga2V5LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogZW5kLFxuXHQgICAgICAgICAgICBkZWx0YTogZW5kLnZhbHVlIC0gc3RhcnQudmFsdWUsXG5cdCAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxuXHQgICAgICAgICAgICBjdXJ2ZTogY3VydmVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGVuZCA9IHBhcnNlRmxvYXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihlbmQsIGluZGV4KSk7XG5cdCAgICAgICAgICBzdGFydCA9IHBhcnNlRmxvYXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihzdGFydCwgaW5kZXgpKTtcblx0ICAgICAgICAgIGRlbHRhID0ge1xuXHQgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcblx0ICAgICAgICAgICAgbmFtZToga2V5LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogZW5kLFxuXHQgICAgICAgICAgICBkZWx0YTogZW5kIC0gc3RhcnQsXG5cdCAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxuXHQgICAgICAgICAgICBjdXJ2ZTogY3VydmVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLm1lcmdlVW5pdHMgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBrZXkpIHtcblx0ICAgIGlmICghZW5kLmlzU3RyaWN0ICYmIHN0YXJ0LmlzU3RyaWN0KSB7XG5cdCAgICAgIGVuZC51bml0ID0gc3RhcnQudW5pdDtcblx0ICAgICAgcmV0dXJuIGVuZC5zdHJpbmcgPSBcIlwiICsgZW5kLnZhbHVlICsgZW5kLnVuaXQ7XG5cdCAgICB9IGVsc2UgaWYgKGVuZC5pc1N0cmljdCAmJiAhc3RhcnQuaXNTdHJpY3QpIHtcblx0ICAgICAgc3RhcnQudW5pdCA9IGVuZC51bml0O1xuXHQgICAgICByZXR1cm4gc3RhcnQuc3RyaW5nID0gXCJcIiArIHN0YXJ0LnZhbHVlICsgc3RhcnQudW5pdDtcblx0ICAgIH0gZWxzZSBpZiAoZW5kLmlzU3RyaWN0ICYmIHN0YXJ0LmlzU3RyaWN0KSB7XG5cdCAgICAgIGlmIChlbmQudW5pdCAhPT0gc3RhcnQudW5pdCkge1xuXHQgICAgICAgIHN0YXJ0LnVuaXQgPSBlbmQudW5pdDtcblx0ICAgICAgICBzdGFydC5zdHJpbmcgPSBcIlwiICsgc3RhcnQudmFsdWUgKyBzdGFydC51bml0O1xuXHQgICAgICAgIHJldHVybiB0aGlzLndhcm4oXCJUd28gZGlmZmVyZW50IHVuaXRzIHdlcmUgc3BlY2lmaWVkIG9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBkZWx0YSBwcm9wZXJ0eSwgbW8gwrcganMgd2lsbCBmYWxsYmFjayB0byBlbmQgXFxcIlwiICsgZW5kLnVuaXQgKyBcIlxcXCIgdW5pdCBcIik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucmFuZCA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG5cdCAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmlzRE9NID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGlzTm9kZTtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaXNOb2RlID0gdHlwZW9mIG8ubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJztcblx0ICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgaXNOb2RlO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRDaGlsZEVsZW1lbnRzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHQgICAgdmFyIGNoaWxkTm9kZXMsIGNoaWxkcmVuLCBpO1xuXHQgICAgY2hpbGROb2RlcyA9IGVsZW1lbnQuY2hpbGROb2Rlcztcblx0ICAgIGNoaWxkcmVuID0gW107XG5cdCAgICBpID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIGlmIChjaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSAxKSB7XG5cdCAgICAgICAgY2hpbGRyZW4udW5zaGlmdChjaGlsZE5vZGVzW2ldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoaWxkcmVuO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5kZWx0YSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBpc1R5cGUxLCBpc1R5cGUyLCBvYmosIHR5cGUxLCB0eXBlMjtcblx0ICAgIHR5cGUxID0gdHlwZW9mIHN0YXJ0O1xuXHQgICAgdHlwZTIgPSB0eXBlb2YgZW5kO1xuXHQgICAgaXNUeXBlMSA9IHR5cGUxID09PSAnc3RyaW5nJyB8fCB0eXBlMSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHN0YXJ0KTtcblx0ICAgIGlzVHlwZTIgPSB0eXBlMiA9PT0gJ3N0cmluZycgfHwgdHlwZTIgPT09ICdudW1iZXInICYmICFpc05hTihlbmQpO1xuXHQgICAgaWYgKCFpc1R5cGUxIHx8ICFpc1R5cGUyKSB7XG5cdCAgICAgIHRoaXMuZXJyb3IoXCJkZWx0YSBtZXRob2QgZXhwZWN0cyBTdHJpbmdzIG9yIE51bWJlcnMgYXQgaW5wdXQgYnV0IGdvdCAtIFwiICsgc3RhcnQgKyBcIiwgXCIgKyBlbmQpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBvYmogPSB7fTtcblx0ICAgIG9ialtzdGFydF0gPSBlbmQ7XG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRVbmlxSUQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiArK3RoaXMudW5pcUlEcztcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuXHQgICAgdmFyIGRvbVBhdGg7XG5cdCAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmIChwYXRoLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpID09PSAnbScpIHtcblx0ICAgICAgICBkb21QYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMuTlMsICdwYXRoJyk7XG5cdCAgICAgICAgZG9tUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHBhdGgpO1xuXHQgICAgICAgIHJldHVybiBkb21QYXRoO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhdGgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAocGF0aC5zdHlsZSkge1xuXHQgICAgICByZXR1cm4gcGF0aDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2xvc2VFbm91Z2ggPSBmdW5jdGlvbihudW0xLCBudW0yLCBlcHMpIHtcblx0ICAgIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCBlcHM7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNoZWNrSWYzZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGRpdiwgcHJlZml4ZWQsIHN0eWxlLCB0cjtcblx0ICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgdGhpcy5zdHlsZShkaXYsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xuXHQgICAgc3R5bGUgPSBkaXYuc3R5bGU7XG5cdCAgICBwcmVmaXhlZCA9IHRoaXMucHJlZml4LmNzcyArIFwidHJhbnNmb3JtXCI7XG5cdCAgICB0ciA9IHN0eWxlW3ByZWZpeGVkXSAhPSBudWxsID8gc3R5bGVbcHJlZml4ZWRdIDogc3R5bGUudHJhbnNmb3JtO1xuXHQgICAgcmV0dXJuIHRyICE9PSAnJztcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHZhcmlhYmxlIGhvbGRzIHBvaW50ZXIgdG8gYW4gb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtBbnl9IFZhcmlhYmxlIHRvIHRlc3Rcblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBJZiB2YXJpYWJsZSBpcyBvYmplY3QuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5pc09iamVjdCA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdCAgICByZXR1cm4gdmFyaWFibGUgIT09IG51bGwgJiYgdHlwZW9mIHZhcmlhYmxlID09PSAnb2JqZWN0Jztcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBmaXJzdCB2YWx1ZSBvZiB0aGUgb2JqZWN0LlxuXHQgICAgVXNlZCB0byBnZXQgZW5kIHZhbHVlIG9uIOKIhnMuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIGdldCB0aGUgdmFsdWUgb2YuXG5cdCAgICBAcmV0dXJucyB7QW55fSBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG9iamVjdCcgcHJvcGVydHkuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXREZWx0YUVuZCA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgdmFyIGtleTtcblx0ICAgIGtleSA9IE9iamVjdC5rZXlzKG9iailbMF07XG5cdCAgICByZXR1cm4gb2JqW2tleV07XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZmlyc3Qga2V5IG9mIHRoZSBvYmplY3QuXG5cdCAgICBVc2VkIHRvIGdldCBzdGFydCB2YWx1ZSBvbiDiiIZzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byBnZXQgdGhlIHZhbHVlIG9mLlxuXHQgICAgQHJldHVybnMge1N0cmluZ30gVGhlIGtleSBvZiB0aGUgZmlyc3Qgb2JqZWN0JyBwcm9wZXJ0eS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmdldERlbHRhU3RhcnQgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHZhciBrZXk7XG5cdCAgICBrZXkgPSBPYmplY3Qua2V5cyhvYmopWzBdO1xuXHQgICAgcmV0dXJuIGtleTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHByb3BlcnkgZXhpc3RzIGluIGNhbGxiYWNrc01hcCBvciB0d2Vlbk9wdGlvbk1hcC5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvclxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIHByb3BlcnR5IGlzIHR3ZWVuIHByb3BlcnR5LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuaXNUd2VlblByb3AgPSBmdW5jdGlvbihrZXlOYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpcy50d2Vlbk9wdGlvbk1hcFtrZXlOYW1lXSB8fCB0aGlzLmNhbGxiYWNrc01hcFtrZXlOYW1lXTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHN0cmluZyBwcm9wZXJ0eSB2YWx1ZVxuXHQgICAgd2hpY2ggY2FuIGluY2x1ZGUgYm90aCBgcmFuZGAgYW5kIGBzdGFnZ2VyIGBcblx0ICAgIHZhbHVlIGluIHZhcmlvdXMgcG9zaXRpb25zLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE9wdGlvbmFsIGluZGV4IGZvciBzdGFnZ2VyLlxuXHQgICAgQHJldHVybnMge051bWJlcn0gUGFyc2VkIG9wdGlvbiB2YWx1ZS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlU3RyaW5nT3B0aW9uID0gZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG5cdCAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuXHQgICAgICBpbmRleCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VJZlN0YWdnZXIodmFsdWUsIGluZGV4KTtcblx0ICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSWZSYW5kKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCB0aGUgbGFzdCBpdGVtIG9mIGFycmF5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IHRvIGdldCB0aGUgbGFzdCBpdGVtIGluLlxuXHQgICAgQHJldHVybnMge0FueX0gVGhlIGxhc3QgaXRlbSBvZiBhcnJheS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmdldExhc3RJdGVtID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHBhcnNlIEhUTUxFbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nLCBPYmplY3R9IFNlbGVjdG9yIHN0cmluZyBvciBIVE1MRWxlbWVudC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IEhUTUxFbGVtZW50LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VFbCA9IGZ1bmN0aW9uKGVsKSB7XG5cdCAgICBpZiAoaC5pc0RPTShlbCkpIHtcblx0ICAgICAgcmV0dXJuIGVsO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgPT09IG51bGwpIHtcblx0ICAgICAgaC5lcnJvcihcIkNhbid0IHBhcnNlIEhUTUwgZWxlbWVudDogXCIsIGVsKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBlbDtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvcmNlIGNvbXBvc2l0b3IgbGF5ZXIgb24gSFRNTEVsZW1lbnQuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IEhUTUxFbGVtZW50LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gSFRNTEVsZW1lbnQuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5mb3JjZTNkID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgIHRoaXMuc2V0UHJlZml4ZWRTdHlsZShlbCwgJ2JhY2tmYWNlLXZpc2liaWxpdHknLCAnaGlkZGVuJyk7XG5cdCAgICByZXR1cm4gZWw7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB2YWx1ZSBpcyBkZWx0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdG8gY2hlY2suXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdmFsdWUgaXMgZGVsdGEuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5pc0RlbHRhID0gZnVuY3Rpb24ob3B0aW9uc1ZhbHVlKSB7XG5cdCAgICB2YXIgaXNPYmplY3Q7XG5cdCAgICBpc09iamVjdCA9IHRoaXMuaXNPYmplY3Qob3B0aW9uc1ZhbHVlKTtcblx0ICAgIGlzT2JqZWN0ID0gaXNPYmplY3QgJiYgIW9wdGlvbnNWYWx1ZS51bml0O1xuXHQgICAgcmV0dXJuICEoIWlzT2JqZWN0IHx8IHRoaXMuaXNBcnJheShvcHRpb25zVmFsdWUpIHx8IHRoaXMuaXNET00ob3B0aW9uc1ZhbHVlKSk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBIZWxwZXJzO1xuXG5cdH0pKCk7XG5cblx0aCA9IG5ldyBIZWxwZXJzO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gaDtcblxuXG4vKioqLyB9KSxcbi8qIDcyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIEJpdCwgQml0c01hcCwgQ2lyY2xlLCBDcm9zcywgQ3VydmUsIEN1c3RvbSwgRXF1YWwsIExpbmUsIFBvbHlnb24sIFJlY3QsIFppZ3phZywgaDtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cblx0Q3VzdG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSlbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oODUpO1xuXG5cdENpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODYpO1xuXG5cdExpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3KTtcblxuXHRaaWd6YWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KTtcblxuXHRSZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSk7XG5cblx0UG9seWdvbiA9IF9fd2VicGFja19yZXF1aXJlX18oOTApO1xuXG5cdENyb3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG5cblx0Q3VydmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg5Mik7XG5cblx0RXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0Qml0c01hcCA9IChmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBCaXRzTWFwKCkge1xuXHQgICAgdGhpcy5hZGRTaGFwZSA9IGguYmluZCh0aGlzLmFkZFNoYXBlLCB0aGlzKTtcblx0ICB9XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5iaXQgPSBCaXQ7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5jdXN0b20gPSBDdXN0b207XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5jaXJjbGUgPSBDaXJjbGU7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5saW5lID0gTGluZTtcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLnppZ3phZyA9IFppZ3phZztcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLnJlY3QgPSBSZWN0O1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUucG9seWdvbiA9IFBvbHlnb247XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5jcm9zcyA9IENyb3NzO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuZXF1YWwgPSBFcXVhbDtcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLmN1cnZlID0gQ3VydmU7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5nZXRTaGFwZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0ICAgIHJldHVybiB0aGlzW25hbWVdIHx8IGguZXJyb3IoXCJubyBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIHNoYXBlIGF2YWlsYWJsZSB5ZXQsIHBsZWFzZSBjaG9vc2UgZnJvbSB0aGlzIGxpc3Q6XCIsIFsnY2lyY2xlJywgJ2xpbmUnLCAnemlnemFnJywgJ3JlY3QnLCAncG9seWdvbicsICdjcm9zcycsICdlcXVhbCcsICdjdXJ2ZSddKTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBzaGFwZSB0byB0aGUgbWFwLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHNoYXBlIG1vZHVsZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTaGFwZSBtb2R1bGUgY2xhc3MuXG5cdCAgICovXG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKG5hbWUsIE1vZHVsZSkge1xuXHQgICAgcmV0dXJuIHRoaXNbbmFtZV0gPSBNb2R1bGU7XG5cdCAgfTtcblxuXHQgIHJldHVybiBCaXRzTWFwO1xuXG5cdH0pKCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBuZXcgQml0c01hcDtcblxuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODQpO1xuXG5cdHZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIEJpdCA9IGZ1bmN0aW9uIChfTW9kdWxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQml0LCBfTW9kdWxlKTtcblxuXHQgIGZ1bmN0aW9uIEJpdCgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEJpdCk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBtb2R1bGUncyBkZWZhdWx0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblx0ICBCaXQucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgICducyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdCAgICAgICd0YWcnOiAnZWxsaXBzZScsXG5cdCAgICAgICdwYXJlbnQnOiBkb2N1bWVudC5ib2R5LFxuXHQgICAgICAncmF0aW8nOiAxLFxuXHQgICAgICAncmFkaXVzJzogNTAsXG5cdCAgICAgICdyYWRpdXNYJzogbnVsbCxcblx0ICAgICAgJ3JhZGl1c1knOiBudWxsLFxuXHQgICAgICAnc3Ryb2tlJzogJ2hvdHBpbmsnLFxuXHQgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcnLFxuXHQgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnJyxcblx0ICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJycsXG5cdCAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuXHQgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuXHQgICAgICAnZmlsbCc6ICd0cmFuc3BhcmVudCcsXG5cdCAgICAgICdmaWxsLW9wYWNpdHknOiAxLFxuXHQgICAgICAnd2lkdGgnOiAwLFxuXHQgICAgICAnaGVpZ2h0JzogMFxuXHQgICAgfTtcblx0ICAgIHRoaXMuX2RyYXdNYXAgPSBbJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdmaWxsJywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ2ZpbGwtb3BhY2l0eScsICd0cmFuc2Zvcm0nXTtcblx0ICB9O1xuXG5cdCAgQml0LnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgdGhpcy5fc3RhdGUgPSB7fTtcblx0ICAgIHRoaXMuX2RyYXdNYXBMZW5ndGggPSB0aGlzLl9kcmF3TWFwLmxlbmd0aDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHRoZSBzaGFwZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIGlmICh0aGlzLl9pc1JlbmRlcmVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIHNldCBgX2lzUmVuZGVyZWRgIGhhdGNoXG5cdCAgICB0aGlzLl9pc1JlbmRlcmVkID0gdHJ1ZTtcblx0ICAgIC8vIGNyZWF0ZSBgU1ZHYCBjYW52YXMgdG8gZHJhdyBpblxuXHQgICAgdGhpcy5fY3JlYXRlU1ZHQ2FudmFzKCk7XG5cdCAgICAvLyBzZXQgY2FudmFzIHNpemVcblx0ICAgIHRoaXMuX3NldENhbnZhc1NpemUoKTtcblx0ICAgIC8vIGRyYXcgdGhlIGluaXRpYWwgc3RhdGVcblx0ICAgIC8vIHRoaXMuX2RyYXcoKTtcblx0ICAgIC8vIGFwcGVuZCB0aGUgY2FudmFzIHRvIHRoZSBwYXJlbnQgZnJvbSBwcm9wc1xuXHQgICAgdGhpcy5fcHJvcHMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBgU1ZHYCBjYW52YXMgdG8gZHJhdyBpbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fY3JlYXRlU1ZHQ2FudmFzID0gZnVuY3Rpb24gX2NyZWF0ZVNWR0NhbnZhcygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBjcmVhdGUgY2FudmFzIC0gYHN2Z2AgZWxlbWVudCB0byBkcmF3IGluXG5cdCAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocC5ucywgJ3N2ZycpO1xuXHQgICAgLy8gY3JlYXRlIHRoZSBlbGVtZW50IHNoYXBlIGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgY2FudmFzXG5cdCAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHAubnMsIHAudGFnKTtcblx0ICAgIHRoaXMuX2NhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHNpemUgb2YgdGhlIF9jYW52YXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX3NldENhbnZhc1NpemUgPSBmdW5jdGlvbiBfc2V0Q2FudmFzU2l6ZSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc3R5bGUgPSB0aGlzLl9jYW52YXMuc3R5bGU7XG5cblx0ICAgIHN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHQgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdCAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdCAgICBzdHlsZS5sZWZ0ID0gJzBweCc7XG5cdCAgICBzdHlsZS50b3AgPSAnMHB4Jztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyB0aGUgc2hhcGUuXG5cdCAgICBDYWxsZWQgb24gZXZlcnkgZnJhbWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiBfZHJhdygpIHtcblx0ICAgIHRoaXMuX3Byb3BzLmxlbmd0aCA9IHRoaXMuX2dldExlbmd0aCgpO1xuXG5cdCAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZSxcblx0ICAgICAgICBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuXG5cdCAgICB2YXIgbGVuID0gdGhpcy5fZHJhd01hcExlbmd0aDtcblx0ICAgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgICB2YXIgbmFtZSA9IHRoaXMuX2RyYXdNYXBbbGVuXTtcblx0ICAgICAgc3dpdGNoIChuYW1lKSB7XG5cdCAgICAgICAgY2FzZSAnc3Ryb2tlLWRhc2hhcnJheSc6XG5cdCAgICAgICAgY2FzZSAnc3Ryb2tlLWRhc2hvZmZzZXQnOlxuXHQgICAgICAgICAgdGhpcy5jYXN0U3Ryb2tlRGFzaChuYW1lKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKG5hbWUsIHRoaXMuX3Byb3BzW25hbWVdKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3N0YXRlLnJhZGl1cyA9IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICB9O1xuXG5cdCAgQml0LnByb3RvdHlwZS5jYXN0U3Ryb2tlRGFzaCA9IGZ1bmN0aW9uIGNhc3RTdHJva2VEYXNoKG5hbWUpIHtcblx0ICAgIC8vICMgaWYgYXJyYXkgb2YgdmFsdWVzXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKF9oMi5kZWZhdWx0LmlzQXJyYXkocFtuYW1lXSkpIHtcblx0ICAgICAgdmFyIHN0cm9rZSA9ICcnO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBbbmFtZV0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZGFzaCA9IHBbbmFtZV1baV0sXG5cdCAgICAgICAgICAgIGNhc3QgPSBkYXNoLnVuaXQgPT09ICclJyA/IHRoaXMuY2FzdFBlcmNlbnQoZGFzaC52YWx1ZSkgOiBkYXNoLnZhbHVlO1xuXHQgICAgICAgIHN0cm9rZSArPSBjYXN0ICsgJyAnO1xuXHQgICAgICB9XG5cdCAgICAgIHBbbmFtZV0gPSBzdHJva2UgPT09ICcwICcgPyBzdHJva2UgPSAnJyA6IHN0cm9rZTtcblx0ICAgICAgcmV0dXJuIHBbbmFtZV0gPSBzdHJva2U7XG5cdCAgICB9XG5cdCAgICAvLyAjIGlmIHNpbmdsZSB2YWx1ZVxuXHQgICAgaWYgKCgwLCBfdHlwZW9mMy5kZWZhdWx0KShwW25hbWVdKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgc3Ryb2tlID0gcFtuYW1lXS51bml0ID09PSAnJScgPyB0aGlzLmNhc3RQZXJjZW50KHBbbmFtZV0udmFsdWUpIDogcFtuYW1lXS52YWx1ZTtcblx0ICAgICAgcFtuYW1lXSA9IHN0cm9rZSA9PT0gMCA/IHN0cm9rZSA9ICcnIDogc3Ryb2tlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBCaXQucHJvdG90eXBlLmNhc3RQZXJjZW50ID0gZnVuY3Rpb24gY2FzdFBlcmNlbnQocGVyY2VudCkge1xuXHQgICAgcmV0dXJuIHBlcmNlbnQgKiAodGhpcy5fcHJvcHMubGVuZ3RoIC8gMTAwKTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgcHJvcHMgdG8gYXR0cmlidXRlcyBhbmQgY2FjaGUgdGhlIHZhbHVlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fc2V0QXR0cklmQ2hhbmdlZCA9IGZ1bmN0aW9uIF9zZXRBdHRySWZDaGFuZ2VkKG5hbWUsIHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fc3RhdGVbbmFtZV0gIT09IHZhbHVlKSB7XG5cdCAgICAgIC8vIHRoaXMuZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHQgICAgICB0aGlzLl9zdGF0ZVtuYW1lXSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsZW5ndGggb2YgdGhlIHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IExlbmd0aCBvZiB0aGUgc2hhcGUuXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24gX2dldExlbmd0aCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgbGVuID0gMCxcblx0ICAgICAgICBpc0dldExlbmd0aCA9ICEhKHRoaXMuZWwgJiYgdGhpcy5lbC5nZXRUb3RhbExlbmd0aCk7XG5cblx0ICAgIGlmIChpc0dldExlbmd0aCAmJiB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZCcpKSB7XG5cdCAgICAgIGxlbiA9IHRoaXMuZWwuZ2V0VG90YWxMZW5ndGgoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxlbiA9IDIgKiAocC5yYWRpdXNYICE9IG51bGwgPyBwLnJhZGl1c1ggOiBwLnJhZGl1cyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGVuO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgdG90YWwgc3VtIGJldHdlZW4gcG9pbnRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIHBvaW50cy5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IERpc3RhbmNlIGJld3R3ZWVuIGFsbCBwb2ludHMuXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fZ2V0UG9pbnRzUGVyaW1pdGVyID0gZnVuY3Rpb24gX2dldFBvaW50c1BlcmltaXRlcihwb2ludHMpIHtcblx0ICAgIHZhciBzdW0gPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdW0gKz0gdGhpcy5fcG9pbnRzRGVsdGEocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcblx0ICAgIH1cblxuXHQgICAgc3VtICs9IHRoaXMuX3BvaW50c0RlbHRhKHBvaW50c1swXSwgX2gyLmRlZmF1bHQuZ2V0TGFzdEl0ZW0ocG9pbnRzKSk7XG5cdCAgICByZXR1cm4gc3VtO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZGVsdGEgZnJvbSB0d28gcG9pbnRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBQb2ludCAxLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFBvaW50IDIuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb29pbnRzLlxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX3BvaW50c0RlbHRhID0gZnVuY3Rpb24gX3BvaW50c0RlbHRhKHBvaW50MSwgcG9pbnQyKSB7XG5cdCAgICB2YXIgZHggPSBNYXRoLmFicyhwb2ludDEueCAtIHBvaW50Mi54KSxcblx0ICAgICAgICBkeSA9IE1hdGguYWJzKHBvaW50MS55IC0gcG9pbnQyLnkpO1xuXHQgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBtb2R1bGUncyBzaXplLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBNb2R1bGUgd2lkdGguXG5cdCAgICBAcGFyYW0ge051bWJlcn0gTW9kdWxlIGhlaWdodC5cblx0ICAqL1xuXG5cblx0ICBCaXQucHJvdG90eXBlLl9zZXRTaXplID0gZnVuY3Rpb24gX3NldFNpemUod2lkdGgsIGhlaWdodCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHAud2lkdGggPSB3aWR0aDtcblx0ICAgIHAuaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgdGhpcy5fZHJhdygpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQml0O1xuXHR9KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEJpdDtcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuXHQgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG5cdCAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuXHQgIH1cblx0fTtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG5cdCAgaWYgKCFzZWxmKSB7XG5cdCAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc3KTtcblxuXHR2YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxuXHR2YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oODEpO1xuXG5cdHZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuXHQgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuXHQgIH1cblxuXHQgIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG5cdCAgICBjb25zdHJ1Y3Rvcjoge1xuXHQgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG5cdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oNzgpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxuXHR2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHQkZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtzZXRQcm90b3R5cGVPZjogX193ZWJwYWNrX3JlcXVpcmVfXyg4MCkuc2V0fSk7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cblx0LyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblx0dmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMClcblx0ICAsIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdHZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcblx0ICBhbk9iamVjdChPKTtcblx0ICBpZighaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKXRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcblx0fTtcblx0bW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHQgICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgc2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSkoRnVuY3Rpb24uY2FsbCwgX193ZWJwYWNrX3JlcXVpcmVfXyg2NykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcblx0ICAgICAgICBzZXQodGVzdCwgW10pO1xuXHQgICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuXHQgICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKXtcblx0ICAgICAgICBjaGVjayhPLCBwcm90byk7XG5cdCAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcblx0ICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG5cdCAgICAgICAgcmV0dXJuIE87XG5cdCAgICAgIH07XG5cdCAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuXHQgIGNoZWNrOiBjaGVja1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG5cdHZhciAkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuT2JqZWN0O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcblx0ICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG5cdH07XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpXG5cdC8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuXHQkZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IF9fd2VicGFja19yZXF1aXJlX18oMzEpfSk7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXG5cdCAgQmFzZSBjbGFzcyBmb3IgbW9kdWxlLiBFeHRlbmRzIGFuZCBwYXJzZXMgZGVmYXVsdHMuXG5cdCovXG5cdHZhciBNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gTW9kdWxlKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgTW9kdWxlKTtcblxuXHQgICAgLy8gdGhpcy5faXNJdCA9IG8uaXNJdDtcblx0ICAgIC8vIGRlbGV0ZSBvLmlzSXQ7XG5cdCAgICB0aGlzLl9vID0gbztcblx0ICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fby5pbmRleCB8fCAwO1xuXHQgICAgLy8gbWFwIG9mIHByb3BzIHRoYXQgc2hvdWxkIGJlXG5cdCAgICAvLyBwYXJzZWQgdG8gYXJyYXlzIG9mIHZhbHVlc1xuXHQgICAgdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCA9IHtcblx0ICAgICAgc3Ryb2tlRGFzaG9mZnNldDogMSxcblx0ICAgICAgc3Ryb2tlRGFzaGFycmF5OiAxLFxuXHQgICAgICBvcmlnaW46IDFcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuX3NraXBQcm9wc0RlbHRhID0ge1xuXHQgICAgICB0aW1lbGluZTogMSxcblx0ICAgICAgcHJldkNoYWluTW9kdWxlOiAxLFxuXHQgICAgICBjYWxsYmFja3NDb250ZXh0OiAxXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9kZWNsYXJlRGVmYXVsdHMoKTtcblx0ICAgIHRoaXMuX2V4dGVuZERlZmF1bHRzKCk7XG5cblx0ICAgIHRoaXMuX3ZhcnMoKTtcblx0ICAgIHRoaXMuX3JlbmRlcigpO1xuXHQgIH1cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICB0aGlzLl9kZWZhdWx0cyA9IHt9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIG1vZHVsZSdzIHZhcmlhYmxlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuXHQgICAgdGhpcy5fc3Ryb2tlRGFzaGFycmF5QnVmZmVyID0gW107XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlbmRlciBvbiBpbml0aWFsaXphdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHt9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHByb3BlcnR5IG9uIHRoZSBtb2R1bGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmcsIE9iamVjdH0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7QW55fSBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5IHRvIHNldC4gQ291bGQgYmVcblx0ICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIGlmIHRoZSBmaXJzdCBwYXJhbSBpcyBvYmplY3QuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fc2V0UHJvcCA9IGZ1bmN0aW9uIF9zZXRQcm9wKGF0dHIsIHZhbHVlKSB7XG5cdCAgICBpZiAoKHR5cGVvZiBhdHRyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGF0dHIpKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgZm9yICh2YXIga2V5IGluIGF0dHIpIHtcblx0ICAgICAgICB0aGlzLl9hc3NpZ25Qcm9wKGtleSwgYXR0cltrZXldKTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fYXNzaWduUHJvcChhdHRyLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFzc2lnbiBzaW5nbGUgcHJvcGVydHkncyB2YWx1ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9hc3NpZ25Qcm9wID0gZnVuY3Rpb24gX2Fzc2lnblByb3Aoa2V5LCB2YWx1ZSkge1xuXHQgICAgdGhpcy5fcHJvcHNba2V5XSA9IHZhbHVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzaG93IGVsZW1lbnQuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3Nob3cgPSBmdW5jdGlvbiBfc2hvdygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAoIXRoaXMuZWwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocC5pc1NvZnRIaWRlKSB7XG5cdCAgICAgIC8vIHRoaXMuZWwuc3R5bGUub3BhY2l0eSA9IHAub3BhY2l0eTtcblx0ICAgICAgdGhpcy5fc2hvd0J5VHJhbnNmb3JtKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaGlkZSBlbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24gX2hpZGUoKSB7XG5cdCAgICBpZiAoIXRoaXMuZWwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fcHJvcHMuaXNTb2Z0SGlkZSkge1xuXHQgICAgICAvLyB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAwO1xuXHQgICAgICBfaDIuZGVmYXVsdC5zZXRQcmVmaXhlZFN0eWxlKHRoaXMuZWwsICd0cmFuc2Zvcm0nLCAnc2NhbGUoMCknKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzaG93IGVsZW1lbnQgYnkgYXBwbHlpbmcgdHJhbnNmb3JtIGJhY2sgdG8gbm9ybWFsLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9zaG93QnlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2hvd0J5VHJhbnNmb3JtKCkge307XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBvcHRpb24gc3RyaW5nLlxuXHQgICAgU2VhcmNoZXMgZm9yIHN0YWdnZXIgYW5kIHJhbmQgdmFsdWVzIGFuZCBwYXJzZXMgdGhlbS5cblx0ICAgIExlYXZlcyB0aGUgdmFsdWUgdW5hdHRlbmRlZCBvdGhlcndpc2UuXG5cdCAgICBAcGFyYW0ge0FueX0gT3B0aW9uIHZhbHVlIHRvIHBhcnNlLlxuXHQgICAgQHJldHVybnMge051bWJlcn0gUGFyc2VkIG9wdGlvbnMgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcGFyc2VPcHRpb25TdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VPcHRpb25TdHJpbmcodmFsdWUpIHtcblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmICh2YWx1ZS5tYXRjaCgvc3RhZ2dlci8pKSB7XG5cdCAgICAgICAgdmFsdWUgPSBfaDIuZGVmYXVsdC5wYXJzZVN0YWdnZXIodmFsdWUsIHRoaXMuX2luZGV4KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgaWYgKHZhbHVlLm1hdGNoKC9yYW5kLykpIHtcblx0ICAgICAgICB2YWx1ZSA9IF9oMi5kZWZhdWx0LnBhcnNlUmFuZCh2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgcG9zdGlvbiBvcHRpb24uXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBQcm9wZXJ0eSBWYWx1ZS5cblx0ICAgIEByZXR1cm5zIHtTdHJpbmd9IFBhcnNlZCBvcHRpb25zIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlUG9zaXRpb25PcHRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbk9wdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICBpZiAoX2gyLmRlZmF1bHQudW5pdE9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgIHZhbHVlID0gX2gyLmRlZmF1bHQucGFyc2VVbml0KHZhbHVlKS5zdHJpbmc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHN0cm9rZURhc2guLiBvcHRpb24uXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtTdHJpbmd9IFBhcnNlZCBvcHRpb25zIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlU3Ryb2tlRGFzaE9wdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVN0cm9rZURhc2hPcHRpb24oa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuXHQgICAgLy8gcGFyc2UgbnVtZXJpYy9wZXJjZW50IHZhbHVlcyBmb3Igc3Ryb2tlRGFzaC4uIHByb3BlcnRpZXNcblx0ICAgIGlmICh0aGlzLl9hcnJheVByb3BlcnR5TWFwW2tleV0pIHtcblx0ICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KSh2YWx1ZSkpIHtcblx0ICAgICAgICBjYXNlICdudW1iZXInOlxuXHQgICAgICAgICAgcmVzdWx0LnB1c2goX2gyLmRlZmF1bHQucGFyc2VVbml0KHZhbHVlKSk7XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlICdzdHJpbmcnOlxuXHQgICAgICAgICAgdmFyIGFycmF5ID0gdmFsdWUuc3BsaXQoJyAnKTtcblx0ICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goX2gyLmRlZmF1bHQucGFyc2VVbml0KGFycmF5W2ldKSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIHByb3BlcnR5IGlzIGRlbHRhIHByb3BlcnR5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QW55fSBQYXJhbWV0ZXIgdmFsdWUgdG8gY2hlY2suXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9pc0RlbHRhID0gZnVuY3Rpb24gX2lzRGVsdGEob3B0aW9uc1ZhbHVlKSB7XG5cdCAgICB2YXIgaXNPYmplY3QgPSBfaDIuZGVmYXVsdC5pc09iamVjdChvcHRpb25zVmFsdWUpO1xuXHQgICAgaXNPYmplY3QgPSBpc09iamVjdCAmJiAhb3B0aW9uc1ZhbHVlLnVuaXQ7XG5cdCAgICByZXR1cm4gISghaXNPYmplY3QgfHwgX2gyLmRlZmF1bHQuaXNBcnJheShvcHRpb25zVmFsdWUpIHx8IF9oMi5kZWZhdWx0LmlzRE9NKG9wdGlvbnNWYWx1ZSkpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZGVsdGEgZnJvbSBwcm9wZXJ0eSBhbmQgc2V0XG5cdCAgICB0aGUgcHJvcGVydHkncyBzdGFydCB2YWx1ZSB0byB0aGUgcHJvcHMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBLZXkgbmFtZSB0byBnZXQgZGVsdGEgZm9yLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbiB2YWx1ZSB0byBnZXQgdGhlIGRlbHRhIGZvci5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9nZXREZWx0YSA9IGZ1bmN0aW9uIF9nZXREZWx0YShrZXksIG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGRlbHRhO1xuXHQgICAgaWYgKChrZXkgPT09ICdsZWZ0JyB8fCBrZXkgPT09ICd0b3AnKSAmJiAhdGhpcy5fby5jdHgpIHtcblx0ICAgICAgX2gyLmRlZmF1bHQud2FybignQ29uc2lkZXIgdG8gYW5pbWF0ZSB4L3kgcHJvcGVydGllcyBpbnN0ZWFkIG9mIGxlZnQvdG9wLFxcbiAgICAgICAgYXMgaXQgd291bGQgYmUgbXVjaCBtb3JlIHBlcmZvcm1hbnQnLCBvcHRpb25zVmFsdWUpO1xuXHQgICAgfVxuXHQgICAgLy8gc2tpcCBkZWx0YSBjYWxjdWxhdGlvbiBmb3IgYSBwcm9wZXJ0eSBpZiBpdCBpcyBsaXN0ZWRcblx0ICAgIC8vIGluIHNraXBQcm9wc0RlbHRhIG9iamVjdFxuXHQgICAgaWYgKHRoaXMuX3NraXBQcm9wc0RlbHRhICYmIHRoaXMuX3NraXBQcm9wc0RlbHRhW2tleV0pIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgLy8gZ2V0IGRlbHRhXG5cdCAgICBkZWx0YSA9IF9oMi5kZWZhdWx0LnBhcnNlRGVsdGEoa2V5LCBvcHRpb25zVmFsdWUsIHRoaXMuX2luZGV4KTtcblx0ICAgIC8vIGlmIHN1Y2Nlc3NmdWxseSBwYXJzZWQgLSBzYXZlIGl0XG5cdCAgICBpZiAoZGVsdGEudHlwZSAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX2RlbHRhc1trZXldID0gZGVsdGE7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkZWx0YUVuZCA9ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShkZWx0YS5lbmQpID09PSAnb2JqZWN0JyA/IGRlbHRhLmVuZC52YWx1ZSA9PT0gMCA/IDAgOiBkZWx0YS5lbmQuc3RyaW5nIDogZGVsdGEuZW5kO1xuXHQgICAgLy8gc2V0IHByb3BzIHRvIGVuZCB2YWx1ZSBvZiB0aGUgZGVsdGFcblx0ICAgIC8vIDAgc2hvdWxkIGJlIDAgcmVnYXJkbGVzcyB1bml0c1xuXHQgICAgdGhpcy5fcHJvcHNba2V5XSA9IGRlbHRhRW5kO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjb3B5IGBfb2Agb3B0aW9ucyB0byBgX3Byb3BzYCBvYmplY3Rcblx0ICAgIHdpdGggZmFsbGJhY2sgdG8gYF9kZWZhdWx0c2AuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX2V4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24gX2V4dGVuZERlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fcHJvcHMgPSB7fTtcblx0ICAgIHRoaXMuX2RlbHRhcyA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdCAgICAgIC8vIHNraXAgcHJvcGVydHkgaWYgaXQgaXMgbGlzdGVkIGluIF9za2lwUHJvcHNcblx0ICAgICAgLy8gaWYgKHRoaXMuX3NraXBQcm9wcyAmJiB0aGlzLl9za2lwUHJvcHNba2V5XSkgeyBjb250aW51ZTsgfVxuXHQgICAgICAvLyBjb3B5IHRoZSBwcm9wZXJ0aWVzIHRvIHRoZSBfbyBvYmplY3Rcblx0ICAgICAgdmFyIHZhbHVlID0gdGhpcy5fb1trZXldICE9IG51bGwgPyB0aGlzLl9vW2tleV0gOiB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHQgICAgICAvLyBwYXJzZSBvcHRpb25cblx0ICAgICAgdGhpcy5fcGFyc2VPcHRpb24oa2V5LCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHR1bmUgbmV3IG9wcmlvbnMgdG8gX28gYW5kIF9wcm9wcyBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0IHRvIHR1bmUgdG8uXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fdHVuZU5ld09wdGlvbnMgPSBmdW5jdGlvbiBfdHVuZU5ld09wdGlvbnMobykge1xuXHQgICAgLy8gaGlkZSB0aGUgbW9kdWxlIGJlZm9yZSB0dW5pbmcgaXQncyBvcHRpb25zXG5cdCAgICAvLyBjdXogdGhlIHVzZXIgY291bGQgc2VlIHRoZSBjaGFuZ2Vcblx0ICAgIHRoaXMuX2hpZGUoKTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG5cdCAgICAgIC8vIHNraXAgcHJvcGVydHkgaWYgaXQgaXMgbGlzdGVkIGluIF9za2lwUHJvcHNcblx0ICAgICAgLy8gaWYgKHRoaXMuX3NraXBQcm9wcyAmJiB0aGlzLl9za2lwUHJvcHNba2V5XSkgeyBjb250aW51ZTsgfVxuXHQgICAgICAvLyBjb3B5IHRoZSBwcm9wZXJ0aWVzIHRvIHRoZSBfbyBvYmplY3Rcblx0ICAgICAgLy8gZGVsZXRlIHRoZSBrZXkgZnJvbSBkZWx0YXNcblx0ICAgICAgbyAmJiBkZWxldGUgdGhpcy5fZGVsdGFzW2tleV07XG5cdCAgICAgIC8vIHJld3JpdGUgX28gcmVjb3JkXG5cdCAgICAgIHRoaXMuX29ba2V5XSA9IG9ba2V5XTtcblx0ICAgICAgLy8gc2F2ZSB0aGUgb3B0aW9ucyB0byBfcHJvcHNcblx0ICAgICAgdGhpcy5fcGFyc2VPcHRpb24oa2V5LCBvW2tleV0pO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBvcHRpb24gdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE9wdGlvbiBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9IE9wdGlvbiB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZU9wdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZU9wdGlvbihuYW1lLCB2YWx1ZSkge1xuXHQgICAgLy8gaWYgZGVsdGEgcHJvcGVydHlcblx0ICAgIGlmICh0aGlzLl9pc0RlbHRhKHZhbHVlKSAmJiAhdGhpcy5fc2tpcFByb3BzRGVsdGFbbmFtZV0pIHtcblx0ICAgICAgdGhpcy5fZ2V0RGVsdGEobmFtZSwgdmFsdWUpO1xuXHQgICAgICB2YXIgZGVsdGFFbmQgPSBfaDIuZGVmYXVsdC5nZXREZWx0YUVuZCh2YWx1ZSk7XG5cdCAgICAgIHJldHVybiB0aGlzLl9hc3NpZ25Qcm9wKG5hbWUsIHRoaXMuX3BhcnNlUHJvcGVydHkobmFtZSwgZGVsdGFFbmQpKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fYXNzaWduUHJvcChuYW1lLCB0aGlzLl9wYXJzZVByb3BlcnR5KG5hbWUsIHZhbHVlKSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHBvc3Rpb24gYW5kIHN0cmluZyBwcm9wcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtBbnl9ICBQYXJzZWQgcHJvcGVydHkgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcGFyc2VQcmVBcnJheVByb3BlcnR5ID0gZnVuY3Rpb24gX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuXHQgICAgLy8gcGFyc2Ugc3RhZ2dlciBhbmQgcmFuZCB2YWx1ZXNcblx0ICAgIHZhbHVlID0gdGhpcy5fcGFyc2VPcHRpb25TdHJpbmcodmFsdWUpO1xuXHQgICAgLy8gcGFyc2UgdW5pdHMgZm9yIHBvc2l0aW9uIHByb3BlcnRpZXNcblx0ICAgIHJldHVybiB0aGlzLl9wYXJzZVBvc2l0aW9uT3B0aW9uKG5hbWUsIHZhbHVlKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgcHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7QW55fSAgUGFyc2VkIHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHkgPSBmdW5jdGlvbiBfcGFyc2VQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuXHQgICAgLy8gcGFyc2UgYEhUTUxgIGVsZW1lbnQgaW4gYHBhcmVudGAgb3B0aW9uXG5cdCAgICBpZiAobmFtZSA9PT0gJ3BhcmVudCcpIHtcblx0ICAgICAgcmV0dXJuIF9oMi5kZWZhdWx0LnBhcnNlRWwodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgLy8gcGFyc2UgYHN0YWdnZXJgLCBgcmFuZGAgYW5kIGBwb3NpdGlvbmBcblx0ICAgIHZhbHVlID0gdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KG5hbWUsIHZhbHVlKTtcblx0ICAgIC8vIHBhcnNlIG51bWVyaWMvcGVyY2VudCB2YWx1ZXMgZm9yIHN0cm9rZURhc2guLiBwcm9wZXJ0aWVzXG5cdCAgICByZXR1cm4gdGhpcy5fcGFyc2VTdHJva2VEYXNoT3B0aW9uKG5hbWUsIHZhbHVlKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgdmFsdWVzIGluc2lkZSDiiIYuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IEtleSBuYW1lLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gRGVsdGEgd2l0aCBwYXJzZWQgcGFyYW1ldGVycy5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZURlbHRhVmFsdWVzID0gZnVuY3Rpb24gX3BhcnNlRGVsdGFWYWx1ZXMobmFtZSwgZGVsdGEpIHtcblx0ICAgIC8vIHJldHVybiBoLnBhcnNlRGVsdGEoIG5hbWUsIGRlbHRhLCB0aGlzLl9pbmRleCApO1xuXG5cdCAgICB2YXIgZCA9IHt9O1xuXHQgICAgZm9yICh2YXIga2V5IGluIGRlbHRhKSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGRlbHRhW2tleV07XG5cblx0ICAgICAgLy8gZGVsZXRlIGRlbHRhW2tleV07XG5cdCAgICAgIC8vIGFkZCBwYXJzZWQgcHJvcGVydGllc1xuXHQgICAgICB2YXIgbmV3RW5kID0gdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KG5hbWUsIHZhbHVlKTtcblx0ICAgICAgZFt0aGlzLl9wYXJzZVByZUFycmF5UHJvcGVydHkobmFtZSwga2V5KV0gPSBuZXdFbmQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgZGVsdGEgYW5kIG5vbmRlbHRhIHByb3BlcnRpZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7QW55fSAgUGFyc2VkIHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3ByZXBhcnNlUHJvcFZhbHVlID0gZnVuY3Rpb24gX3ByZXBhcnNlUHJvcFZhbHVlKGtleSwgdmFsdWUpIHtcblx0ICAgIHJldHVybiB0aGlzLl9pc0RlbHRhKHZhbHVlKSA/IHRoaXMuX3BhcnNlRGVsdGFWYWx1ZXMoa2V5LCB2YWx1ZSkgOiB0aGlzLl9wYXJzZVByZUFycmF5UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBkZWx0YXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEVhc2VkIHByb2dyZXNzIHRvIGNhbGN1bGF0ZSAtIFswLi4xXS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcm9ncmVzcyB0byBjYWxjdWxhdGUgLSBbMC4uMV0uXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fY2FsY0N1cnJlbnRQcm9wcyA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHApIHtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2RlbHRhcykge1xuXG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2RlbHRhc1trZXldO1xuXG5cdCAgICAgIC8vIGdldCBlYXNlZCBwcm9ncmVzcyBmcm9tIGRlbHRhIGVhc2luZyBpZiBkZWZpbmVkIGFuZCBub3QgY3VydmVcblx0ICAgICAgdmFyIGlzQ3VydmUgPSAhIXZhbHVlLmN1cnZlO1xuXHQgICAgICB2YXIgZXAgPSB2YWx1ZS5lYXNpbmcgIT0gbnVsbCAmJiAhaXNDdXJ2ZSA/IHZhbHVlLmVhc2luZyhwKSA6IGVhc2VkUHJvZ3Jlc3M7XG5cblx0ICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdhcnJheScpIHtcblx0ICAgICAgICB2YXIgYXJyO1xuXHQgICAgICAgIC8vIGlmIHByb3AgcHJvcGVydHkgaXMgYXJyYXkgLSByZXVzZSBpdCBlbHNlIC0gY3JlYXRlIGFuIGFycmF5XG5cdCAgICAgICAgaWYgKF9oMi5kZWZhdWx0LmlzQXJyYXkodGhpcy5fcHJvcHNba2V5XSkpIHtcblx0ICAgICAgICAgIGFyciA9IHRoaXMuX3Byb3BzW2tleV07XG5cdCAgICAgICAgICBhcnIubGVuZ3RoID0gMDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgYXJyID0gW107XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8ganVzdCBvcHRpbWl6YXRpb24gdG8gcHJldmVudCBjdXJ2ZVxuXHQgICAgICAgIC8vIGNhbGN1bGF0aW9ucyBvbiBldmVyeSBhcnJheSBpdGVtXG5cdCAgICAgICAgdmFyIHByb2MgPSBpc0N1cnZlID8gdmFsdWUuY3VydmUocCkgOiBudWxsO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5kZWx0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdmFyIGl0ZW0gPSB2YWx1ZS5kZWx0YVtpXSxcblx0ICAgICAgICAgICAgICBkYXNoID0gIWlzQ3VydmUgPyB2YWx1ZS5zdGFydFtpXS52YWx1ZSArIGVwICogaXRlbS52YWx1ZSA6IHByb2MgKiAodmFsdWUuc3RhcnRbaV0udmFsdWUgKyBwICogaXRlbS52YWx1ZSk7XG5cdCAgICAgICAgICBhcnIucHVzaCh7XG5cdCAgICAgICAgICAgIHN0cmluZzogJycgKyBkYXNoICsgaXRlbS51bml0LFxuXHQgICAgICAgICAgICB2YWx1ZTogZGFzaCxcblx0ICAgICAgICAgICAgdW5pdDogaXRlbS51bml0XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gYXJyO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdCAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9ICFpc0N1cnZlID8gdmFsdWUuc3RhcnQgKyBlcCAqIHZhbHVlLmRlbHRhIDogdmFsdWUuY3VydmUocCkgKiAodmFsdWUuc3RhcnQgKyBwICogdmFsdWUuZGVsdGEpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICd1bml0Jykge1xuXHQgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSAhaXNDdXJ2ZSA/IHZhbHVlLnN0YXJ0LnZhbHVlICsgZXAgKiB2YWx1ZS5kZWx0YSA6IHZhbHVlLmN1cnZlKHApICogKHZhbHVlLnN0YXJ0LnZhbHVlICsgcCAqIHZhbHVlLmRlbHRhKTtcblxuXHQgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSAnJyArIGN1cnJlbnRWYWx1ZSArIHZhbHVlLmVuZC51bml0O1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdjb2xvcicpIHtcblx0ICAgICAgICB2YXIgciwgZywgYiwgYTtcblx0ICAgICAgICBpZiAoIWlzQ3VydmUpIHtcblx0ICAgICAgICAgIHIgPSBwYXJzZUludCh2YWx1ZS5zdGFydC5yICsgZXAgKiB2YWx1ZS5kZWx0YS5yLCAxMCk7XG5cdCAgICAgICAgICBnID0gcGFyc2VJbnQodmFsdWUuc3RhcnQuZyArIGVwICogdmFsdWUuZGVsdGEuZywgMTApO1xuXHQgICAgICAgICAgYiA9IHBhcnNlSW50KHZhbHVlLnN0YXJ0LmIgKyBlcCAqIHZhbHVlLmRlbHRhLmIsIDEwKTtcblx0ICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KHZhbHVlLnN0YXJ0LmEgKyBlcCAqIHZhbHVlLmRlbHRhLmEpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgY3AgPSB2YWx1ZS5jdXJ2ZShwKTtcblx0ICAgICAgICAgIHIgPSBwYXJzZUludChjcCAqICh2YWx1ZS5zdGFydC5yICsgcCAqIHZhbHVlLmRlbHRhLnIpLCAxMCk7XG5cdCAgICAgICAgICBnID0gcGFyc2VJbnQoY3AgKiAodmFsdWUuc3RhcnQuZyArIHAgKiB2YWx1ZS5kZWx0YS5nKSwgMTApO1xuXHQgICAgICAgICAgYiA9IHBhcnNlSW50KGNwICogKHZhbHVlLnN0YXJ0LmIgKyBwICogdmFsdWUuZGVsdGEuYiksIDEwKTtcblx0ICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KGNwICogKHZhbHVlLnN0YXJ0LmEgKyBwICogdmFsdWUuZGVsdGEuYSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIGN1cnJlbnQgcHJvZ3Jlc3MgYW5kIHByb2JhYmx5IGRyYXcgaXQgaW4gY2hpbGRyZW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEVhc2VkIHByb2dyZXNzIHRvIHNldCAtIFswLi4xXS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcm9ncmVzcyB0byBzZXQgLSBbMC4uMV0uXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBfc2V0UHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcywgcHJvZ3Jlc3MpIHtcblx0ICAgIHRoaXMuX3Byb2dyZXNzID0gZWFzZWRQcm9ncmVzcztcblx0ICAgIHRoaXMuX2NhbGNDdXJyZW50UHJvcHMoZWFzZWRQcm9ncmVzcywgcHJvZ3Jlc3MpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gTW9kdWxlO1xuXHR9KCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gTW9kdWxlO1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9iaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHR2YXIgX2JpdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaXQpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIEN1c3RvbSA9IGZ1bmN0aW9uIChfQml0KSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQ3VzdG9tLCBfQml0KTtcblxuXHQgIGZ1bmN0aW9uIEN1c3RvbSgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEN1c3RvbSk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfQml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBtb2R1bGUncyBkZWZhdWx0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgKi9cblx0ICBDdXN0b20ucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgX0JpdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXG5cdCAgICB0aGlzLl9kZWZhdWx0cy50YWcgPSAncGF0aCc7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5wYXJlbnQgPSBudWxsO1xuXG5cdCAgICAvLyByZW1vdmUgYHN0cm9rZS13aWR0aGAgZnJvbSBgX2RyYXdNYXBgXG5cdCAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gcmVjYWwgc3Ryb2tlV2lkdGggc2l6ZSByZWdhcmRpbmcgc2NhbGVcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZHJhd01hcC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodGhpcy5fZHJhd01hcFtpXSA9PT0gJ3N0cm9rZS13aWR0aCcpIHtcblx0ICAgICAgICB0aGlzLl9kcmF3TWFwLnNwbGljZShpLCAxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgc2hhcGUgdG8gc2V0IG9uIG1vZHVsZSdzIHBhdGguXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBFbXB0eSBzdHJpbmcuXG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5nZXRTaGFwZSA9IGZ1bmN0aW9uIGdldFNoYXBlKCkge1xuXHQgICAgcmV0dXJuICcnO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgc2hhcGUgcGVyaW1ldGVyIGxlbmd0aC5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IERlZmF1bHQgbGVuZ3RoIHN0cmluZy5cblx0ICAqL1xuXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcblx0ICAgIHJldHVybiAxMDA7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgdGhlIHNoYXBlLlxuXHQgICAgQ2FsbGVkIG9uIGV2ZXJ5IGZyYW1lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAqL1xuXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHN0YXRlID0gdGhpcy5fc3RhdGUsXG5cdCAgICAgICAgcmFkaXVzWENoYW5nZSA9IHN0YXRlWydyYWRpdXNYJ10gIT09IHAucmFkaXVzWCxcblx0ICAgICAgICByYWRpdXNZQ2hhbmdlID0gc3RhdGVbJ3JhZGl1c1knXSAhPT0gcC5yYWRpdXNZLFxuXHQgICAgICAgIHJhZGl1c0NoYW5nZSA9IHN0YXRlWydyYWRpdXMnXSAhPT0gcC5yYWRpdXM7XG5cblx0ICAgIC8vIHVwZGF0ZSB0cmFuc2Zvcm0gb25seSBpZiBvbmUgb2YgcmFkaXVzZXMgY2hhbmdlZFxuXHQgICAgaWYgKHJhZGl1c1hDaGFuZ2UgfHwgcmFkaXVzWUNoYW5nZSB8fCByYWRpdXNDaGFuZ2UpIHtcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHRoaXMuX2dldFNjYWxlKCkpO1xuXHQgICAgICBzdGF0ZVsncmFkaXVzWCddID0gcC5yYWRpdXNYO1xuXHQgICAgICBzdGF0ZVsncmFkaXVzWSddID0gcC5yYWRpdXNZO1xuXHQgICAgICBzdGF0ZVsncmFkaXVzJ10gPSBwLnJhZGl1cztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgnc3Ryb2tlLXdpZHRoJywgcFsnc3Ryb2tlLXdpZHRoJ10gLyBwLm1heFNjYWxlKTtcblxuXHQgICAgX0JpdC5wcm90b3R5cGUuX2RyYXcuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHRoZSBzaGFwZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIGlmICh0aGlzLl9pc1JlbmRlcmVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzUmVuZGVyZWQgPSB0cnVlO1xuXG5cdCAgICB0aGlzLl9sZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcC5wYXJlbnQuaW5uZXJIVE1MID0gJzxzdmcgaWQ9XCJqcy1tb2pzLXNoYXBlLWNhbnZhc1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIj48ZyBpZD1cImpzLW1vanMtc2hhcGUtZWxcIj4nICsgdGhpcy5nZXRTaGFwZSgpICsgJzwvZz48L3N2Zz4nO1xuXG5cdCAgICB0aGlzLl9jYW52YXMgPSBwLnBhcmVudC5xdWVyeVNlbGVjdG9yKCcjanMtbW9qcy1zaGFwZS1jYW52YXMnKTtcblx0ICAgIHRoaXMuZWwgPSBwLnBhcmVudC5xdWVyeVNlbGVjdG9yKCcjanMtbW9qcy1zaGFwZS1lbCcpO1xuXHQgICAgdGhpcy5fc2V0Q2FudmFzU2l6ZSgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgc2NhbGVzIGZvciB0aGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG11dGF0ZXMgQHByb3BzXG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fZ2V0U2NhbGUgPSBmdW5jdGlvbiBfZ2V0U2NhbGUoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHJhZGl1c1ggPSBwLnJhZGl1c1ggPyBwLnJhZGl1c1ggOiBwLnJhZGl1cyxcblx0ICAgICAgICByYWRpdXNZID0gcC5yYWRpdXNZID8gcC5yYWRpdXNZIDogcC5yYWRpdXM7XG5cblx0ICAgIHAuc2NhbGVYID0gMiAqIHJhZGl1c1ggLyAxMDA7XG5cdCAgICBwLnNjYWxlWSA9IDIgKiByYWRpdXNZIC8gMTAwO1xuXHQgICAgcC5tYXhTY2FsZSA9IE1hdGgubWF4KHAuc2NhbGVYLCBwLnNjYWxlWSk7XG5cblx0ICAgIHAuc2hpZnRYID0gcC53aWR0aCAvIDIgLSA1MCAqIHAuc2NhbGVYO1xuXHQgICAgcC5zaGlmdFkgPSBwLmhlaWdodCAvIDIgLSA1MCAqIHAuc2NhbGVZO1xuXG5cdCAgICB2YXIgdHJhbnNsYXRlID0gJ3RyYW5zbGF0ZSgnICsgcC5zaGlmdFggKyAnLCAnICsgcC5zaGlmdFkgKyAnKSc7XG5cdCAgICByZXR1cm4gdHJhbnNsYXRlICsgJyBzY2FsZSgnICsgcC5zY2FsZVggKyAnLCAnICsgcC5zY2FsZVkgKyAnKSc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxlbmd0aCBvZiB0aGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge051bWJlcn0gTGVuZ3RoIG9mIHRoZSBzaGFwZS5cblx0ICAqL1xuXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbiBfZ2V0TGVuZ3RoKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEN1c3RvbTtcblx0fShfYml0Mi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBDdXN0b207XG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIEJpdCwgQ2lyY2xlLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MylbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5cdENpcmNsZSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKENpcmNsZSwgc3VwZXJDbGFzcyk7XG5cblx0ICBmdW5jdGlvbiBDaXJjbGUoKSB7XG5cdCAgICByZXR1cm4gQ2lyY2xlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIENpcmNsZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgQ2lyY2xlLl9fc3VwZXJfXy5fZGVjbGFyZURlZmF1bHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHMuc2hhcGUgPSAnZWxsaXBzZSc7XG5cdCAgfTtcblxuXHQgIENpcmNsZS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByeCwgcnk7XG5cdCAgICByeCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByeSA9IHRoaXMuX3Byb3BzLnJhZGl1c1kgIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1kgOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdyeCcsIHJ4KTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3J5JywgcnkpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgnY3gnLCB0aGlzLl9wcm9wcy53aWR0aCAvIDIpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgnY3knLCB0aGlzLl9wcm9wcy5oZWlnaHQgLyAyKTtcblx0ICAgIHJldHVybiBDaXJjbGUuX19zdXBlcl9fLl9kcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfTtcblxuXHQgIENpcmNsZS5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJhZGl1c1gsIHJhZGl1c1k7XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmV0dXJuIDIgKiBNYXRoLlBJICogTWF0aC5zcXJ0KChyYWRpdXNYICogcmFkaXVzWCArIHJhZGl1c1kgKiByYWRpdXNZKSAvIDIpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQ2lyY2xlO1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBDaXJjbGU7XG5cblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgQml0LCBMaW5lLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MylbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5cdExpbmUgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChMaW5lLCBzdXBlckNsYXNzKTtcblxuXHQgIGZ1bmN0aW9uIExpbmUoKSB7XG5cdCAgICByZXR1cm4gTGluZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBMaW5lLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24oKSB7XG5cdCAgICBMaW5lLl9fc3VwZXJfXy5fZGVjbGFyZURlZmF1bHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHMudGFnID0gJ2xpbmUnO1xuXHQgIH07XG5cblx0ICBMaW5lLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJhZGl1c1gsIHgsIHk7XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHggPSB0aGlzLl9wcm9wcy53aWR0aCAvIDI7XG5cdCAgICB5ID0gdGhpcy5fcHJvcHMuaGVpZ2h0IC8gMjtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3gxJywgeCAtIHJhZGl1c1gpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgneDInLCB4ICsgcmFkaXVzWCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd5MScsIHkpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgneTInLCB5KTtcblx0ICAgIHJldHVybiBMaW5lLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gTGluZTtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuXG4vKioqLyB9KSxcbi8qIDg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIFppZ3phZyxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHRaaWd6YWcgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChaaWd6YWcsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gWmlnemFnKCkge1xuXHQgICAgcmV0dXJuIFppZ3phZy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBaaWd6YWcucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIFppZ3phZy5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnBvaW50cyA9IDM7XG5cdCAgfTtcblxuXHQgIFppZ3phZy5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjdXJyZW50WCwgY3VycmVudFksIGRlbHRhLCBpLCBpc1BvaW50cywgaXNSYWRpdXNYLCBpc1JhZGl1c1ksIGosIGxlbmd0aCwgcCwgcG9pbnRzLCByYWRpdXNYLCByYWRpdXNZLCByZWYsIHN0ZXBYLCB4LCB5LCB5RmxpcDtcblx0ICAgIFppZ3phZy5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmICghdGhpcy5fcHJvcHMucG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJhZGl1c1ggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IHRoaXMuX3Byb3BzLnJhZGl1c1kgIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1kgOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICBpc1JhZGl1c1ggPSByYWRpdXNYID09PSB0aGlzLl9wcmV2UmFkaXVzWDtcblx0ICAgIGlzUmFkaXVzWSA9IHJhZGl1c1kgPT09IHRoaXMuX3ByZXZSYWRpdXNZO1xuXHQgICAgaXNQb2ludHMgPSBwLnBvaW50cyA9PT0gdGhpcy5fcHJldlBvaW50cztcblx0ICAgIGlmIChpc1JhZGl1c1ggJiYgaXNSYWRpdXNZICYmIGlzUG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHggPSBwLndpZHRoIC8gMjtcblx0ICAgIHkgPSBwLmhlaWdodCAvIDI7XG5cdCAgICBjdXJyZW50WCA9IHggLSByYWRpdXNYO1xuXHQgICAgY3VycmVudFkgPSB5O1xuXHQgICAgc3RlcFggPSAoMiAqIHJhZGl1c1gpIC8gKHAucG9pbnRzIC0gMSk7XG5cdCAgICB5RmxpcCA9IC0xO1xuXHQgICAgZGVsdGEgPSBNYXRoLnNxcnQoc3RlcFggKiBzdGVwWCArIHJhZGl1c1kgKiByYWRpdXNZKTtcblx0ICAgIGxlbmd0aCA9IC1kZWx0YTtcblx0ICAgIHBvaW50cyA9IFwiTVwiICsgY3VycmVudFggKyBcIiwgXCIgKyB5ICsgXCIgXCI7XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcC5wb2ludHM7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuXHQgICAgICBwb2ludHMgKz0gXCJMXCIgKyBjdXJyZW50WCArIFwiLCBcIiArIGN1cnJlbnRZICsgXCIgXCI7XG5cdCAgICAgIGN1cnJlbnRYICs9IHN0ZXBYO1xuXHQgICAgICBsZW5ndGggKz0gZGVsdGE7XG5cdCAgICAgIGN1cnJlbnRZID0geUZsaXAgPT09IC0xID8geSAtIHJhZGl1c1kgOiB5O1xuXHQgICAgICB5RmxpcCA9IC15RmxpcDtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcblx0ICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgcG9pbnRzKTtcblx0ICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNYID0gcmFkaXVzWDtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgfTtcblxuXHQgIFppZ3phZy5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFppZ3phZztcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gWmlnemFnO1xuXG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIEJpdCwgUmVjdCxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHRSZWN0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoUmVjdCwgc3VwZXJDbGFzcyk7XG5cblx0ICBmdW5jdGlvbiBSZWN0KCkge1xuXHQgICAgcmV0dXJuIFJlY3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgUmVjdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgUmVjdC5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3JlY3QnO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMucnggPSAwO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnJ5ID0gMDtcblx0ICB9O1xuXG5cdCAgUmVjdC5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBwLCByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgUmVjdC5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHJhZGl1c1ggPSBwLnJhZGl1c1ggIT0gbnVsbCA/IHAucmFkaXVzWCA6IHAucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IHAucmFkaXVzWSAhPSBudWxsID8gcC5yYWRpdXNZIDogcC5yYWRpdXM7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd3aWR0aCcsIDIgKiByYWRpdXNYKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ2hlaWdodCcsIDIgKiByYWRpdXNZKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3gnLCAocC53aWR0aCAvIDIpIC0gcmFkaXVzWCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd5JywgKHAuaGVpZ2h0IC8gMikgLSByYWRpdXNZKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3J4JywgcC5yeCk7XG5cdCAgICByZXR1cm4gdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgncnknLCBwLnJ5KTtcblx0ICB9O1xuXG5cdCAgUmVjdC5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJhZGl1c1gsIHJhZGl1c1k7XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmV0dXJuIDIgKiAoMiAqIHJhZGl1c1ggKyAyICogcmFkaXVzWSk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBSZWN0O1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBSZWN0O1xuXG5cbi8qKiovIH0pLFxuLyogOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIEJpdCwgUG9seWdvbiwgaCxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0UG9seWdvbiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKFBvbHlnb24sIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gUG9seWdvbigpIHtcblx0ICAgIHJldHVybiBQb2x5Z29uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIGRlZmF1bHRzLlxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICAqL1xuXG5cdCAgUG9seWdvbi5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgUG9seWdvbi5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnBvaW50cyA9IDM7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IHRoZSBzaGFwZS5cblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAgKi9cblxuXHQgIFBvbHlnb24ucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgY2hhciwgZCwgaSwgaXNQb2ludHMsIGlzUmFkaXVzWCwgaXNSYWRpdXNZLCBqLCBrLCBsZW4sIHAsIHBvaW50LCByYWRpdXNYLCByYWRpdXNZLCByZWYsIHJlZjEsIHN0ZXA7XG5cdCAgICBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgaXNSYWRpdXNYID0gcmFkaXVzWCA9PT0gdGhpcy5fcHJldlJhZGl1c1g7XG5cdCAgICBpc1JhZGl1c1kgPSByYWRpdXNZID09PSB0aGlzLl9wcmV2UmFkaXVzWTtcblx0ICAgIGlzUG9pbnRzID0gcC5wb2ludHMgPT09IHRoaXMuX3ByZXZQb2ludHM7XG5cdCAgICBpZiAoIShpc1JhZGl1c1ggJiYgaXNSYWRpdXNZICYmIGlzUG9pbnRzKSkge1xuXHQgICAgICBzdGVwID0gMzYwIC8gdGhpcy5fcHJvcHMucG9pbnRzO1xuXHQgICAgICBpZiAodGhpcy5fcmFkaWFsUG9pbnRzID09IG51bGwpIHtcblx0ICAgICAgICB0aGlzLl9yYWRpYWxQb2ludHMgPSBbXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9yYWRpYWxQb2ludHMubGVuZ3RoID0gMDtcblx0ICAgICAgfVxuXHQgICAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fcHJvcHMucG9pbnRzOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgICB0aGlzLl9yYWRpYWxQb2ludHMucHVzaChoLmdldFJhZGlhbFBvaW50KHtcblx0ICAgICAgICAgIHJhZGl1czogdGhpcy5fcHJvcHMucmFkaXVzLFxuXHQgICAgICAgICAgcmFkaXVzWDogdGhpcy5fcHJvcHMucmFkaXVzWCxcblx0ICAgICAgICAgIHJhZGl1c1k6IHRoaXMuX3Byb3BzLnJhZGl1c1ksXG5cdCAgICAgICAgICBhbmdsZTogaSAqIHN0ZXAsXG5cdCAgICAgICAgICBjZW50ZXI6IHtcblx0ICAgICAgICAgICAgeDogcC53aWR0aCAvIDIsXG5cdCAgICAgICAgICAgIHk6IHAuaGVpZ2h0IC8gMlxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pKTtcblx0ICAgICAgfVxuXHQgICAgICBkID0gJyc7XG5cdCAgICAgIHJlZjEgPSB0aGlzLl9yYWRpYWxQb2ludHM7XG5cdCAgICAgIGZvciAoaSA9IGsgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgayA8IGxlbjsgaSA9ICsraykge1xuXHQgICAgICAgIHBvaW50ID0gcmVmMVtpXTtcblx0ICAgICAgICBjaGFyID0gaSA9PT0gMCA/ICdNJyA6ICdMJztcblx0ICAgICAgICBkICs9IFwiXCIgKyBjaGFyICsgKHBvaW50LngudG9GaXhlZCg0KSkgKyBcIixcIiArIChwb2ludC55LnRvRml4ZWQoNCkpICsgXCIgXCI7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5fcHJldlBvaW50cyA9IHAucG9pbnRzO1xuXHQgICAgICB0aGlzLl9wcmV2UmFkaXVzWCA9IHJhZGl1c1g7XG5cdCAgICAgIHRoaXMuX3ByZXZSYWRpdXNZID0gcmFkaXVzWTtcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2QnLCAoZCArPSAneicpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBQb2x5Z29uLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH07XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGxlbmd0aCBvZiB0aGUgc2hhcGUuXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgICovXG5cblx0ICBQb2x5Z29uLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fZ2V0UG9pbnRzUGVyaW1pdGVyKHRoaXMuX3JhZGlhbFBvaW50cyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBQb2x5Z29uO1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIEJpdCwgQ3Jvc3MsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cblx0Q3Jvc3MgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChDcm9zcywgc3VwZXJDbGFzcyk7XG5cblx0ICBmdW5jdGlvbiBDcm9zcygpIHtcblx0ICAgIHJldHVybiBDcm9zcy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBDcm9zcy5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgQ3Jvc3MuX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy50YWcgPSAncGF0aCc7XG5cdCAgfTtcblxuXHQgIENyb3NzLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGQsIGlzUmFkaXVzWCwgaXNSYWRpdXNZLCBsaW5lMSwgbGluZTIsIHAsIHJhZGl1c1gsIHJhZGl1c1ksIHgsIHgxLCB4MiwgeSwgeTEsIHkyO1xuXHQgICAgQ3Jvc3MuX19zdXBlcl9fLl9kcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgaXNSYWRpdXNYID0gcmFkaXVzWCA9PT0gdGhpcy5fcHJldlJhZGl1c1g7XG5cdCAgICBpc1JhZGl1c1kgPSByYWRpdXNZID09PSB0aGlzLl9wcmV2UmFkaXVzWTtcblx0ICAgIGlmIChpc1JhZGl1c1ggJiYgaXNSYWRpdXNZKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHggPSB0aGlzLl9wcm9wcy53aWR0aCAvIDI7XG5cdCAgICB5ID0gdGhpcy5fcHJvcHMuaGVpZ2h0IC8gMjtcblx0ICAgIHgxID0geCAtIHJhZGl1c1g7XG5cdCAgICB4MiA9IHggKyByYWRpdXNYO1xuXHQgICAgbGluZTEgPSBcIk1cIiArIHgxICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgeDIgKyBcIixcIiArIHk7XG5cdCAgICB5MSA9IHkgLSByYWRpdXNZO1xuXHQgICAgeTIgPSB5ICsgcmFkaXVzWTtcblx0ICAgIGxpbmUyID0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5MSArIFwiIExcIiArIHggKyBcIixcIiArIHkyO1xuXHQgICAgZCA9IGxpbmUxICsgXCIgXCIgKyBsaW5lMjtcblx0ICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgZCk7XG5cdCAgICB0aGlzLl9wcmV2UmFkaXVzWCA9IHJhZGl1c1g7XG5cdCAgICByZXR1cm4gdGhpcy5fcHJldlJhZGl1c1kgPSByYWRpdXNZO1xuXHQgIH07XG5cblx0ICBDcm9zcy5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHJhZGl1c1gsIHJhZGl1c1k7XG5cdCAgICByYWRpdXNYID0gdGhpcy5fcHJvcHMucmFkaXVzWCAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWCA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmV0dXJuIDIgKiAocmFkaXVzWCArIHJhZGl1c1kpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQ3Jvc3M7XG5cblx0fSkoQml0KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IENyb3NzO1xuXG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2JpdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5cdHZhciBfYml0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgQ3VydmUgPSBmdW5jdGlvbiAoX0JpdCkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEN1cnZlLCBfQml0KTtcblxuXHQgIGZ1bmN0aW9uIEN1cnZlKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ3VydmUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX0JpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICovXG5cdCAgQ3VydmUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgX0JpdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IHRoZSBtb2R1bGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICovXG5cblxuXHQgIEN1cnZlLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uIF9kcmF3KCkge1xuXHQgICAgX0JpdC5wcm90b3R5cGUuX2RyYXcuY2FsbCh0aGlzKTtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cblx0ICAgIHZhciByYWRpdXNYID0gcC5yYWRpdXNYICE9IG51bGwgPyBwLnJhZGl1c1ggOiBwLnJhZGl1cztcblx0ICAgIHZhciByYWRpdXNZID0gcC5yYWRpdXNZICE9IG51bGwgPyBwLnJhZGl1c1kgOiBwLnJhZGl1cztcblxuXHQgICAgdmFyIGlzUmFkaXVzWCA9IHJhZGl1c1ggPT09IHRoaXMuX3ByZXZSYWRpdXNYO1xuXHQgICAgdmFyIGlzUmFkaXVzWSA9IHJhZGl1c1kgPT09IHRoaXMuX3ByZXZSYWRpdXNZO1xuXHQgICAgdmFyIGlzUG9pbnRzID0gcC5wb2ludHMgPT09IHRoaXMuX3ByZXZQb2ludHM7XG5cdCAgICAvLyBza2lwIGlmIG5vdGhpbmcgY2hhbmdlZFxuXHQgICAgaWYgKGlzUmFkaXVzWCAmJiBpc1JhZGl1c1kgJiYgaXNQb2ludHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgeCA9IHAud2lkdGggLyAyO1xuXHQgICAgdmFyIHkgPSBwLmhlaWdodCAvIDI7XG5cdCAgICB2YXIgeDEgPSB4IC0gcmFkaXVzWDtcblx0ICAgIHZhciB4MiA9IHggKyByYWRpdXNYO1xuXG5cdCAgICB2YXIgZCA9ICdNJyArIHgxICsgJyAnICsgeSArICcgUSAnICsgeCArICcgJyArICh5IC0gMiAqIHJhZGl1c1kpICsgJyAnICsgeDIgKyAnICcgKyB5O1xuXG5cdCAgICAvLyBzZXQgdGhlIGBkYCBhdHRyaWJ1dGUgYW5kIHNhdmUgaXQgdG8gYF9wcmV2RGBcblx0ICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgZCk7XG5cdCAgICAvLyBzYXZlIHRoZSBwcm9wZXJ0aWVzXG5cdCAgICB0aGlzLl9wcmV2UG9pbnRzID0gcC5wb2ludHM7XG5cdCAgICB0aGlzLl9wcmV2UmFkaXVzWCA9IHJhZGl1c1g7XG5cdCAgICB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgfTtcblxuXHQgIEN1cnZlLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24gX2dldExlbmd0aCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cblx0ICAgIHZhciByYWRpdXNYID0gcC5yYWRpdXNYICE9IG51bGwgPyBwLnJhZGl1c1ggOiBwLnJhZGl1cztcblx0ICAgIHZhciByYWRpdXNZID0gcC5yYWRpdXNZICE9IG51bGwgPyBwLnJhZGl1c1kgOiBwLnJhZGl1cztcblxuXHQgICAgdmFyIGRSYWRpdXMgPSByYWRpdXNYICsgcmFkaXVzWTtcblx0ICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KCgzICogcmFkaXVzWCArIHJhZGl1c1kpICogKHJhZGl1c1ggKyAzICogcmFkaXVzWSkpO1xuXG5cdCAgICByZXR1cm4gLjUgKiBNYXRoLlBJICogKDMgKiBkUmFkaXVzIC0gc3FydCk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBDdXJ2ZTtcblx0fShfYml0Mi5kZWZhdWx0KTsgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcblxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEN1cnZlO1xuXG4vKioqLyB9KSxcbi8qIDkzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIEVxdWFsLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MylbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXG5cdEVxdWFsID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoRXF1YWwsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gRXF1YWwoKSB7XG5cdCAgICByZXR1cm4gRXF1YWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgRXF1YWwucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIEVxdWFsLl9fc3VwZXJfXy5fZGVjbGFyZURlZmF1bHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy50YWcgPSAncGF0aCc7XG5cdCAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHMucG9pbnRzID0gMjtcblx0ICB9O1xuXG5cdCAgRXF1YWwucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgZCwgaSwgaXNQb2ludHMsIGlzUmFkaXVzWCwgaXNSYWRpdXNZLCBqLCBwLCByYWRpdXNYLCByYWRpdXNZLCByZWYsIHgsIHgxLCB4MiwgeSwgeVN0YXJ0LCB5U3RlcDtcblx0ICAgIEVxdWFsLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKCF0aGlzLl9wcm9wcy5wb2ludHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIGlzUmFkaXVzWCA9IHJhZGl1c1ggPT09IHRoaXMuX3ByZXZSYWRpdXNYO1xuXHQgICAgaXNSYWRpdXNZID0gcmFkaXVzWSA9PT0gdGhpcy5fcHJldlJhZGl1c1k7XG5cdCAgICBpc1BvaW50cyA9IHAucG9pbnRzID09PSB0aGlzLl9wcmV2UG9pbnRzO1xuXHQgICAgaWYgKGlzUmFkaXVzWCAmJiBpc1JhZGl1c1kgJiYgaXNQb2ludHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgeCA9IHRoaXMuX3Byb3BzLndpZHRoIC8gMjtcblx0ICAgIHkgPSB0aGlzLl9wcm9wcy5oZWlnaHQgLyAyO1xuXHQgICAgeDEgPSB4IC0gcmFkaXVzWDtcblx0ICAgIHgyID0geCArIHJhZGl1c1g7XG5cdCAgICBkID0gJyc7XG5cdCAgICB5U3RlcCA9IDIgKiByYWRpdXNZIC8gKHRoaXMuX3Byb3BzLnBvaW50cyAtIDEpO1xuXHQgICAgeVN0YXJ0ID0geSAtIHJhZGl1c1k7XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fcHJvcHMucG9pbnRzOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgeSA9IFwiXCIgKyAoaSAqIHlTdGVwICsgeVN0YXJ0KTtcblx0ICAgICAgZCArPSBcIk1cIiArIHgxICsgXCIsIFwiICsgeSArIFwiIExcIiArIHgyICsgXCIsIFwiICsgeSArIFwiIFwiO1xuXHQgICAgfVxuXHQgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2QnLCBkKTtcblx0ICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNYID0gcmFkaXVzWDtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgfTtcblxuXHQgIEVxdWFsLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gMiAqICh0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVxdWFsO1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBFcXVhbDtcblxuXG4vKioqLyB9KSxcbi8qIDk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cblx0dmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuXHR2YXIgX3RoZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XG5cblx0dmFyIF90aGVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVuYWJsZSk7XG5cblx0dmFyIF90dW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuXG5cdHZhciBfdHVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90dW5hYmxlKTtcblxuXHR2YXIgX3R3ZWVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcblxuXHR2YXIgX3R3ZWVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2VlbmFibGUpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cdHZhciBCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcblx0dmFyIHNoYXBlc01hcCA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuXG5cdC8vIFRPRE9cblx0Ly8gIC0gcmVmYWN0b3Jcblx0Ly8gICAgLSBhZGQgc2V0SWZDaGFuZ2VkIHRvIE1vZHVsZVxuXHQvLyAgLS1cblx0Ly8gIC0gdHdlZW4gZm9yIGV2ZXJ5IHByb3BcblxuXHR2YXIgU2hhcGUgPSBmdW5jdGlvbiAoX1R1bmFibGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShTaGFwZSwgX1R1bmFibGUpO1xuXG5cdCAgZnVuY3Rpb24gU2hhcGUoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTaGFwZSk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfVHVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cdCAgU2hhcGUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgLy8gREVGQVVMVFMgLyBBUElzXG5cdCAgICB0aGlzLl9kZWZhdWx0cyA9IHtcblx0ICAgICAgLy8gd2hlcmUgdG8gYXBwZW5kIHRoZSBtb2R1bGUgdG8gW3NlbGVjdG9yLCBIVE1MRWxlbWVudF1cblx0ICAgICAgcGFyZW50OiBkb2N1bWVudC5ib2R5LFxuXHQgICAgICAvLyBjbGFzcyBuYW1lIGZvciB0aGUgYGVsYFxuXHQgICAgICBjbGFzc05hbWU6ICcnLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFtjaXJjbGUsIGxpbmUsIHppZ3phZywgcmVjdCwgcG9seWdvbiwgY3Jvc3MsIGVxdWFsIF1cblx0ICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbY29sb3IgbmFtZSwgcmdiLCByZ2JhLCBoZXhdXG5cdCAgICAgIHN0cm9rZTogJ3RyYW5zcGFyZW50Jyxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyAwLi4xIF1cblx0ICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbJ2J1dHQnIHwgJ3JvdW5kJyB8ICdzcXVhcmUnXVxuXHQgICAgICBzdHJva2VMaW5lY2FwOiAnJyxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICBzdHJva2VXaWR0aDogMixcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHN0cm9rZURhc2hhcnJheTogMCxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFtjb2xvciBuYW1lLCByZ2IsIHJnYmEsIGhleF1cblx0ICAgICAgZmlsbDogJ2RlZXBwaW5rJyxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyAwLi4xIF1cblx0ICAgICAgZmlsbE9wYWNpdHk6IDEsXG5cdCAgICAgIC8vIHtCb29sZWFufSAtIGlmIHNob3VsZCBoaWRlIG1vZHVsZSB3aXRoIGBvcGFjaXR5YCBpbnN0ZWFkIG9mIGBkaXNwbGF5YFxuXHQgICAgICBpc1NvZnRIaWRlOiB0cnVlLFxuXHQgICAgICAvLyB7Qm9vbGVhbn0gLSBpZiBzaG91bGQgdHJpZ2dlciBjb21wb3NpdGUgbGF5ZXIgZm9yIHRoZSBgZWxgXG5cdCAgICAgIGlzRm9yY2UzZDogZmFsc2UsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICBsZWZ0OiAnNTAlJyxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHRvcDogJzUwJScsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICB4OiAwLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgeTogMCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICBhbmdsZTogMCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICBzY2FsZTogMSxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXSBGYWxsYmFja3MgdG8gYHNjYWxlYC5cblx0ICAgICAgc2NhbGVYOiBudWxsLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdIEZhbGxiYWNrcyB0byBgc2NhbGVgLlxuXHQgICAgICBzY2FsZVk6IG51bGwsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICBvcmlnaW46ICc1MCUgNTAlJyxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyAwLi4xIF1cblx0ICAgICAgb3BhY2l0eTogMSxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHJ4OiAwLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgcnk6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgcG9pbnRzOiAzLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIHJhZGl1czogNTAsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgcmFkaXVzWDogbnVsbCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICByYWRpdXNZOiBudWxsLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsgYm9vbGVhbiBdXG5cdCAgICAgIGlzU2hvd1N0YXJ0OiBmYWxzZSxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbIGJvb2xlYW4gXVxuXHQgICAgICBpc1Nob3dFbmQ6IHRydWUsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWyBib29sZWFuIF1cblx0ICAgICAgaXNSZWZyZXNoU3RhdGU6IHRydWUsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgPiAwIF1cblx0ICAgICAgZHVyYXRpb246IDQwMCxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cblx0ICAgICAgLyogdGVjaG5pY2FsIG9uZXM6ICovXG5cdCAgICAgIC8vIGV4cGxpY2l0IHdpZHRoIG9mIHRoZSBtb2R1bGUgY2FudmFzXG5cdCAgICAgIHdpZHRoOiBudWxsLFxuXHQgICAgICAvLyBleHBsaWNpdCBoZWlnaHQgb2YgdGhlIG1vZHVsZSBjYW52YXNcblx0ICAgICAgaGVpZ2h0OiBudWxsLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgLy8gc2l6ZUdhcDogICAgICAgICAgMCxcblx0ICAgICAgLyogW2Jvb2xlYW5dIDo6IElmIHNob3VsZCBoYXZlIGNoaWxkIHNoYXBlLiAqL1xuXHQgICAgICBpc1dpdGhTaGFwZTogdHJ1ZSxcblx0ICAgICAgLy8gY29udGV4dCBmb3IgYWxsIHRoZSBjYWxsYmFja3Ncblx0ICAgICAgY2FsbGJhY2tzQ29udGV4dDogdGhpc1xuXHQgICAgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRoIG9wdGlvbmFsIG5ldyBvcHRpb25zLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQG92ZXJyaWRlcyBAIFR1bmFibGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byBzZXQgb24gdGhlIHJ1bi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLnR1bmUgPSBmdW5jdGlvbiB0dW5lKG8pIHtcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS50dW5lLmNhbGwodGhpcywgbyk7XG5cdCAgICAvLyB1cGRhdGUgc2hhcGVNb2R1bGUncyBzaXplIHRvIHRoZSBtYXggaW4gYHRoZW5gIGNoYWluXG5cdCAgICB0aGlzLl9nZXRNYXhTaXplSW5DaGFpbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBhIHRoZW4gcmVjb3JkIGZvciB0aGUgbW9kdWxlLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQG92ZXJyaWRlcyBAIFRoZW5hYmxlXG5cdCAgICBAcGFyYW0gICAge09iamVjdH0gT3B0aW9ucyBmb3IgdGhlIG5leHQgYW5pbWF0aW9uLlxuXHQgICAgQHJldHVybnMgIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG8pIHtcblx0ICAgIC8vIHRoaXMuX21ha2VUaW1lbGluZSgpXG5cdCAgICBfVHVuYWJsZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIG8pO1xuXHQgICAgLy8gdXBkYXRlIHNoYXBlTW9kdWxlJ3Mgc2l6ZSB0byB0aGUgbWF4IGluIGB0aGVuYCBjaGFpblxuXHQgICAgdGhpcy5fZ2V0TWF4U2l6ZUluQ2hhaW4oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EKFMpIF5cblx0ICAvLyB2IFBSSVZBVEUgTUVUSE9EKFMpIHZcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSB2YXJpYWJsZXMuXG5cdCAgICBAb3ZlcnJpZGVzIFRoZW5hYmxlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICAvLyBjYWxsIF92YXJzIG1ldGhvZCBvbiBUaGVuYWJsZVxuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLl92YXJzLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLl9sYXN0U2V0ID0ge307XG5cdCAgICAvLyBzYXZlIHByZXZpb3VzIG1vZHVsZSBpbiB0aGUgY2hhaW5cblx0ICAgIHRoaXMuX3ByZXZDaGFpbk1vZHVsZSA9IHRoaXMuX28ucHJldkNoYWluTW9kdWxlO1xuXHQgICAgLy8gc2hvdWxkIGRyYXcgb24gZm9yZWlnbiBzdmcgY2FudmFzXG5cdCAgICB0aGlzLmlzRm9yZWlnbiA9ICEhdGhpcy5fby5jdHg7XG5cdCAgICAvLyB0aGlzLl9vLmlzVGltZWxpbmVMZXNzID0gdHJ1ZTtcblx0ICAgIC8vIHNob3VsZCB0YWtlIGFuIHN2ZyBlbGVtZW50IGFzIHNlbGYgYml0XG5cdCAgICByZXR1cm4gdGhpcy5pc0ZvcmVpZ25CaXQgPSAhIXRoaXMuX28uc2hhcGU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGluaXRpYWxpemUgbW9kdWxlcyBwcmVzZW50YXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBNb2R1bGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG5cdCAgICBpZiAoIXRoaXMuX2lzUmVuZGVyZWQgJiYgIXRoaXMuX2lzQ2hhaW5lZCkge1xuXHQgICAgICAvLyBjcmVhdGUgYG1vanNgIHNoYXBlIGVsZW1lbnRcblx0ICAgICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgICAvLyBzZXQgbmFtZSBvbiB0aGUgYGVsYFxuXHQgICAgICB0aGlzLmVsLnNldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJywgJ21vanMtc2hhcGUnKTtcblx0ICAgICAgLy8gc2V0IGNsYXNzIG9uIHRoZSBgZWxgXG5cdCAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuX3Byb3BzLmNsYXNzTmFtZSk7XG5cdCAgICAgIC8vIGNyZWF0ZSBzaGFwZSBtb2R1bGVcblx0ICAgICAgdGhpcy5fY3JlYXRlU2hhcGUoKTtcblx0ICAgICAgLy8gYXBwZW5kIGBlbGAgdG8gcGFyZW50XG5cdCAgICAgIHRoaXMuX3Byb3BzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcblx0ICAgICAgLy8gc2V0IHBvc2l0aW9uIHN0eWxlcyBvbiB0aGUgZWxcblx0ICAgICAgdGhpcy5fc2V0RWxTdHlsZXMoKTtcblx0ICAgICAgLy8gc2V0IGluaXRpYWwgcG9zaXRpb24gZm9yIHRoZSBmaXJzdCBtb2R1bGUgaW4gdGhlIGNoYWluXG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKDAsIDApO1xuXHQgICAgICAvLyBzaG93IGF0IHN0YXJ0IGlmIGBpc1Nob3dTdGFydGBcblx0ICAgICAgaWYgKHRoaXMuX3Byb3BzLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgICAgdGhpcy5fc2hvdygpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2hpZGUoKTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBzZXQgYF9pc1JlbmRlcmVkYCBoYXRjaFxuXHQgICAgICB0aGlzLl9pc1JlbmRlcmVkID0gdHJ1ZTtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5faXNDaGFpbmVkKSB7XG5cdCAgICAgIC8vIHNhdmUgZWxlbWVudHMgZnJvbSBtYXN0ZXIgbW9kdWxlXG5cdCAgICAgIHRoaXMuZWwgPSB0aGlzLl9tYXN0ZXJNb2R1bGUuZWw7XG5cdCAgICAgIHRoaXMuc2hhcGVNb2R1bGUgPSB0aGlzLl9tYXN0ZXJNb2R1bGUuc2hhcGVNb2R1bGU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgZWwgc3R5bGVzIG9uIGluaXRpYWxpemF0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3NldEVsU3R5bGVzID0gZnVuY3Rpb24gX3NldEVsU3R5bGVzKCkge1xuXHQgICAgaWYgKCF0aGlzLmVsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIGlmICghdGhpcy5pc0ZvcmVpZ24pIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc3R5bGUgPSB0aGlzLmVsLnN0eWxlLFxuXHQgICAgICAgIHdpZHRoID0gcC5zaGFwZVdpZHRoLFxuXHQgICAgICAgIGhlaWdodCA9IHAuc2hhcGVIZWlnaHQ7XG5cblx0ICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0ICAgIHRoaXMuX3NldEVsU2l6ZVN0eWxlcyh3aWR0aCwgaGVpZ2h0KTtcblxuXHQgICAgaWYgKHAuaXNGb3JjZTNkKSB7XG5cdCAgICAgIHZhciBuYW1lID0gJ2JhY2tmYWNlLXZpc2liaWxpdHknO1xuXHQgICAgICBzdHlsZVsnJyArIG5hbWVdID0gJ2hpZGRlbic7XG5cdCAgICAgIHN0eWxlWycnICsgaC5wcmVmaXguY3NzICsgbmFtZV0gPSAnaGlkZGVuJztcblx0ICAgIH1cblx0ICAgIC8vIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IGB3aWR0aGAvYGhlaWdodGAvYG1hcmdpbnNgIHRvIHRoZSBgZWxgIHN0eWxlcy5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBXaWR0aC5cblx0ICAgIEBwYXJhbSB7aGVpZ2h0fSBIZWlnaHQuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9zZXRFbFNpemVTdHlsZXMgPSBmdW5jdGlvbiBfc2V0RWxTaXplU3R5bGVzKHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG5cdCAgICBzdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0ICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdCAgICBzdHlsZVsnbWFyZ2luLWxlZnQnXSA9IC13aWR0aCAvIDIgKyAncHgnO1xuXHQgICAgc3R5bGVbJ21hcmdpbi10b3AnXSA9IC1oZWlnaHQgLyAyICsgJ3B4Jztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyBzaGFwZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICBpZiAoIXRoaXMuc2hhcGVNb2R1bGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGJQID0gdGhpcy5zaGFwZU1vZHVsZS5fcHJvcHM7XG5cdCAgICAvLyBzZXQgcHJvcHMgb24gYml0XG5cdCAgICAvLyBiUC54ICAgICAgICAgICAgICAgICAgICA9IHRoaXMuX29yaWdpbi54O1xuXHQgICAgLy8gYlAueSAgICAgICAgICAgICAgICAgICAgPSB0aGlzLl9vcmlnaW4ueTtcblx0ICAgIGJQLnJ4ID0gcC5yeDtcblx0ICAgIGJQLnJ5ID0gcC5yeTtcblx0ICAgIGJQLnN0cm9rZSA9IHAuc3Ryb2tlO1xuXHQgICAgYlBbJ3N0cm9rZS13aWR0aCddID0gcC5zdHJva2VXaWR0aDtcblx0ICAgIGJQWydzdHJva2Utb3BhY2l0eSddID0gcC5zdHJva2VPcGFjaXR5O1xuXHQgICAgYlBbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHAuc3Ryb2tlRGFzaGFycmF5O1xuXHQgICAgYlBbJ3N0cm9rZS1kYXNob2Zmc2V0J10gPSBwLnN0cm9rZURhc2hvZmZzZXQ7XG5cdCAgICBiUFsnc3Ryb2tlLWxpbmVjYXAnXSA9IHAuc3Ryb2tlTGluZWNhcDtcblx0ICAgIGJQWydmaWxsJ10gPSBwLmZpbGw7XG5cdCAgICBiUFsnZmlsbC1vcGFjaXR5J10gPSBwLmZpbGxPcGFjaXR5O1xuXHQgICAgYlAucmFkaXVzID0gcC5yYWRpdXM7XG5cdCAgICBiUC5yYWRpdXNYID0gcC5yYWRpdXNYO1xuXHQgICAgYlAucmFkaXVzWSA9IHAucmFkaXVzWTtcblx0ICAgIGJQLnBvaW50cyA9IHAucG9pbnRzO1xuXG5cdCAgICB0aGlzLnNoYXBlTW9kdWxlLl9kcmF3KCk7XG5cdCAgICB0aGlzLl9kcmF3RWwoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IGN1cnJlbnQgbW9kdWxlcyBwcm9wcyB0byBtYWluIGRpdiBlbC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9kcmF3RWwgPSBmdW5jdGlvbiBfZHJhd0VsKCkge1xuXHQgICAgLy8gcmV0dXJuO1xuXHQgICAgaWYgKHRoaXMuZWwgPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuXG5cdCAgICAvLyBzdHlsZS5vcGFjaXR5ID0gcC5vcGFjaXR5O1xuXHQgICAgdGhpcy5faXNQcm9wQ2hhbmdlZCgnb3BhY2l0eScpICYmIChzdHlsZS5vcGFjaXR5ID0gcC5vcGFjaXR5KTtcblx0ICAgIGlmICghdGhpcy5pc0ZvcmVpZ24pIHtcblx0ICAgICAgdGhpcy5faXNQcm9wQ2hhbmdlZCgnbGVmdCcpICYmIChzdHlsZS5sZWZ0ID0gcC5sZWZ0KTtcblx0ICAgICAgdGhpcy5faXNQcm9wQ2hhbmdlZCgndG9wJykgJiYgKHN0eWxlLnRvcCA9IHAudG9wKTtcblxuXHQgICAgICB2YXIgaXNYID0gdGhpcy5faXNQcm9wQ2hhbmdlZCgneCcpLFxuXHQgICAgICAgICAgaXNZID0gdGhpcy5faXNQcm9wQ2hhbmdlZCgneScpLFxuXHQgICAgICAgICAgaXNUcmFuc2xhdGUgPSBpc1ggfHwgaXNZLFxuXHQgICAgICAgICAgaXNTY2FsZVggPSB0aGlzLl9pc1Byb3BDaGFuZ2VkKCdzY2FsZVgnKSxcblx0ICAgICAgICAgIGlzU2NhbGVZID0gdGhpcy5faXNQcm9wQ2hhbmdlZCgnc2NhbGVZJyksXG5cdCAgICAgICAgICBpc1NjYWxlID0gdGhpcy5faXNQcm9wQ2hhbmdlZCgnc2NhbGUnKSxcblx0ICAgICAgICAgIGlzU2NhbGUgPSBpc1NjYWxlIHx8IGlzU2NhbGVYIHx8IGlzU2NhbGVZLFxuXHQgICAgICAgICAgaXNSb3RhdGUgPSB0aGlzLl9pc1Byb3BDaGFuZ2VkKCdhbmdsZScpO1xuXG5cdCAgICAgIGlmIChpc1RyYW5zbGF0ZSB8fCBpc1NjYWxlIHx8IGlzUm90YXRlKSB7XG5cdCAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuX2ZpbGxUcmFuc2Zvcm0oKTtcblx0ICAgICAgICBzdHlsZVtoLnByZWZpeC5jc3MgKyAndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm07XG5cdCAgICAgICAgc3R5bGVbJ3RyYW5zZm9ybSddID0gdHJhbnNmb3JtO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuX2lzUHJvcENoYW5nZWQoJ29yaWdpbicpIHx8IHRoaXMuX2RlbHRhc1snb3JpZ2luJ10pIHtcblx0ICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5fZmlsbE9yaWdpbigpO1xuXHQgICAgICAgIHN0eWxlW2gucHJlZml4LmNzcyArICd0cmFuc2Zvcm0tb3JpZ2luJ10gPSBvcmlnaW47XG5cdCAgICAgICAgc3R5bGVbJ3RyYW5zZm9ybS1vcmlnaW4nXSA9IG9yaWdpbjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiBwcm9wZXJ0eSBjaGFuZ2VkIGFmdGVyIHRoZSBsYXRlc3QgY2hlY2suXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59XG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9pc1Byb3BDaGFuZ2VkID0gZnVuY3Rpb24gX2lzUHJvcENoYW5nZWQobmFtZSkge1xuXHQgICAgLy8gaWYgdGhlcmUgaXMgbm8gcmVjb2QgZm9yIHRoZSBwcm9wZXJ0eSAtIGNyZWF0ZSBpdFxuXHQgICAgaWYgKHRoaXMuX2xhc3RTZXRbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9sYXN0U2V0W25hbWVdID0ge307XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5fbGFzdFNldFtuYW1lXS52YWx1ZSAhPT0gdGhpcy5fcHJvcHNbbmFtZV0pIHtcblx0ICAgICAgdGhpcy5fbGFzdFNldFtuYW1lXS52YWx1ZSA9IHRoaXMuX3Byb3BzW25hbWVdO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBuZXcgb3B0aW9uIG9uIHJ1bi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSAgT3B0aW9uIHRvIHR1bmUgb24gcnVuLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fdHVuZU5ld09wdGlvbnMgPSBmdW5jdGlvbiBfdHVuZU5ld09wdGlvbnMobykge1xuXHQgICAgLy8gY2FsbCBzdXBlciBvbiBNb2R1bGVcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fdHVuZU5ld09wdGlvbnMuY2FsbCh0aGlzLCBvKTtcblx0ICAgIC8vIHJldHVybiBpZiBlbXB0eSBvYmplY3Rcblx0ICAgIGlmICghKG8gIT0gbnVsbCAmJiAoMCwgX2tleXMyLmRlZmF1bHQpKG8pLmxlbmd0aCkpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cblx0ICAgIC8vIHRoaXMuX2NhbGNTaXplKCk7XG5cdCAgICB0aGlzLl9zZXRFbFN0eWxlcygpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgbWF4IHJhZGl1c1ggdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFJhZGl1cyBuYW1lLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0TWF4UmFkaXVzID0gZnVuY3Rpb24gX2dldE1heFJhZGl1cyhuYW1lKSB7XG5cdCAgICB2YXIgc2VsZlNpemUsIHNlbGZTaXplWDtcblx0ICAgIHNlbGZTaXplID0gdGhpcy5fZ2V0UmFkaXVzU2l6ZSgncmFkaXVzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5fZ2V0UmFkaXVzU2l6ZShuYW1lLCBzZWxmU2l6ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGluY3JlYXNlIGNhbGN1bGF0ZWQgc2l6ZSBiYXNlZCBvbiBlYXNpbmcuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5faW5jcmVhc2VTaXplV2l0aEVhc2luZyA9IGZ1bmN0aW9uIF9pbmNyZWFzZVNpemVXaXRoRWFzaW5nKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBlYXNpbmcgPSB0aGlzLl9vLmVhc2luZyxcblx0ICAgICAgICBpc1N0cmluZ0Vhc2luZyA9IGVhc2luZyAmJiB0eXBlb2YgZWFzaW5nID09PSAnc3RyaW5nJztcblxuXHQgICAgc3dpdGNoIChpc1N0cmluZ0Vhc2luZyAmJiBlYXNpbmcudG9Mb3dlckNhc2UoKSkge1xuXHQgICAgICBjYXNlICdlbGFzdGljLm91dCc6XG5cdCAgICAgIGNhc2UgJ2VsYXN0aWMuaW5vdXQnOlxuXHQgICAgICAgIHAuc2l6ZSAqPSAxLjI1O1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdiYWNrLm91dCc6XG5cdCAgICAgIGNhc2UgJ2JhY2suaW5vdXQnOlxuXHQgICAgICAgIHAuc2l6ZSAqPSAxLjE7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGluY3JlYXNlIGNhbGN1bGF0ZWQgc2l6ZSBiYXNlZCBvbiBiaXQgcmF0aW8uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cdCAgLy8gX2luY3JlYXNlU2l6ZVdpdGhCaXRSYXRpbyAoKSB7XG5cdCAgLy8gICB2YXIgcCAgID0gdGhpcy5fcHJvcHM7XG5cdCAgLy8gICAvLyBwLnNpemUgKj0gdGhpcy5zaGFwZS5fcHJvcHMucmF0aW87XG5cdCAgLy8gICBwLnNpemUgKz0gMiAqIHAuc2l6ZUdhcDtcblx0ICAvLyB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgbWF4aW11bSByYWRpdXMgc2l6ZSB3aXRoIG9wdGlvbmFsIGZhbGxiYWNrLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fVxuXHQgICAgICBAcGFyYW0ga2V5IHtTdHJpbmd9IE5hbWUgb2YgdGhlIHJhZGl1cyAtIFtyYWRpdXN8cmFkaXVzWHxyYWRpdXNZXS5cblx0ICAgICAgQHBhcmFtIEBvcHRpb25hbCBmYWxsYmFjayB7TnVtYmVyfSAgT3B0aW9uYWwgbnVtYmVyIHRvIHNldCBpZiB0aGVyZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBubyB2YWx1ZSBmb3IgdGhlIGtleS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2dldFJhZGl1c1NpemUgPSBmdW5jdGlvbiBfZ2V0UmFkaXVzU2l6ZShuYW1lKSB7XG5cdCAgICB2YXIgZmFsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cblx0ICAgIHZhciBkZWx0YSA9IHRoaXMuX2RlbHRhc1tuYW1lXTtcblx0ICAgIC8vIGlmIHZhbHVlIGlzIGRlbHRhIHZhbHVlXG5cdCAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuXHQgICAgICAvLyBnZXQgbWF4aW11bSBudW1iZXIgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlcyBvZiB0aGUgZGVsdGFcblx0ICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGRlbHRhLmVuZCksIE1hdGguYWJzKGRlbHRhLnN0YXJ0KSk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BzW25hbWVdICE9IG51bGwpIHtcblx0ICAgICAgLy8gZWxzZSBnZXQgdGhlIHZhbHVlIGZyb20gcHJvcHMgb2JqZWN0XG5cdCAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuX3Byb3BzW25hbWVdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBmYWxsYmFjaztcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IG1heCBzaGFwZSBjYW52YXMgc2l6ZSBhbmQgc2F2ZSBpdCB0byBfcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0U2hhcGVTaXplID0gZnVuY3Rpb24gX2dldFNoYXBlU2l6ZSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cblx0ICAgIC8vIGdldCBtYXhpbXVtIHN0cm9rZSB2YWx1ZVxuXHQgICAgc3Ryb2tlID0gdGhpcy5fZ2V0TWF4U3Ryb2tlKCk7XG5cdCAgICAvLyBzYXZlIHNoYXBlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHRvIGBfcHJvcHNgXG5cdCAgICBwLnNoYXBlV2lkdGggPSBwLndpZHRoICE9IG51bGwgPyBwLndpZHRoIDogMiAqIHRoaXMuX2dldE1heFJhZGl1cygncmFkaXVzWCcpICsgc3Ryb2tlO1xuXG5cdCAgICBwLnNoYXBlSGVpZ2h0ID0gcC5oZWlnaHQgIT0gbnVsbCA/IHAuaGVpZ2h0IDogMiAqIHRoaXMuX2dldE1heFJhZGl1cygncmFkaXVzWScpICsgc3Ryb2tlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiBfY3JlYXRlU2hhcGUoKSB7XG5cdCAgICAvLyBjYWxjdWxhdGUgbWF4IHNoYXBlIGNhbnZhcyBzaXplIGFuZCBzZXQgdG8gX3Byb3BzXG5cdCAgICB0aGlzLl9nZXRTaGFwZVNpemUoKTtcblx0ICAgIC8vIGRvbid0IGNyZWF0ZSBhY3R1YWwgc2hhcGUgaWYgIWBpc1dpdGhTaGFwZWBcblx0ICAgIGlmICghdGhpcy5fcHJvcHMuaXNXaXRoU2hhcGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgLy8gZ2V0IHNoYXBlJ3MgY2xhc3Ncblx0ICAgIHZhciBTaGFwZSA9IHNoYXBlc01hcC5nZXRTaGFwZSh0aGlzLl9wcm9wcy5zaGFwZSk7XG5cdCAgICAvLyBjcmVhdGUgYF9zaGFwZWAgbW9kdWxlXG5cdCAgICB0aGlzLnNoYXBlTW9kdWxlID0gbmV3IFNoYXBlKHtcblx0ICAgICAgd2lkdGg6IHAuc2hhcGVXaWR0aCxcblx0ICAgICAgaGVpZ2h0OiBwLnNoYXBlSGVpZ2h0LFxuXHQgICAgICBwYXJlbnQ6IHRoaXMuZWxcblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgbWF4IHNpemUgaW4gYHRoZW5gIGNoYWluXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0TWF4U2l6ZUluQ2hhaW4gPSBmdW5jdGlvbiBfZ2V0TWF4U2l6ZUluQ2hhaW4oKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIG1heFcgPSAwLFxuXHQgICAgICAgIG1heEggPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fbW9kdWxlc1tpXS5fZ2V0U2hhcGVTaXplKCk7XG5cdCAgICAgIG1heFcgPSBNYXRoLm1heChtYXhXLCB0aGlzLl9tb2R1bGVzW2ldLl9wcm9wcy5zaGFwZVdpZHRoKTtcblx0ICAgICAgbWF4SCA9IE1hdGgubWF4KG1heEgsIHRoaXMuX21vZHVsZXNbaV0uX3Byb3BzLnNoYXBlSGVpZ2h0KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5zaGFwZU1vZHVsZSAmJiB0aGlzLnNoYXBlTW9kdWxlLl9zZXRTaXplKG1heFcsIG1heEgpO1xuXHQgICAgdGhpcy5fc2V0RWxTaXplU3R5bGVzKG1heFcsIG1heEgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgbWF4IHZhbHVlIG9mIHRoZSBzdHJva2VXaWR0aC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9nZXRNYXhTdHJva2UgPSBmdW5jdGlvbiBfZ2V0TWF4U3Ryb2tlKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHZhciBkU3Ryb2tlID0gdGhpcy5fZGVsdGFzWydzdHJva2VXaWR0aCddO1xuXHQgICAgcmV0dXJuIGRTdHJva2UgIT0gbnVsbCA/IE1hdGgubWF4KGRTdHJva2Uuc3RhcnQsIGRTdHJva2UuZW5kKSA6IHAuc3Ryb2tlV2lkdGg7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgZGVsdGFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIE1vZHVsZVxuXHQgICAgQHBhcmFtICAge051bWJlcn0gIEVhc2VkUHJvZ3Jlc3MgdG8gc2V0IC0gWzAuLjFdLlxuXHQgICAgQHBhcmFtICAge051bWJlcn0gIFByb2dyZXNzIHRvIHNldCAtIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG5cdCAgICAvLyBjYWxsIHRoZSBzdXBlciBvbiBNb2R1bGVcblx0ICAgIF9tb2R1bGUyLmRlZmF1bHQucHJvdG90eXBlLl9zZXRQcm9ncmVzcy5jYWxsKHRoaXMsIGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKTtcblx0ICAgIC8vIGRyYXcgY3VycmVudCBwcm9ncmVzc1xuXHQgICAgdGhpcy5fZHJhdyhlYXNlZFByb2dyZXNzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYWRkIGNhbGxiYWNrIG92ZXJyaWRlcyB0byBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gYWRkIHRoZSBvdmVycmlkZXMgdG8uXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9hcHBseUNhbGxiYWNrT3ZlcnJpZGVzID0gZnVuY3Rpb24gX2FwcGx5Q2FsbGJhY2tPdmVycmlkZXMob2JqKSB7XG5cdCAgICB2YXIgaXQgPSB0aGlzLFxuXHQgICAgICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIHNwZWNpZnkgY29udHJvbCBmdW5jdGlvbnMgZm9yIHRoZSBtb2R1bGVcblx0ICAgIG9iai5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGVwLCBwKSB7XG5cdCAgICAgICAgcmV0dXJuIGl0Ll9zZXRQcm9ncmVzcyhlcCwgcCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoaXNGd2QpIHtcblx0ICAgICAgICAvLyBkb24ndCB0b3VjaCBtYWluIGBlbGAgb25TdGFydCBpbiBjaGFpbmVkIGVsZW1lbnRzXG5cdCAgICAgICAgaWYgKGl0Ll9pc0NoYWluZWQpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChpc0Z3ZCkge1xuXHQgICAgICAgICAgaXQuX3Nob3coKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKCFwLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgICAgICAgIGl0Ll9oaWRlKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKGlzRndkKSB7XG5cdCAgICAgICAgLy8gZG9uJ3QgdG91Y2ggbWFpbiBgZWxgIGlmIG5vdCB0aGUgbGFzdCBpbiBgdGhlbmAgY2hhaW5cblx0ICAgICAgICBpZiAoIWl0Ll9pc0xhc3RJbkNoYWluKCkpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzRndkKSB7XG5cdCAgICAgICAgICBpZiAoIXAuaXNTaG93RW5kKSB7XG5cdCAgICAgICAgICAgIGl0Ll9oaWRlKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGl0Ll9zaG93KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBvblJlZnJlc2g6IGZ1bmN0aW9uIG9uUmVmcmVzaChpc0JlZm9yZSkge1xuXHQgICAgICAgIHAuaXNSZWZyZXNoU3RhdGUgJiYgaXNCZWZvcmUgJiYgaXQuX3JlZnJlc2hCZWZvcmUoKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0dXAgdHdlZW4gYW5kIHRpbWVsaW5lIG9wdGlvbnMgYmVmb3JlIGNyZWF0aW5nIHRoZW0uXG5cdCAgICBAb3ZlcnJpZGUgQCBUd2VlbmFibGVcblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl90cmFuc2Zvcm1Ud2Vlbk9wdGlvbnMgPSBmdW5jdGlvbiBfdHJhbnNmb3JtVHdlZW5PcHRpb25zKCkge1xuXHQgICAgdGhpcy5fYXBwbHlDYWxsYmFja092ZXJyaWRlcyh0aGlzLl9vKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHRyYW5zZm9ybSBzdHJpbmcuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge1N0cmluZ30gVHJhbnNmb3JtIHN0cmluZy5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2ZpbGxUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfZmlsbFRyYW5zZm9ybSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc2NhbGVYID0gcC5zY2FsZVggIT0gbnVsbCA/IHAuc2NhbGVYIDogcC5zY2FsZSxcblx0ICAgICAgICBzY2FsZVkgPSBwLnNjYWxlWSAhPSBudWxsID8gcC5zY2FsZVkgOiBwLnNjYWxlLFxuXHQgICAgICAgIHNjYWxlID0gc2NhbGVYICsgJywgJyArIHNjYWxlWTtcblx0ICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwLnggKyAnLCAnICsgcC55ICsgJykgcm90YXRlKCcgKyBwLmFuZ2xlICsgJ2RlZykgc2NhbGUoJyArIHNjYWxlICsgJyknO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdHJhbnNmb3JtLW9yaWdpbiBzdHJpbmcuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge1N0cmluZ30gVHJhbnNmb3JtIHN0cmluZy5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2ZpbGxPcmlnaW4gPSBmdW5jdGlvbiBfZmlsbE9yaWdpbigpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc3RyID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAub3JpZ2luLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHN0ciArPSBwLm9yaWdpbltpXS5zdHJpbmcgKyAnICc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3RyO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZWZyZXNoIHN0YXRlIGJlZm9yIHN0YXJ0VGltZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9yZWZyZXNoQmVmb3JlID0gZnVuY3Rpb24gX3JlZnJlc2hCZWZvcmUoKSB7XG5cdCAgICAvLyBjYWxsIHNldFByb2dyZXNzIHdpdGggZWFzZWQgYW5kIG5vcm1hbCBwcm9ncmVzc1xuXHQgICAgdGhpcy5fc2V0UHJvZ3Jlc3ModGhpcy50d2Vlbi5fcHJvcHMuZWFzaW5nKDApLCAwKTtcblxuXHQgICAgaWYgKHRoaXMuX3Byb3BzLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgIHRoaXMuX3Nob3coKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2hpZGUoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdGhhdCBnZXRzIGNhbGxlZCBvbiBgc29mdGAgc2hvdyBvZiB0aGUgbW9kdWxlLFxuXHQgICAgaXQgc2hvdWxkIHJlc3RvcmUgdHJhbnNmb3JtIHN0eWxlcyBvZiB0aGUgbW9kdWxlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBNb2R1bGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3Nob3dCeVRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9zaG93QnlUcmFuc2Zvcm0oKSB7XG5cdCAgICAvLyByZXNldCB0aGUgY2FjaGUgb2YgdGhlIHNjYWxlIHByb3Bcblx0ICAgIHRoaXMuX2xhc3RTZXQuc2NhbGUgPSBudWxsO1xuXHQgICAgLy8gZHJhdyBlbCBhY2Nyb2RpbmcgdG8gaXQncyBwcm9wc1xuXHQgICAgdGhpcy5fZHJhd0VsKCk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBTaGFwZTtcblx0fShfdHVuYWJsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gU2hhcGU7XG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oOTYpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5PYmplY3Qua2V5cztcblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxuXHR2YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KVxuXHQgICwgJGtleXMgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KSgna2V5cycsIGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuXHQgICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG5cdCAgfTtcblx0fSk7XG5cbi8qKiovIH0pLFxuLyogOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKVxuXHQgICwgY29yZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXG5cdCAgLCBmYWlscyAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcblx0ICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG5cdCAgICAsIGV4cCA9IHt9O1xuXHQgIGV4cFtLRVldID0gZXhlYyhmbik7XG5cdCAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfdHdlZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDApO1xuXG5cdHZhciBfdHdlZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuYWJsZSk7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICBUaGUgVGhlbmFibGUgY2xhc3MgYWRkcyAudGhlbiBwdWJsaWMgbWV0aG9kIGFuZFxuXHQgIHRoZSBhYmlsaXR5IHRvIGNoYWluIEFQSSBjYWxscy5cblx0Ki9cblx0dmFyIFRoZW5hYmxlID0gZnVuY3Rpb24gKF9Ud2VlbmFibGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShUaGVuYWJsZSwgX1R3ZWVuYWJsZSk7XG5cblx0ICBmdW5jdGlvbiBUaGVuYWJsZSgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFRoZW5hYmxlKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9Ud2VlbmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgYSB0aGVuIHJlY29yZCBmb3IgdGhlIG1vZHVsZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAgICB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGUgbmV4dCBhbmltYXRpb24uXG5cdCAgICBAcmV0dXJucyAge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvKSB7XG5cdCAgICAvLyByZXR1cm4gaWYgbm90aGluZyB3YXMgcGFzc2VkXG5cdCAgICBpZiAobyA9PSBudWxsIHx8ICEoMCwgX2tleXMyLmRlZmF1bHQpKG8pLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH1cblx0ICAgIC8vIG1lcmdlIHRoZW4gb3B0aW9ucyB3aXRoIHRoZSBjdXJyZW50IG9uZXNcblx0ICAgIHZhciBwcmV2UmVjb3JkID0gdGhpcy5faGlzdG9yeVt0aGlzLl9oaXN0b3J5Lmxlbmd0aCAtIDFdLFxuXHQgICAgICAgIHByZXZNb2R1bGUgPSB0aGlzLl9tb2R1bGVzW3RoaXMuX21vZHVsZXMubGVuZ3RoIC0gMV0sXG5cdCAgICAgICAgbWVyZ2VkID0gdGhpcy5fbWVyZ2VUaGVuT3B0aW9ucyhwcmV2UmVjb3JkLCBvKTtcblxuXHQgICAgdGhpcy5fcmVzZXRNZXJnZWRGbGFncyhtZXJnZWQpO1xuXHQgICAgLy8gY3JlYXRlIGEgc3VibW9kdWxlIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG1hc3RlciBtb2R1bGVcblx0ICAgIHZhciBtb2R1bGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihtZXJnZWQpO1xuXHQgICAgLy8gc2V0IGB0aGlzYCBhcyBhbXN0ZXIgbW9kdWxlIG9mIGNoaWxkIG1vZHVsZVxuXHQgICAgbW9kdWxlLl9tYXN0ZXJNb2R1bGUgPSB0aGlzO1xuXHQgICAgLy8gc2F2ZSB0aGUgbW9kdWxlcyB0byB0aGUgX21vZHVsZXMgYXJyYXlcblx0ICAgIHRoaXMuX21vZHVsZXMucHVzaChtb2R1bGUpO1xuXHQgICAgLy8gYWRkIG1vZHVsZSdzIHR3ZWVuIGludG8gbWFzdGVyIHRpbWVsaW5lXG5cdCAgICB0aGlzLnRpbWVsaW5lLmFwcGVuZChtb2R1bGUpO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gXiBQVUJMSUMgIE1FVEhPRChTKSBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRChTKSB2XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlc2V0IHNvbWUgZmxhZ3Mgb24gbWVyZ2VkIG9wdGlvbnMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSAgIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gT3B0aW9ucyBvYmplY3QuXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9yZXNldE1lcmdlZEZsYWdzID0gZnVuY3Rpb24gX3Jlc2V0TWVyZ2VkRmxhZ3Mob2JqKSB7XG5cdCAgICAvLyBzZXQgdGhlIHN1Ym1vZHVsZSB0byBiZSB3aXRob3V0IHRpbWVsaW5lIGZvciBwZXJmIHJlYXNvbnNcblx0ICAgIG9iai5pc1RpbWVsaW5lTGVzcyA9IHRydWU7XG5cdCAgICAvLyByZXNldCBpc1Nob3dTdGFydCBmbGFnIGZvciB0aGUgc3VibW9kdWxlc1xuXHQgICAgb2JqLmlzU2hvd1N0YXJ0ID0gZmFsc2U7XG5cdCAgICAvLyByZXNldCBpc1JlZnJlc2hTdGF0ZSBmbGFnIGZvciB0aGUgc3VibW9kdWxlc1xuXHQgICAgb2JqLmlzUmVmcmVzaFN0YXRlID0gZmFsc2U7XG5cdCAgICAvLyBzZXQgdGhlIHN1Ym1vZHVsZSBjYWxsYmFja3MgY29udGV4dFxuXHQgICAgb2JqLmNhbGxiYWNrc0NvbnRleHQgPSB0aGlzLl9wcm9wcy5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXM7XG5cdCAgICAvLyBzZXQgcHJldmlvdXMgbW9kdWxlXG5cdCAgICBvYmoucHJldkNoYWluTW9kdWxlID0gX2gyLmRlZmF1bHQuZ2V0TGFzdEl0ZW0odGhpcy5fbW9kdWxlcyk7XG5cdCAgICAvLyBwYXNzIHRoZSBgdGhpc2AgYXMgbWFzdGVyIG1vZHVsZVxuXHQgICAgb2JqLm1hc3Rlck1vZHVsZSA9IHRoaXM7XG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBpbml0aWFsaXplIHByb3BlcnRpZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgX1R3ZWVuYWJsZS5wcm90b3R5cGUuX3ZhcnMuY2FsbCh0aGlzKTtcblx0ICAgIC8vIHNhdmUgX21hc3RlciBtb2R1bGVcblx0ICAgIHRoaXMuX21hc3Rlck1vZHVsZSA9IHRoaXMuX28ubWFzdGVyTW9kdWxlO1xuXHQgICAgLy8gc2V0IGlzQ2hhaW5lZCBmbGFnIGJhc2VkIG9uIHByZXZDaGFpbk1vZHVsZSBvcHRpb25cblx0ICAgIHRoaXMuX2lzQ2hhaW5lZCA9ICEhdGhpcy5fbWFzdGVyTW9kdWxlO1xuXHQgICAgLy8gd2UgYXJlIGV4cGVjdCB0aGF0IHRoZSBfbyBvYmplY3Rcblx0ICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGV4dGVuZGVkIGJ5IGRlZmF1bHRzXG5cdCAgICB2YXIgaW5pdGlhbFJlY29yZCA9IF9oMi5kZWZhdWx0LmNsb25lT2JqKHRoaXMuX3Byb3BzKTtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9hcnJheVByb3BlcnR5TWFwKSB7XG5cdCAgICAgIGlmICh0aGlzLl9vW2tleV0pIHtcblx0ICAgICAgICB2YXIgcHJlUGFyc2VkID0gdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KGtleSwgdGhpcy5fb1trZXldKTtcblx0ICAgICAgICBpbml0aWFsUmVjb3JkW2tleV0gPSBwcmVQYXJzZWQ7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5faGlzdG9yeSA9IFtpbml0aWFsUmVjb3JkXTtcblx0ICAgIC8vIHRoZSBhcnJheSBob2xkcyBhbGwgbW9kdWxlcyBpbiB0aGUgdGhlbiBjaGFpblxuXHQgICAgdGhpcy5fbW9kdWxlcyA9IFt0aGlzXTtcblx0ICAgIC8vIHRoZSBwcm9wcyB0aGF0IHRvIGV4Y2x1ZGUgZnJvbSB0aGVuIG1lcmdlXG5cdCAgICB0aGlzLl9ub25NZXJnZVByb3BzID0geyBzaGFwZTogMSB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBtZXJnZSB0d28gb3B0aW9ucyBpbnRvIG9uZS4gVXNlZCBpbiAudGhlbiBjaGFpbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFN0YXJ0IG9wdGlvbnMgZm9yIHRoZSBtZXJnZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBFbmQgb3B0aW9ucyBmb3IgdGhlIG1lcmdlLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gTWVyZ2VkIG9wdGlvbnMuXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9tZXJnZVRoZW5PcHRpb25zID0gZnVuY3Rpb24gX21lcmdlVGhlbk9wdGlvbnMoc3RhcnQsIGVuZCkge1xuXHQgICAgdmFyIG8gPSB7fTtcblx0ICAgIHRoaXMuX21lcmdlU3RhcnRMb29wKG8sIHN0YXJ0KTtcblx0ICAgIHRoaXMuX21lcmdlRW5kTG9vcChvLCBzdGFydCwgZW5kKTtcblx0ICAgIHRoaXMuX2hpc3RvcnkucHVzaChvKTtcblx0ICAgIHJldHVybiBvO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwaXBlIHN0YXJ0VmFsdWUgb2YgdGhlIGRlbHRhLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTdGFydCBwcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9IFN0YXJ0IHByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0FueX0gU3RhcnQgcHJvcGVydHkgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9jaGVja1N0YXJ0VmFsdWUgPSBmdW5jdGlvbiBfY2hlY2tTdGFydFZhbHVlKG5hbWUsIHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgT3JpZ2luYWxseSBwYXJ0IG9mIHRoZSBfbWVyZ2VUaGVuT3B0aW9ucy5cblx0ICAgIExvb3BzIHRocnUgc3RhcnQgb2JqZWN0IGFuZCBjb3BpZXMgYWxsIHRoZSBwcm9wcyBmcm9tIGl0LlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCB0byBjb3B5IGluLlxuXHQgICAgQHBhcm1hIHtPYmplY3R9IFN0YXJ0IG9wdGlvbnMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fbWVyZ2VTdGFydExvb3AgPSBmdW5jdGlvbiBfbWVyZ2VTdGFydExvb3Aobywgc3RhcnQpIHtcblx0ICAgIC8vIGxvb3AgdGhydSBzdGFydCBvcHRpb25zIG9iamVjdFxuXHQgICAgZm9yICh2YXIga2V5IGluIHN0YXJ0KSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHN0YXJ0W2tleV07XG5cdCAgICAgIGlmIChzdGFydFtrZXldID09IG51bGwpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfTtcblx0ICAgICAgLy8gY29weSBhbGwgdmFsdWVzIGZyb20gc3RhcnQgaWYgbm90IHR3ZWVuIHByb3Agb3IgZHVyYXRpb25cblx0ICAgICAgaWYgKCFfaDIuZGVmYXVsdC5pc1R3ZWVuUHJvcChrZXkpIHx8IGtleSA9PT0gJ2R1cmF0aW9uJykge1xuXHQgICAgICAgIC8vIGlmIGRlbHRhIC0gY29weSBvbmx5IHRoZSBlbmQgdmFsdWVcblx0ICAgICAgICBpZiAodGhpcy5faXNEZWx0YSh2YWx1ZSkpIHtcblx0ICAgICAgICAgIG9ba2V5XSA9IF9oMi5kZWZhdWx0LmdldERlbHRhRW5kKHZhbHVlKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb1trZXldID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgT3JpZ2luYWxseSBwYXJ0IG9mIHRoZSBfbWVyZ2VUaGVuT3B0aW9ucy5cblx0ICAgIExvb3BzIHRocnUgc3RhcnQgb2JqZWN0IGFuZCBtZXJnZXMgYWxsIHRoZSBwcm9wcyBmcm9tIGl0LlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCB0byBjb3B5IGluLlxuXHQgICAgQHBhcm1hIHtPYmplY3R9IFN0YXJ0IG9wdGlvbnMgb2JqZWN0LlxuXHQgICAgQHBhcm1hIHtPYmplY3R9IEVuZCBvcHRpb25zIG9iamVjdC5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX21lcmdlRW5kTG9vcCA9IGZ1bmN0aW9uIF9tZXJnZUVuZExvb3Aobywgc3RhcnQsIGVuZCkge1xuXHQgICAgdmFyIGVuZEtleXMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKGVuZCk7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBlbmQpIHtcblx0ICAgICAgLy8ganVzdCBjb3B5IHBhcmVudCBvcHRpb25cblx0ICAgICAgaWYgKGtleSA9PSAncGFyZW50Jykge1xuXHQgICAgICAgIG9ba2V5XSA9IGVuZFtrZXldO2NvbnRpbnVlO1xuXHQgICAgICB9O1xuXG5cdCAgICAgIC8vIGdldCBrZXkvdmFsdWUgb2YgdGhlIGVuZCBvYmplY3Rcblx0ICAgICAgLy8gZW5kS2V5IC0gbmFtZSBvZiB0aGUgcHJvcGVydHksIGVuZFZhbHVlIC0gdmFsdWUgb2YgdGhlIHByb3BlcnR5XG5cdCAgICAgIHZhciBlbmRWYWx1ZSA9IGVuZFtrZXldLFxuXHQgICAgICAgICAgc3RhcnRWYWx1ZSA9IHN0YXJ0W2tleV0gIT0gbnVsbCA/IHN0YXJ0W2tleV0gOiB0aGlzLl9kZWZhdWx0c1trZXldO1xuXG5cdCAgICAgIHN0YXJ0VmFsdWUgPSB0aGlzLl9jaGVja1N0YXJ0VmFsdWUoa2V5LCBzdGFydFZhbHVlKTtcblx0ICAgICAgaWYgKGVuZFZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICBjb250aW51ZTtcblx0ICAgICAgfTtcblx0ICAgICAgLy8gbWFrZSDiiIYgb2Ygc3RhcnQgLT4gZW5kXG5cdCAgICAgIC8vIGlmIGtleSBuYW1lIGlzIHJhZGl1c1gvcmFkaXVzWSBhbmRcblx0ICAgICAgLy8gdGhlIHN0YXJ0VmFsdWUgaXMgbm90IHNldCBmYWxsYmFjayB0byByYWRpdXMgdmFsdWVcblx0ICAgICAgdmFyIGlzU3ViUmFkaXVzID0ga2V5ID09PSAncmFkaXVzWCcgfHwga2V5ID09PSAncmFkaXVzWSc7XG5cdCAgICAgIGlmIChpc1N1YlJhZGl1cyAmJiBzdGFydFZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICBzdGFydFZhbHVlID0gc3RhcnQucmFkaXVzO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIGlzU3ViUmFkaXVzID0ga2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknO1xuXHQgICAgICBpZiAoaXNTdWJSYWRpdXMgJiYgc3RhcnRWYWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgc3RhcnRWYWx1ZSA9IHN0YXJ0LnNjYWxlO1xuXHQgICAgICB9XG5cblx0ICAgICAgb1trZXldID0gdGhpcy5fbWVyZ2VUaGVuUHJvcGVydHkoa2V5LCBzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIG1lcmdlIGBzdGFydGAgYW5kIGBlbmRgIGZvciBhIHByb3BlcnR5IGluIHRoZW4gcmVjb3JkLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBFbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fbWVyZ2VUaGVuUHJvcGVydHkgPSBmdW5jdGlvbiBfbWVyZ2VUaGVuUHJvcGVydHkoa2V5LCBzdGFydFZhbHVlLCBlbmRWYWx1ZSkge1xuXHQgICAgLy8gaWYgaXNudCB0d2VlbiBwcm9wZXJ0eVxuXHQgICAgdmFyIGlzQm9vbGVhbiA9IHR5cGVvZiBlbmRWYWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuXHQgICAgICAgIGN1cnZlLFxuXHQgICAgICAgIGVhc2luZztcblxuXHQgICAgaWYgKCFfaDIuZGVmYXVsdC5pc1R3ZWVuUHJvcChrZXkpICYmICF0aGlzLl9ub25NZXJnZVByb3BzW2tleV0gJiYgIWlzQm9vbGVhbikge1xuXG5cdCAgICAgIGlmIChfaDIuZGVmYXVsdC5pc09iamVjdChlbmRWYWx1ZSkgJiYgZW5kVmFsdWUudG8gIT0gbnVsbCkge1xuXHQgICAgICAgIGN1cnZlID0gZW5kVmFsdWUuY3VydmU7XG5cdCAgICAgICAgZWFzaW5nID0gZW5kVmFsdWUuZWFzaW5nO1xuXHQgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUudG87XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBpZiBlbmQgdmFsdWUgaXMgZGVsdGEgLSBqdXN0IHNhdmUgaXRcblx0ICAgICAgaWYgKHRoaXMuX2lzRGVsdGEoZW5kVmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlRGVsdGFWYWx1ZXMoa2V5LCBlbmRWYWx1ZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHBhcnNlZEVuZFZhbHVlID0gdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KGtleSwgZW5kVmFsdWUpO1xuXHQgICAgICAgIC8vIGlmIGVuZCB2YWx1ZSBpcyBub3QgZGVsdGEgLSBtZXJnZSB3aXRoIHN0YXJ0IHZhbHVlXG5cdCAgICAgICAgaWYgKHRoaXMuX2lzRGVsdGEoc3RhcnRWYWx1ZSkpIHtcblx0ICAgICAgICAgIHZhciBfcmVmO1xuXG5cdCAgICAgICAgICAvLyBpZiBzdGFydCB2YWx1ZSBpcyBkZWx0YSAtIHRha2UgdGhlIGVuZCB2YWx1ZVxuXHQgICAgICAgICAgLy8gYXMgc3RhcnQgdmFsdWUgb2YgdGhlIG5ldyBkZWx0YVxuXHQgICAgICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltfaDIuZGVmYXVsdC5nZXREZWx0YUVuZChzdGFydFZhbHVlKV0gPSBwYXJzZWRFbmRWYWx1ZSwgX3JlZi5lYXNpbmcgPSBlYXNpbmcsIF9yZWYuY3VydmUgPSBjdXJ2ZSwgX3JlZjtcblx0ICAgICAgICAgIC8vIGlmIGJvdGggc3RhcnQgYW5kIGVuZCB2YWx1ZSBhcmUgbm90IOKIhiAtIG1ha2Ug4oiGXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhciBfcmVmMjtcblxuXHQgICAgICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW3N0YXJ0VmFsdWVdID0gcGFyc2VkRW5kVmFsdWUsIF9yZWYyLmVhc2luZyA9IGVhc2luZywgX3JlZjIuY3VydmUgPSBjdXJ2ZSwgX3JlZjI7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIGNvcHkgdGhlIHR3ZWVuIHZhbHVlcyB1bmF0dGVuZGVkXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZW5kVmFsdWU7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJldHJlaXZlIGFycmF5J3MgbGVuZ3RoIGFuZCByZXR1cm4gLTEgZm9yXG5cdCAgICBhbGwgb3RoZXIgdHlwZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBcnJheSwgQW55fSBBcnJheSB0byBnZXQgdGhlIHdpZHRoIGZvci5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IEFycmF5IGxlbmd0aCBvciAtMSBpZiBub3QgYXJyYXkuXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9nZXRBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIF9nZXRBcnJheUxlbmd0aChhcnIpIHtcblx0ICAgIHJldHVybiBfaDIuZGVmYXVsdC5pc0FycmF5KGFycikgPyBhcnIubGVuZ3RoIDogLTE7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWx0YSBwcm9wZXJ0eS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUGFyYW1ldGVyIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59XG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9pc0RlbHRhID0gZnVuY3Rpb24gX2lzRGVsdGEob3B0aW9uc1ZhbHVlKSB7XG5cdCAgICB2YXIgaXNPYmplY3QgPSBfaDIuZGVmYXVsdC5pc09iamVjdChvcHRpb25zVmFsdWUpO1xuXHQgICAgaXNPYmplY3QgPSBpc09iamVjdCAmJiAhb3B0aW9uc1ZhbHVlLnVuaXQ7XG5cdCAgICByZXR1cm4gISghaXNPYmplY3QgfHwgX2gyLmRlZmF1bHQuaXNBcnJheShvcHRpb25zVmFsdWUpIHx8IF9oMi5kZWZhdWx0LmlzRE9NKG9wdGlvbnNWYWx1ZSkpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB0aGUgbW9kdWxlIGlzIGZpcnN0IGluIGB0aGVuYCBjaGFpbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIG1vZHVsZSBpcyB0aGUgZmlyc3QgaW4gbW9kdWxlIGNoYWluLlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5faXNGaXJzdEluQ2hhaW4gPSBmdW5jdGlvbiBfaXNGaXJzdEluQ2hhaW4oKSB7XG5cdCAgICByZXR1cm4gIXRoaXMuX21hc3Rlck1vZHVsZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIG1vZHVsZSBpcyBsYXN0IGluIGB0aGVuYCBjaGFpbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIG1vZHVsZSBpcyB0aGUgbGFzdCBpbiBtb2R1bGUgY2hhaW4uXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9pc0xhc3RJbkNoYWluID0gZnVuY3Rpb24gX2lzTGFzdEluQ2hhaW4oKSB7XG5cdCAgICB2YXIgbWFzdGVyID0gdGhpcy5fbWFzdGVyTW9kdWxlO1xuXHQgICAgLy8gaWYgdGhlcmUgaXMgbm8gbWFzdGVyIGZpZWxkIC0gY2hlY2sgdGhlIG1vZHVsZXMgbGVuZ3RoXG5cdCAgICAvLyBpZiBtb2R1bGUgbGVuZ3RoIGlzIDEgdGh1cyB0aGVyZSBpcyBubyBtb2R1bGVzIGNoYWluIFxuXHQgICAgLy8gaXQgaXMgdGhlIGxhc3Qgb25lLCBvdGhlcndpc2UgaXQgaXNudFxuXHQgICAgaWYgKCFtYXN0ZXIpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX21vZHVsZXMubGVuZ3RoID09PSAxO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgdGhlcmUgaXMgbWFzdGVyIC0gY2hlY2sgaWYgaXQgaXMgdGhlIGxhc3QgaXRlbSBpbiBfbW9kdWxlcyBjaGFpblxuXHQgICAgcmV0dXJuIHRoaXMgPT09IF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKG1hc3Rlci5fbW9kdWxlcyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBUaGVuYWJsZTtcblx0fShfdHdlZW5hYmxlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBUaGVuYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxMDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfdGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0dmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0KTtcblxuXHR2YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICBDbGFzcyB0byBkZWZpbmUgYSBtb2R1bGUgYW5jZXN0b3Jcblx0ICB3aXRoIHRpbWVsaW5lIGFuZCB0d2VlbiBvcHRpb25zIGFuZCBmdW5jdGlvbmFsaXR5LlxuXHQgIEFsbCBydW5hYmxlIG1vZHVsZXMgc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXG5cdCAgQGNsYXNzIFR3ZWVuYWJsZVxuXHQqL1xuXHR2YXIgVHdlZW5hYmxlID0gZnVuY3Rpb24gKF9Nb2R1bGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShUd2VlbmFibGUsIF9Nb2R1bGUpO1xuXG5cdCAgLypcblx0ICAgIGBwbGF5YCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBUaW1lIHNoaWZ0LlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnBsYXkuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGBwbGF5QmFja3dhcmRgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFRpbWUgc2hpZnQuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucGxheUJhY2t3YXJkID0gZnVuY3Rpb24gcGxheUJhY2t3YXJkKCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5wbGF5QmFja3dhcmQuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGBwYXVzZWAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucGF1c2UuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGBzdG9wYCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBbMC4uLjFdIFByb2dyZXNzIHRvIHNldCBvbiBzdG9wLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKkRlZmF1bHQqIGlzIGAwYCBpZiBgcGxheWBcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBgMWAgaWYgYHBsYXlCQWNrd2FyZGAuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnN0b3AuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGByZXNldGAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucmVzZXQuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGByZXBsYXlgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnJlcGxheSA9IGZ1bmN0aW9uIHJlcGxheSgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucmVwbGF5LmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcmVwbGF5YCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5yZXBsYXlCYWNrd2FyZCA9IGZ1bmN0aW9uIHJlcGxheUJhY2t3YXJkKCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5yZXBsYXlCYWNrd2FyZC5hcHBseSh0aGlzLnRpbWVsaW5lLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgYHJlc3VtZWAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge051bWJlcn0gVGltZSBzaGlmdC5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cblx0ICAgIHRoaXMudGltZWxpbmUucmVzdW1lLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgc2V0UHJvZ3Jlc3NgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFswLi4uMV0gUHJvZ3Jlc3MgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUuc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBzZXRQcm9ncmVzcygpIHtcblx0ICAgIHRoaXMudGltZWxpbmUuc2V0UHJvZ3Jlc3MuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIHNldFNwZWVkIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFNwZWVkIHZhbHVlLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnNldFNwZWVkID0gZnVuY3Rpb24gc2V0U3BlZWQoc3BlZWQpIHtcblx0ICAgIHRoaXMudGltZWxpbmUuc2V0U3BlZWQuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EKFMpIF5cblx0ICAvLyB2IFBSSVZBVEUgTUVUSE9EKFMpIHZcblxuXHQgIGZ1bmN0aW9uIFR3ZWVuYWJsZSgpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR3ZWVuYWJsZSk7XG5cblx0ICAgIC8vIHBpcGUgZnVuY3Rpb24gZm9yIF9vIG9iamVjdFxuXHQgICAgLy8gYmVmb3JlIGNyZWF0aW5nIHR3ZWVuL3RpbWVsaW5lXG5cdCAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9Nb2R1bGUuY2FsbCh0aGlzLCBvKSk7XG5cdCAgICAvLyBzdXBlciBvZiBNb2R1bGVcblxuXG5cdCAgICBfdGhpcy5fdHJhbnNmb3JtVHdlZW5PcHRpb25zKCk7XG5cdCAgICAvLyBtYWtlIHR3ZWVuIG9ubHkgaWYgaXNUd2Vlbkxlc3Mgb3B0aW9uIGlzIG5vdCBzZXRcblx0ICAgICFfdGhpcy5fby5pc1R3ZWVuTGVzcyAmJiBfdGhpcy5fbWFrZVR3ZWVuKCk7XG5cdCAgICAvLyBtYWtlIHRpbWVsaW5lIG9ubHkgaWYgaXNUaW1lbGluZUxlc3Mgb3B0aW9uIGlzIG5vdCBzZXRcblx0ICAgICFfdGhpcy5fby5pc1RpbWVsaW5lTGVzcyAmJiBfdGhpcy5fbWFrZVRpbWVsaW5lKCk7XG5cdCAgICByZXR1cm4gX3RoaXM7XG5cdCAgfVxuXHQgIC8qXG5cdCAgICBQbGFjZWhvbGRlciBtZXRob2QgdGhhdCBzaG91bGQgYmUgb3ZlcnJpZGVkXG5cdCAgICBhbmQgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIHR3ZWVuL3RpbWVsaW5lIGNyZWF0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLl90cmFuc2Zvcm1Ud2Vlbk9wdGlvbnMgPSBmdW5jdGlvbiBfdHJhbnNmb3JtVHdlZW5PcHRpb25zKCkge307XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdHdlZW4uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUuX21ha2VUd2VlbiA9IGZ1bmN0aW9uIF9tYWtlVHdlZW4oKSB7XG5cdCAgICAvLyBwYXNzIGNhbGxiYWNrcyBjb250ZXh0XG5cdCAgICB0aGlzLl9vLmNhbGxiYWNrc0NvbnRleHQgPSB0aGlzLl9vLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcztcblx0ICAgIHRoaXMudHdlZW4gPSBuZXcgX3R3ZWVuMi5kZWZhdWx0KHRoaXMuX28pO1xuXHQgICAgLy8gbWFrZSB0aW1lbGluZSBwcm9wZXJ0eSBwb2ludCB0byB0d2VlbiBvbmUgaXMgXCJubyB0aW1lbGluZVwiIG1vZGVcblx0ICAgIHRoaXMuX28uaXNUaW1lbGluZUxlc3MgJiYgKHRoaXMudGltZWxpbmUgPSB0aGlzLnR3ZWVuKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHRpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaW1lbGluZSdzIG9wdGlvbnMuXG5cdCAgICAgICAgICAgICAgICAgICAgQW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIFwidGltZWxpbmVcIiBwcm9wZXJ0eSB3aXRoXG5cdCAgICAgICAgICAgICAgICAgICAgdGltZWxpbmUgb3B0aW9ucy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLl9tYWtlVGltZWxpbmUgPSBmdW5jdGlvbiBfbWFrZVRpbWVsaW5lKCkge1xuXHQgICAgLy8gcGFzcyBjYWxsYmFja3MgY29udGV4dFxuXHQgICAgdGhpcy5fby50aW1lbGluZSA9IHRoaXMuX28udGltZWxpbmUgfHwge307XG5cdCAgICB0aGlzLl9vLnRpbWVsaW5lLmNhbGxiYWNrc0NvbnRleHQgPSB0aGlzLl9vLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcztcblx0ICAgIHRoaXMudGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KHRoaXMuX28udGltZWxpbmUpO1xuXHQgICAgLy8gc2V0IHRoZSBmbGFnIHRvIGluZGljYXRlIHRoYXQgcmVhbCB0aW1lbGluZSBpcyBwcmVzZW50XG5cdCAgICB0aGlzLl9pc1RpbWVsaW5lID0gdHJ1ZTtcblx0ICAgIC8vIGlmIHR3ZWVuIGV4aXN0IC0gYWRkIGl0IHRvIHRoZSB0aW1lbGluZSB0aGVyZSBpcyBzb21lXG5cdCAgICAvLyBtb2R1bGVzIGxpa2UgYnVyc3QgYW5kIHN0YWdnZXIgdGhhdCBoYXZlIG5vIHR3ZWVuXG5cdCAgICB0aGlzLnR3ZWVuICYmIHRoaXMudGltZWxpbmUuYWRkKHRoaXMudHdlZW4pO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVHdlZW5hYmxlO1xuXHR9KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IFR3ZWVuYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0dmFyIF90d2VlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xuXG5cdHZhciBfdHdlZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2VlbmVyKTtcblxuXHR2YXIgX2Vhc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcblxuXHR2YXIgX2Vhc2luZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYXNpbmcpO1xuXG5cdHZhciBfbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cblx0dmFyIF9tb2R1bGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW9kdWxlKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8vIGltcG9ydCBoIGZyb20gJy4uL2gnO1xuXHR2YXIgVHdlZW4gPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFR3ZWVuLCBfTW9kdWxlKTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgZG8gZGVjbGFyZSBkZWZhdWx0cyB3aXRoIHRoaXMuX2RlZmF1bHRzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblx0ICBUd2Vlbi5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICAvLyBERUZBVUxUU1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgIC8qIGR1cmF0aW9uIG9mIHRoZSB0d2VlbiBbMC4u4oieXSAqL1xuXHQgICAgICBkdXJhdGlvbjogMzUwLFxuXHQgICAgICAvKiBkZWxheSBvZiB0aGUgdHdlZW4gWy3iiJ4uLuKInl0gKi9cblx0ICAgICAgZGVsYXk6IDAsXG5cdCAgICAgIC8qIHJlcGVhdCBvZiB0aGUgdHdlZW4gWzAuLuKInl0sIG1lYW5zIGhvdyBtdWNoIHRvXG5cdCAgICAgICAgIHJlcGVhdCB0aGUgdHdlZW4gcmVnYXJkbGVzcyBmaXJzdCBydW4sXG5cdCAgICAgICAgIGZvciBpbnN0YW5jZSByZXBlYXQ6IDIgd2lsbCBtYWtlIHRoZSB0d2VlbiBydW4gMyB0aW1lcyAqL1xuXHQgICAgICByZXBlYXQ6IDAsXG5cdCAgICAgIC8qIHNwZWVkIG9mIHBsYXliYWNrIFswLi7iiJ5dLCBzcGVlZCB0aGF0IGlzIGxlc3MgdGhlbiAxXG5cdCAgICAgICAgIHdpbGwgc2xvd2Rvd24gcGxheWJhY2ssIGZvciBpbnN0YW5jZSAuNSB3aWxsIG1ha2UgdHdlZW5cblx0ICAgICAgICAgcnVuIDJ4IHNsb3dlci4gU3BlZWQgb2YgMiB3aWxsIHNwZWVkdXAgdGhlIHR3ZWVuIHRvIDJ4LiAqL1xuXHQgICAgICBzcGVlZDogMSxcblx0ICAgICAgLyogIGZsaXAgb25VcGRhdGUncyBwcm9ncmVzcyBvbiBlYWNoIGV2ZW4gcGVyaW9kLlxuXHQgICAgICAgICAgbm90ZSB0aGF0IGNhbGxiYWNrcyBvcmRlciB3b24ndCBmbGlwIGF0IGxlYXN0XG5cdCAgICAgICAgICBmb3Igbm93ICh1bmRlciBjb25zaWRlcmF0aW9uKS4gKi9cblx0ICAgICAgaXNZb3lvOiBmYWxzZSxcblx0ICAgICAgLyogZWFzaW5nIGZvciB0aGUgdHdlZW4sIGNvdWxkIGJlIGFueSBlYXNpbmcgdHlwZSBbbGluayB0byBlYXNpbmctdHlwZXMubWRdICovXG5cdCAgICAgIGVhc2luZzogJ1Npbi5PdXQnLFxuXHQgICAgICAvKlxuXHQgICAgICAgIEVhc2luZyBmb3IgYmFja3dhcmQgZGlyZWN0aW9uIG9mIHRoZSB0d2VlbnRoZSB0d2Vlbixcblx0ICAgICAgICBpZiBgbnVsbGAgLSBmYWxsYmFja3MgdG8gYGVhc2luZ2AgcHJvcGVydHkuXG5cdCAgICAgICAgZm9yd2FyZCBkaXJlY3Rpb24gaW4gYHlveW9gIHBlcmlvZCBpcyB0cmVhdGVkIGFzIGJhY2t3YXJkIGZvciB0aGUgZWFzaW5nLlxuXHQgICAgICAqL1xuXHQgICAgICBiYWNrd2FyZEVhc2luZzogbnVsbCxcblx0ICAgICAgLyogY3VzdG9tIHR3ZWVuJ3MgbmFtZSAqL1xuXHQgICAgICBuYW1lOiBudWxsLFxuXHQgICAgICAvKiBjdXN0b20gdHdlZW4ncyBiYXNlIG5hbWUgKi9cblx0ICAgICAgbmFtZUJhc2U6ICdUd2VlbicsXG5cdCAgICAgIC8qXG5cdCAgICAgICAgb25Qcm9ncmVzcyBjYWxsYmFjayBydW5zIGJlZm9yZSBhbnkgb3RoZXIgY2FsbGJhY2suXG5cdCAgICAgICAgQHBhcmFtIHtOdW1iZXJ9ICAgVGhlIGVudGlyZSwgbm90IGVhc2VkLCBwcm9ncmVzc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSB0d2VlbiByZWdhcmRpbmcgcmVwZWF0IG9wdGlvbi5cblx0ICAgICAgICBAcGFyYW0ge0Jvb2xlYW59ICBUaGUgZGlyZWN0aW9uIG9mIHRoZSB0d2Vlbi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBgdHJ1ZWAgZm9yIGZvcndhcmQgZGlyZWN0aW9uLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGBmYWxzZWAgZm9yIGJhY2t3YXJkIGRpcmVjdGlvbih0d2VlbiBydW5zIGluIHJldmVyc2UpLlxuXHQgICAgICAqL1xuXHQgICAgICBvblByb2dyZXNzOiBudWxsLFxuXHQgICAgICAvKlxuXHQgICAgICAgIG9uU3RhcnQgY2FsbGJhY2sgcnVucyBvbiB2ZXJ5IHN0YXJ0IG9mIHRoZSB0d2VlbiBqdXN0IGFmdGVyIG9uUHJvZ3Jlc3Ncblx0ICAgICAgICBvbmUuIFJ1bnMgb24gdmVyeSBlbmQgb2YgdGhlIHR3ZWVuIGlmIHR3ZWVuIGlzIHJldmVyc2VkLlxuXHQgICAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gIERpcmVjdGlvbiBvZiB0aGUgdHdlZW4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgYHRydWVgIGZvciBmb3J3YXJkIGRpcmVjdGlvbi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBgZmFsc2VgIGZvciBiYWNrd2FyZCBkaXJlY3Rpb24odHdlZW4gcnVucyBpbiByZXZlcnNlKS5cblx0ICAgICAgKi9cblx0ICAgICAgb25TdGFydDogbnVsbCxcblx0ICAgICAgb25SZWZyZXNoOiBudWxsLFxuXHQgICAgICBvbkNvbXBsZXRlOiBudWxsLFxuXHQgICAgICBvblJlcGVhdFN0YXJ0OiBudWxsLFxuXHQgICAgICBvblJlcGVhdENvbXBsZXRlOiBudWxsLFxuXHQgICAgICBvbkZpcnN0VXBkYXRlOiBudWxsLFxuXHQgICAgICBvblVwZGF0ZTogbnVsbCxcblx0ICAgICAgaXNDaGFpbmVkOiBmYWxzZSxcblx0ICAgICAgLy8gcGxheWJhY2sgY2FsbGJhY2tzXG5cdCAgICAgIG9uUGxheWJhY2tTdGFydDogbnVsbCxcblx0ICAgICAgb25QbGF5YmFja1BhdXNlOiBudWxsLFxuXHQgICAgICBvblBsYXliYWNrU3RvcDogbnVsbCxcblx0ICAgICAgb25QbGF5YmFja0NvbXBsZXRlOiBudWxsLFxuXHQgICAgICAvLyBjb250ZXh0IHdoaWNoIGFsbCBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgd2l0aFxuXHQgICAgICBjYWxsYmFja3NDb250ZXh0OiBudWxsXG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcGxheSB0aGUgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gIHtOdW1iZXJ9IFNoaWZ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHQgICAgQHJldHVybiB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuXHQgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncGxheScgJiYgdGhpcy5faXNSdW5uaW5nKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fcHJvcHMuaXNSZXZlcnNlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fc3ViUGxheShzaGlmdCwgJ3BsYXknKTtcblx0ICAgIHRoaXMuX3NldFBsYXliYWNrU3RhdGUoJ3BsYXknKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcGxheSB0aGUgVHdlZW4gaW4gcmV2ZXJzZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnBsYXlCYWNrd2FyZCA9IGZ1bmN0aW9uIHBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuXHQgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncmV2ZXJzZScgJiYgdGhpcy5faXNSdW5uaW5nKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fcHJvcHMuaXNSZXZlcnNlZCA9IHRydWU7XG5cdCAgICB0aGlzLl9zdWJQbGF5KHNoaWZ0LCAncmV2ZXJzZScpO1xuXHQgICAgdGhpcy5fc2V0UGxheWJhY2tTdGF0ZSgncmV2ZXJzZScpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBwYXVzZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG5cdCAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdwYXVzZScgfHwgdGhpcy5fc3RhdGUgPT09ICdzdG9wJykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIHRoaXMuX3JlbW92ZUZyb21Ud2VlbmVyKCk7XG5cdCAgICB0aGlzLl9zZXRQbGF5YmFja1N0YXRlKCdwYXVzZScpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBzdG9wIHRoZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IFByb2dyZXNzIFswLi4xXSB0byBzZXQgd2hlbiBzdG9wcGVkLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AocHJvZ3Jlc3MpIHtcblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3N0b3AnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl93YXNVa25vd25VcGRhdGUgPSB1bmRlZmluZWQ7XG5cblx0ICAgIHZhciBzdG9wUHJvYyA9IHByb2dyZXNzICE9IG51bGwgPyBwcm9ncmVzc1xuXHQgICAgLyogaWYgbm8gcHJvZ3Jlc3MgcGFzc3NlZCAtIHNldCAxIGlmIHR3ZWVuXG5cdCAgICAgICBpcyBwbGF5aW5nQmFja3dhcmQsIG90aGVyd2lzZSBzZXQgdG8gMCAqL1xuXHQgICAgOiB0aGlzLl9zdGF0ZSA9PT0gJ3JldmVyc2UnID8gMSA6IDA7XG5cblx0ICAgIHRoaXMuc2V0UHJvZ3Jlc3Moc3RvcFByb2MpO1xuXG5cdCAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIHJlcGxheShyZXN0YXJ0KSB0aGUgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gICB7TnVtYmVyfSBTaGlmdCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnJlcGxheSA9IGZ1bmN0aW9uIHJlcGxheSgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuXHQgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgdGhpcy5wbGF5KHNoaWZ0KTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcmVwbGF5KHJlc3RhcnQpIGJhY2t3YXJkIHRoZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IFNoaWZ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUucmVwbGF5QmFja3dhcmQgPSBmdW5jdGlvbiByZXBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuXHQgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgdGhpcy5wbGF5QmFja3dhcmQoc2hpZnQpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byByZXN1bWUgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICB7TnVtYmVyfSBTaGlmdCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0ICAgIEByZXR1cm4ge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuXG5cdCAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdwYXVzZScpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHN3aXRjaCAodGhpcy5fcHJldlN0YXRlKSB7XG5cdCAgICAgIGNhc2UgJ3BsYXknOlxuXHQgICAgICAgIHRoaXMucGxheShzaGlmdCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgJ3JldmVyc2UnOlxuXHQgICAgICAgIHRoaXMucGxheUJhY2t3YXJkKHNoaWZ0KTtcblx0ICAgICAgICBicmVhaztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBzZXQgcHJvZ3Jlc3Mgb24gdHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gc2V0LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBzZXRQcm9ncmVzcyhwcm9ncmVzcykge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIHNldCBzdGFydCB0aW1lIGlmIHRoZXJlIGlzIG5vIG9uZSB5ZXQuXG5cdCAgICAhcC5zdGFydFRpbWUgJiYgdGhpcy5fc2V0U3RhcnRUaW1lKCk7XG5cdCAgICAvLyByZXNldCBwbGF5IHRpbWVcblx0ICAgIHRoaXMuX3BsYXlUaW1lID0gbnVsbDtcblx0ICAgIC8vIHByb2dyZXNzIHNob3VsZCBiZSBpbiByYW5nZSBvZiBbMC4uMV1cblx0ICAgIHByb2dyZXNzIDwgMCAmJiAocHJvZ3Jlc3MgPSAwKTtcblx0ICAgIHByb2dyZXNzID4gMSAmJiAocHJvZ3Jlc3MgPSAxKTtcblx0ICAgIC8vIHVwZGF0ZSBzZWxmIHdpdGggY2FsY3VsYXRlZCB0aW1lXG5cdCAgICB0aGlzLl91cGRhdGUocC5zdGFydFRpbWUgLSBwLmRlbGF5ICsgcHJvZ3Jlc3MgKiBwLnJlcGVhdFRpbWUpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCB0d2VlbidzIHNwZWVkLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFNwZWVkIHZhbHVlLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuc2V0U3BlZWQgPSBmdW5jdGlvbiBzZXRTcGVlZChzcGVlZCkge1xuXHQgICAgdGhpcy5fcHJvcHMuc3BlZWQgPSBzcGVlZDtcblx0ICAgIC8vIGlmIHBsYXlpbmcgLSBub3JtYWxpemUgX3N0YXJ0VGltZSBhbmQgX3ByZXZUaW1lIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuXHQgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncGxheScgfHwgdGhpcy5fc3RhdGUgPT09ICdyZXZlcnNlJykge1xuXHQgICAgICB0aGlzLl9zZXRSZXN1bWVUaW1lKHRoaXMuX3N0YXRlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXNldCB0d2VlbidzIHN0YXRlIGFuZCBwcm9wZXJ0aWVzLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0ICAgIHRoaXMuX3JlbW92ZUZyb21Ud2VlbmVyKCk7XG5cdCAgICB0aGlzLl9zZXRQbGF5YmFja1N0YXRlKCdzdG9wJyk7XG5cdCAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSAwO1xuXHQgICAgdGhpcy5faXNDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5faXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuXHQgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5fcHJldlRpbWUgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLl9wcmV2WW95byA9IHVuZGVmaW5lZDtcblx0ICAgIC8vIHRoaXMuX3Byb3BzLnN0YXJ0VGltZSAgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLl9wcm9wcy5pc1JldmVyc2VkID0gZmFsc2U7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gXiBQVUJMSUMgIE1FVEhPRChTKSBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRChTKSB2XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxhdW5jaCBwbGF5LiBVc2VkIGFzIGxhdW5jaFxuXHQgICAgbWV0aG9kIGZvciBib3RocGxheSBhbmQgcmV2ZXJzZSBtZXRob2RzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcGFyYW0gIHtTdHJpbmd9IFBsYXkgb3IgcmV2ZXJzZSBzdGF0ZS5cblx0ICAgIEByZXR1cm4ge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3N1YlBsYXkgPSBmdW5jdGlvbiBfc3ViUGxheSgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblx0ICAgIHZhciBzdGF0ZSA9IGFyZ3VtZW50c1sxXTtcblxuXHQgICAgdmFyIHJlc3VtZVRpbWUsXG5cdCAgICAgICAgc3RhcnRUaW1lLFxuXHQgICAgICAgIHAgPSB0aGlzLl9wcm9wcyxcblxuXHQgICAgLy8gY2hlY2sgaWYgZGlyZWN0aW9uIG9mIHBsYXliYWNrIGNoYW5nZXMsXG5cdCAgICAvLyBpZiBzbywgdGhlIF9wcm9ncmVzc1RpbWUgbmVlZHMgdG8gYmUgZmxpcHBlZFxuXHQgICAgX3N0YXRlID0gdGhpcy5fc3RhdGUsXG5cdCAgICAgICAgX3ByZXZTdGF0ZSA9IHRoaXMuX3ByZXZTdGF0ZSxcblx0ICAgICAgICBpc1BhdXNlID0gX3N0YXRlID09PSAncGF1c2UnLFxuXHQgICAgICAgIHdhc1BsYXkgPSBfc3RhdGUgPT09ICdwbGF5JyB8fCBpc1BhdXNlICYmIF9wcmV2U3RhdGUgPT09ICdwbGF5Jyxcblx0ICAgICAgICB3YXNSZXZlcnNlID0gX3N0YXRlID09PSAncmV2ZXJzZScgfHwgaXNQYXVzZSAmJiBfcHJldlN0YXRlID09PSAncmV2ZXJzZScsXG5cdCAgICAgICAgaXNGbGlwID0gd2FzUGxheSAmJiBzdGF0ZSA9PT0gJ3JldmVyc2UnIHx8IHdhc1JldmVyc2UgJiYgc3RhdGUgPT09ICdwbGF5JztcblxuXHQgICAgLy8gaWYgdHdlZW4gd2FzIGVuZGVkLCBzZXQgcHJvZ3Jlc3MgdG8gMCBpZiBub3QsIHNldCB0byBlbGFwc2VkIHByb2dyZXNzXG5cdCAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSB0aGlzLl9wcm9ncmVzc1RpbWUgPj0gcC5yZXBlYXRUaW1lID8gMCA6IHRoaXMuX3Byb2dyZXNzVGltZTtcblx0ICAgIC8vIGZsaXAgdGhlIF9wcm9ncmVzc1RpbWUgaWYgcGxheWJhY2sgZGlyZWN0aW9uIGNoYW5nZWRcblx0ICAgIGlmIChpc0ZsaXApIHtcblx0ICAgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gcC5yZXBlYXRUaW1lIC0gdGhpcy5fcHJvZ3Jlc3NUaW1lO1xuXHQgICAgfVxuXHQgICAgLy8gc2V0IHJlc3VtZSB0aW1lIGFuZCBub3JtYWxpemUgcHJldi9zdGFydCB0aW1lc1xuXHQgICAgdGhpcy5fc2V0UmVzdW1lVGltZShzdGF0ZSwgc2hpZnQpO1xuXHQgICAgLy8gYWRkIHNlbGYgdG8gdHdlZW5lciA9IHBsYXlcblx0ICAgIF90d2VlbmVyMi5kZWZhdWx0LmFkZCh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgX3Jlc3VtZVRpbWUsIF9zdGFydFRpbWUgYW5kIF9wcmV2VGltZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gQ3VycmVudCBzdGF0ZS4gW3BsYXksIHJldmVyc2VdXG5cdCAgICBAcGFyYW0ge051bWJlcn0gVGltZSBzaGlmdC4gKkRlZmF1bHQqIGlzIDAuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRSZXN1bWVUaW1lID0gZnVuY3Rpb24gX3NldFJlc3VtZVRpbWUoc3RhdGUpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuXHQgICAgLy8gZ2V0IGN1cnJlbnQgbW9tZW50IGFzIHJlc3VtZSB0aW1lXG5cdCAgICB0aGlzLl9yZXN1bWVUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdCAgICAvLyBzZXQgc3RhcnQgdGltZSByZWdhcmRpbmcgcGFzc2VkIGBzaGlmdGAgYW5kIGBwcm9jVGltZWBcblx0ICAgIHZhciBzdGFydFRpbWUgPSB0aGlzLl9yZXN1bWVUaW1lIC0gTWF0aC5hYnMoc2hpZnQpIC0gdGhpcy5fcHJvZ3Jlc3NUaW1lO1xuXHQgICAgdGhpcy5fc2V0U3RhcnRUaW1lKHN0YXJ0VGltZSwgZmFsc2UpO1xuXHQgICAgLy8gaWYgd2UgaGF2ZSBwcmV2VGltZSAtIHdlIG5lZWQgdG8gbm9ybWFsaXplXG5cdCAgICAvLyBpdCBmb3IgdGhlIGN1cnJlbnQgcmVzdW1lIHRpbWVcblx0ICAgIGlmICh0aGlzLl9wcmV2VGltZSAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX3ByZXZUaW1lID0gc3RhdGUgPT09ICdwbGF5JyA/IHRoaXMuX25vcm1QcmV2VGltZUZvcndhcmQoKSA6IHRoaXMuX3Byb3BzLmVuZFRpbWUgLSB0aGlzLl9wcm9ncmVzc1RpbWU7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHJlY2FsY3VsYXRlIF9wcmV2VGltZSBmb3IgZm9yd2FyZCBkaXJlY3Rpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybiB7TnVtYmVyfSBOb3JtYWxpemVkIHByZXYgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX25vcm1QcmV2VGltZUZvcndhcmQgPSBmdW5jdGlvbiBfbm9ybVByZXZUaW1lRm9yd2FyZCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByZXR1cm4gcC5zdGFydFRpbWUgKyB0aGlzLl9wcm9ncmVzc1RpbWUgLSBwLmRlbGF5O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIENvbnN0cnVjdG9yIG9mIHRoZSBjbGFzcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgZnVuY3Rpb24gVHdlZW4oKSB7XG5cdCAgICB2YXIgX3JldDtcblxuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVHdlZW4pO1xuXG5cdCAgICB2YXIgX3RoaXMgPSAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9Nb2R1bGUuY2FsbCh0aGlzLCBvKSk7XG5cblx0ICAgIF90aGlzLl9wcm9wcy5uYW1lID09IG51bGwgJiYgX3RoaXMuX3NldFNlbGZOYW1lKCk7XG5cdCAgICByZXR1cm4gX3JldCA9IF90aGlzLCAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgc2VsZiBuYW1lIHRvIGdlbmVyaWMgb25lLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3NldFNlbGZOYW1lID0gZnVuY3Rpb24gX3NldFNlbGZOYW1lKCkge1xuXHQgICAgdmFyIGdsb2JhbE5hbWUgPSAnXycgKyB0aGlzLl9wcm9wcy5uYW1lQmFzZSArICdzJztcblx0ICAgIC8vIHRyYWNrIGFtb3VudCBvZiB0d2VlbnMgZ2xvYmFsbHlcblx0ICAgIF90d2VlbmVyMi5kZWZhdWx0W2dsb2JhbE5hbWVdID0gX3R3ZWVuZXIyLmRlZmF1bHRbZ2xvYmFsTmFtZV0gPT0gbnVsbCA/IDEgOiArK190d2VlbmVyMi5kZWZhdWx0W2dsb2JhbE5hbWVdO1xuXHQgICAgLy8gYW5kIHNldCBnZW5lcmljIHR3ZWVuJ3MgbmFtZSAgfHwgVHdlZW4gIyB8fFxuXHQgICAgdGhpcy5fcHJvcHMubmFtZSA9IHRoaXMuX3Byb3BzLm5hbWVCYXNlICsgJyAnICsgX3R3ZWVuZXIyLmRlZmF1bHRbZ2xvYmFsTmFtZV07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHNldCBwbGF5YmFjayBzdGF0ZSBzdHJpbmcuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFN0YXRlIG5hbWVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3NldFBsYXliYWNrU3RhdGUgPSBmdW5jdGlvbiBfc2V0UGxheWJhY2tTdGF0ZShzdGF0ZSkge1xuXHQgICAgLy8gc2F2ZSBwcmV2aW91cyBzdGF0ZVxuXHQgICAgdGhpcy5fcHJldlN0YXRlID0gdGhpcy5fc3RhdGU7XG5cdCAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuXG5cdCAgICAvLyBjYWxsYmFja3Ncblx0ICAgIHZhciB3YXNQYXVzZSA9IHRoaXMuX3ByZXZTdGF0ZSA9PT0gJ3BhdXNlJyxcblx0ICAgICAgICB3YXNTdG9wID0gdGhpcy5fcHJldlN0YXRlID09PSAnc3RvcCcsXG5cdCAgICAgICAgd2FzUGxheSA9IHRoaXMuX3ByZXZTdGF0ZSA9PT0gJ3BsYXknLFxuXHQgICAgICAgIHdhc1JldmVyc2UgPSB0aGlzLl9wcmV2U3RhdGUgPT09ICdyZXZlcnNlJyxcblx0ICAgICAgICB3YXNQbGF5aW5nID0gd2FzUGxheSB8fCB3YXNSZXZlcnNlLFxuXHQgICAgICAgIHdhc1N0aWxsID0gd2FzU3RvcCB8fCB3YXNQYXVzZTtcblxuXHQgICAgaWYgKChzdGF0ZSA9PT0gJ3BsYXknIHx8IHN0YXRlID09PSAncmV2ZXJzZScpICYmIHdhc1N0aWxsKSB7XG5cdCAgICAgIHRoaXMuX3BsYXliYWNrU3RhcnQoKTtcblx0ICAgIH1cblx0ICAgIGlmIChzdGF0ZSA9PT0gJ3BhdXNlJyAmJiB3YXNQbGF5aW5nKSB7XG5cdCAgICAgIHRoaXMuX3BsYXliYWNrUGF1c2UoKTtcblx0ICAgIH1cblx0ICAgIGlmIChzdGF0ZSA9PT0gJ3N0b3AnICYmICh3YXNQbGF5aW5nIHx8IHdhc1BhdXNlKSkge1xuXHQgICAgICB0aGlzLl9wbGF5YmFja1N0b3AoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBzb21lIHZhcnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG5cdCAgICB0aGlzLl9wcmV2VGltZSA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuX3Byb2dyZXNzVGltZSA9IDA7XG5cdCAgICB0aGlzLl9uZWdhdGl2ZVNoaWZ0ID0gMDtcblx0ICAgIHRoaXMuX3N0YXRlID0gJ3N0b3AnO1xuXHQgICAgLy8gaWYgbmVnYXRpdmUgZGVsYXkgd2FzIHNwZWNpZmllZCxcblx0ICAgIC8vIHNhdmUgaXQgdG8gX25lZ2F0aXZlU2hpZnQgcHJvcGVydHkgYW5kXG5cdCAgICAvLyByZXNldCBpdCBiYWNrIHRvIDBcblx0ICAgIGlmICh0aGlzLl9wcm9wcy5kZWxheSA8IDApIHtcblx0ICAgICAgdGhpcy5fbmVnYXRpdmVTaGlmdCA9IHRoaXMuX3Byb3BzLmRlbGF5O1xuXHQgICAgICB0aGlzLl9wcm9wcy5kZWxheSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgdHdlZW4ncyBkaW1lbnRpb25zLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX2NhbGNEaW1lbnRpb25zID0gZnVuY3Rpb24gX2NhbGNEaW1lbnRpb25zKCkge1xuXHQgICAgdGhpcy5fcHJvcHMudGltZSA9IHRoaXMuX3Byb3BzLmR1cmF0aW9uICsgdGhpcy5fcHJvcHMuZGVsYXk7XG5cdCAgICB0aGlzLl9wcm9wcy5yZXBlYXRUaW1lID0gdGhpcy5fcHJvcHMudGltZSAqICh0aGlzLl9wcm9wcy5yZXBlYXQgKyAxKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZXh0ZW5kIGRlZmF1bHRzIGJ5IG9wdGlvbnMgYW5kIHB1dCB0aGVtIGluIF9wcm9wcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIF9leHRlbmREZWZhdWx0cygpIHtcblx0ICAgIC8vIHNhdmUgY2FsbGJhY2sgb3ZlcnJpZGVzIG9iamVjdCB3aXRoIGZhbGxiYWNrIHRvIGVtcHR5IG9uZVxuXHQgICAgdGhpcy5fY2FsbGJhY2tPdmVycmlkZXMgPSB0aGlzLl9vLmNhbGxiYWNrT3ZlcnJpZGVzIHx8IHt9O1xuXHQgICAgZGVsZXRlIHRoaXMuX28uY2FsbGJhY2tPdmVycmlkZXM7XG5cdCAgICAvLyBjYWxsIHRoZSBfZXh0ZW5kRGVmYXVsdHMgQCBNb2R1bGVcblx0ICAgIF9Nb2R1bGUucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cy5jYWxsKHRoaXMpO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcC5lYXNpbmcgPSBfZWFzaW5nMi5kZWZhdWx0LnBhcnNlRWFzaW5nKHAuZWFzaW5nKTtcblx0ICAgIHAuZWFzaW5nLl9wYXJlbnQgPSB0aGlzO1xuXG5cdCAgICAvLyBwYXJzZSBvbmx5IHByZXNlbnQgYmFja3dhcmQgZWFzaW5nIHRvIHByZXZlbnQgcGFyc2luZyBhcyBgbGluZWFyLm5vbmVgXG5cdCAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZmFsbGJhY2sgdG8gYGVhc2luZ2AgaW4gYF9zZXRQcm9ncmVzc2AgbWV0aG9kXG5cdCAgICBpZiAocC5iYWNrd2FyZEVhc2luZyAhPSBudWxsKSB7XG5cdCAgICAgIHAuYmFja3dhcmRFYXNpbmcgPSBfZWFzaW5nMi5kZWZhdWx0LnBhcnNlRWFzaW5nKHAuYmFja3dhcmRFYXNpbmcpO1xuXHQgICAgICBwLmJhY2t3YXJkRWFzaW5nLl9wYXJlbnQgPSB0aGlzO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBmb3Igc2V0dGluZyBzdGFydCBhbmQgZW5kIHRpbWUgdG8gcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXIoVGltZXN0YW1wKX0sIHtOdWxsfSBTdGFydCB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBTaG91bGQgcmVzZXQgZmxhZ3MuXG5cdCAgICBAcmV0dXJucyB0aGlzXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRTdGFydFRpbWUgPSBmdW5jdGlvbiBfc2V0U3RhcnRUaW1lKHRpbWUpIHtcblx0ICAgIHZhciBpc1Jlc2V0RmxhZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc2hpZnRUaW1lID0gcC5zaGlmdFRpbWUgfHwgMDtcblx0ICAgIC8vIHJlc2V0IGZsYWdzXG5cdCAgICBpZiAoaXNSZXNldEZsYWdzKSB7XG5cdCAgICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7dGhpcy5faXNSZXBlYXRDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgdGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvLyBzZXQgc3RhcnQgdGltZSB0byBwYXNzZWQgdGltZSBvciB0byB0aGUgY3VycmVudCBtb21lbnRcblx0ICAgIHZhciBzdGFydFRpbWUgPSB0aW1lID09IG51bGwgPyBwZXJmb3JtYW5jZS5ub3coKSA6IHRpbWU7XG5cdCAgICAvLyBjYWxjdWxhdGUgYm91bmRzXG5cdCAgICAvLyAtIG5lZ2F0aXZlU2hpZnQgaXMgbmVnYXRpdmUgZGVsYXkgaW4gb3B0aW9ucyBoYXNoXG5cdCAgICAvLyAtIHNoaWZ0IHRpbWUgaXMgc2hpZnQgb2YgdGhlIHBhcmVudFxuXHQgICAgcC5zdGFydFRpbWUgPSBzdGFydFRpbWUgKyBwLmRlbGF5ICsgdGhpcy5fbmVnYXRpdmVTaGlmdCArIHNoaWZ0VGltZTtcblx0ICAgIHAuZW5kVGltZSA9IHAuc3RhcnRUaW1lICsgcC5yZXBlYXRUaW1lIC0gcC5kZWxheTtcblx0ICAgIC8vIHNldCBwbGF5IHRpbWUgdG8gdGhlIHN0YXJ0VGltZXNcblx0ICAgIC8vIGlmIHBsYXliYWNrIGNvbnRyb2xzIGFyZSB1c2VkIC0gdXNlIF9yZXN1bWVUaW1lIGFzIHBsYXkgdGltZSxcblx0ICAgIC8vIGVsc2UgdXNlIHNoaWZ0ZWQgc3RhcnRUaW1lIC0tIHNoaWZ0IGlzIG5lZWRlZCBmb3IgdGltZWxpbmVzIGFwcGVuZCBjaGFpbnNcblx0ICAgIHRoaXMuX3BsYXlUaW1lID0gdGhpcy5fcmVzdW1lVGltZSAhPSBudWxsID8gdGhpcy5fcmVzdW1lVGltZSA6IHN0YXJ0VGltZSArIHNoaWZ0VGltZTtcblx0ICAgIHRoaXMuX3Jlc3VtZVRpbWUgPSBudWxsO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdXBkYXRlIHR3ZWVuJ3MgcHJvZ3Jlc3MuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgdXBkYXRlIHRpbWUuXG5cdCAgICAtLSBuZXh0IHBhcmFtcyBvbmx5IHByZXNlbnQgd2hlbiBwYXJlbnQgVGltZWxpbmUgY2FsbHMgdGhlIG1ldGhvZC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcmV2aW91cyBUaW1lbGluZSdzIHVwZGF0ZSB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBXYXMgcGFyZW50IGluIHlveW8gcGVyaW9kLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFstMSwgMCwgMV0gSWYgdXBkYXRlIGlzIG9uIGVkZ2UuXG5cdCAgICAgICAgICAgICAgICAgICAtMSA9IGVkZ2UganVtcCBpbiBuZWdhdGl2ZSBkaXJlY3Rpb24uXG5cdCAgICAgICAgICAgICAgICAgICAgMCA9IG5vIGVkZ2UganVtcC5cblx0ICAgICAgICAgICAgICAgICAgICAxID0gZWRnZSBqdW1wIGluIHBvc2l0aXZlIGRpcmVjdGlvbi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUodGltZSwgdGltZWxpbmVQcmV2VGltZSwgd2FzWW95bywgb25FZGdlKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgLy8gaWYgd2UgZG9uJ3QgdGhlIF9wcmV2VGltZSB0aHVzIHRoZSBkaXJlY3Rpb24gd2UgYXJlIGhlYWRpbmcgdG8sXG5cdCAgICAvLyBidXQgcHJldlRpbWUgd2FzIHBhc3NlZCB0aHVzIHdlIGFyZSBjaGlsZCBvZiBhIFRpbWVsaW5lXG5cdCAgICAvLyBzZXQgX3ByZXZUaW1lIHRvIHBhc3NlZCBvbmUgYW5kIHByZXRlbnQgdGhhdCB0aGVyZSB3YXMgdW5rbm93blxuXHQgICAgLy8gdXBkYXRlIHRvIG5vdCB0byBibG9jayBzdGFydC9jb21wbGV0ZSBjYWxsYmFja3Ncblx0ICAgIGlmICh0aGlzLl9wcmV2VGltZSA9PSBudWxsICYmIHRpbWVsaW5lUHJldlRpbWUgIT0gbnVsbCkge1xuXG5cdCAgICAgIGlmICh0aGlzLl9wcm9wcy5zcGVlZCAmJiB0aGlzLl9wbGF5VGltZSkge1xuXHQgICAgICAgIC8vIHBsYXkgcG9pbnQgKyAoIHNwZWVkICogZGVsdGEgKVxuXHQgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdGhpcy5fcGxheVRpbWUgKyB0aGlzLl9wcm9wcy5zcGVlZCAqICh0aW1lbGluZVByZXZUaW1lIC0gdGhpcy5fcGxheVRpbWUpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHRoaXMuX3ByZXZUaW1lID0gdGltZWxpbmVQcmV2VGltZTtcblx0ICAgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gdmFyIGJlZm9yZSA9IHRpbWU7XG5cdCAgICAvLyBjYWNoZSB2YXJzXG5cdCAgICB2YXIgc3RhcnRQb2ludCA9IHAuc3RhcnRUaW1lIC0gcC5kZWxheTtcblx0ICAgIC8vIGlmIHNwZWVkIHBhcmFtIHdhcyBkZWZpbmVkIC0gY2FsY3VsYXRlXG5cdCAgICAvLyBuZXcgdGltZSByZWdhcmRpbmcgc3BlZWRcblx0ICAgIGlmIChwLnNwZWVkICYmIHRoaXMuX3BsYXlUaW1lKSB7XG5cdCAgICAgIC8vIHBsYXkgcG9pbnQgKyAoIHNwZWVkICogZGVsdGEgKVxuXHQgICAgICB0aW1lID0gdGhpcy5fcGxheVRpbWUgKyBwLnNwZWVkICogKHRpbWUgLSB0aGlzLl9wbGF5VGltZSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGR1ZSB0byBqYXZhc2NyaXB0IHByZWNpc2lvbiBpc3N1ZXMsIGFmdGVyIHNwZWVkIG1hcHBpbmdcblx0ICAgIC8vIHdlIGNhbiBnZXQgdmVyeSBjbG9zZSBudW1iZXIgdGhhdCB3YXMgbWFkZSBmcm9tIHByb2dyZXNzIG9mIDFcblx0ICAgIC8vIGFuZCBpbiBmYWN0IHJlcHJlc2VudHMgYGVuZFRpbWVgIGlmIHNvLCBzZXQgdGhlIHRpbWUgdG8gYGVuZFRpbWVgXG5cdCAgICBpZiAoTWF0aC5hYnMocC5lbmRUaW1lIC0gdGltZSkgPCAwLjAwMDAwMDAxKSB7XG5cdCAgICAgIHRpbWUgPSBwLmVuZFRpbWU7XG5cdCAgICB9XG5cblx0ICAgIC8vIGlmIHBhcmVudCBpcyBvbkVkZ2UgYnV0IG5vdCB2ZXJ5IHN0YXJ0IG5vciB2ZXJ5IGVuZFxuXHQgICAgaWYgKG9uRWRnZSAmJiB3YXNZb3lvICE9IG51bGwpIHtcblx0ICAgICAgdmFyIFQgPSB0aGlzLl9nZXRQZXJpb2QodGltZSksXG5cdCAgICAgICAgICBpc1lveW8gPSAhIShwLmlzWW95byAmJiB0aGlzLl9wcm9wcy5yZXBlYXQgJiYgVCAlIDIgPT09IDEpO1xuXG5cdCAgICAgIC8vIGZvciB0aW1lbGluZVxuXHQgICAgICAvLyBub3RpZnkgY2hpbGRyZW4gYWJvdXQgZWRnZSBqdW1wXG5cdCAgICAgIGlmICh0aGlzLl90aW1lbGluZXMpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgdGhpcy5fdGltZWxpbmVzW2ldLl91cGRhdGUodGltZSwgdGltZWxpbmVQcmV2VGltZSwgd2FzWW95bywgb25FZGdlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gZm9yd2FyZCBlZGdlIGRpcmVjdGlvblxuXHQgICAgICBpZiAob25FZGdlID09PSAxKSB7XG5cdCAgICAgICAgLy8ganVtcGVkIGZyb20geW95byBwZXJpb2Q/XG5cdCAgICAgICAgaWYgKHdhc1lveW8pIHtcblx0ICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdGltZSArIDE7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lIC0gMTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdENvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBiYWNrd2FyZCBlZGdlIGRpcmVjdGlvblxuXHQgICAgICB9IGVsc2UgaWYgKG9uRWRnZSA9PT0gLTEpIHtcblx0ICAgICAgICAvLyBqdW1wZWQgZnJvbSB5b3lvIHBlcmlvZD9cblx0ICAgICAgICBpZiAod2FzWW95bykge1xuXHQgICAgICAgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lIC0gMTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdENvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBjYWxsIF9zdGFydCBjYWxsYmFja3Mgb25seSBpZiBwcmV2IHRpbWUgd2FzIGluIGFjdGl2ZSBhcmVhXG5cdCAgICAgICAgICAvLyBub3QgYWx3YXlzIHRydWUgZm9yIGFwcGVuZCBjaGFpbnNcblx0ICAgICAgICAgIGlmICh0aGlzLl9wcmV2VGltZSA+PSBwLnN0YXJ0VGltZSAmJiB0aGlzLl9wcmV2VGltZSA8PSBwLmVuZFRpbWUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lICsgMTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgICAgLy8gcmVzZXQgaXNDT21wbGV0ZWQgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBvbkNvbXBsZXRlIGNiXG5cdCAgICAgICAgICAgIHRoaXMuX2lzQ29tcGxldGVkID0gdHJ1ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gcmVzZXQgdGhlIF9wcmV2VGltZSAtIGRyb3Agb25lIGZyYW1lIHRvIHVuZGVzdGFuZFxuXHQgICAgICAvLyB3aGVyZSB3ZSBhcmUgaGVhZGluZ1xuXHQgICAgICB0aGlzLl9wcmV2VGltZSA9IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIC8vIGlmIGluIGFjdGl2ZSBhcmVhIGFuZCBub3QgZW5kZWQgLSBzYXZlIHByb2dyZXNzIHRpbWVcblx0ICAgIC8vIGZvciBwYXVzZS9wbGF5IHB1cnBvc2VzLlxuXHQgICAgaWYgKHRpbWUgPiBzdGFydFBvaW50ICYmIHRpbWUgPCBwLmVuZFRpbWUpIHtcblx0ICAgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gdGltZSAtIHN0YXJ0UG9pbnQ7XG5cdCAgICB9XG5cdCAgICAvLyBlbHNlIGlmIG5vdCBzdGFydGVkIG9yIGVuZGVkIHNldCBwcm9ncmVzcyB0aW1lIHRvIDBcblx0ICAgIGVsc2UgaWYgKHRpbWUgPD0gc3RhcnRQb2ludCkge1xuXHQgICAgICAgIHRoaXMuX3Byb2dyZXNzVGltZSA9IDA7XG5cdCAgICAgIH0gZWxzZSBpZiAodGltZSA+PSBwLmVuZFRpbWUpIHtcblx0ICAgICAgICAvLyBzZXQgcHJvZ3Jlc3MgdGltZSB0byByZXBlYXQgdGltZSArIHRpbnkgY29mZmljaWVudFxuXHQgICAgICAgIC8vIHRvIG1ha2UgaXQgZXh0ZW5kIGZ1cnRoZXIgdGhhbiB0aGUgZW5kIHRpbWVcblx0ICAgICAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSBwLnJlcGVhdFRpbWUgKyAuMDAwMDAwMDAwMDE7XG5cdCAgICAgIH1cblx0ICAgIC8vIHJldmVyc2UgdGltZSBpZiBfcHJvcHMuaXNSZXZlcnNlZCBpcyBzZXRcblx0ICAgIGlmIChwLmlzUmV2ZXJzZWQpIHtcblx0ICAgICAgdGltZSA9IHAuZW5kVGltZSAtIHRoaXMuX3Byb2dyZXNzVGltZTtcblx0ICAgIH1cblx0ICAgIC8vIFdlIG5lZWQgdG8ga25vdyB3aGF0IGRpcmVjdGlvbiB3ZSBhcmUgaGVhZGluZyB0byxcblx0ICAgIC8vIHNvIGlmIHdlIGRvbid0IGhhdmUgdGhlIHByZXZpb3VzIHVwZGF0ZSB2YWx1ZSAtIHRoaXMgaXMgdmVyeSBmaXJzdFxuXHQgICAgLy8gdXBkYXRlLCAtIHNraXAgaXQgZW50aXJlbHkgYW5kIHdhaXQgZm9yIHRoZSBuZXh0IHZhbHVlXG5cdCAgICBpZiAodGhpcy5fcHJldlRpbWUgPT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9wcmV2VGltZSA9IHRpbWU7XG5cdCAgICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IHRydWU7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgLy8gPT09PT09IEFGVEVSIFNLSVBQRUQgRlJBTUUgPT09PT09XG5cblx0ICAgIC8vIGhhbmRsZSBvblByb2dyZXNzIGNhbGxiYWNrXG5cdCAgICBpZiAodGltZSA+PSBzdGFydFBvaW50ICYmIHRpbWUgPD0gcC5lbmRUaW1lKSB7XG5cdCAgICAgIHRoaXMuX3Byb2dyZXNzKCh0aW1lIC0gc3RhcnRQb2ludCkgLyBwLnJlcGVhdFRpbWUsIHRpbWUpO1xuXHQgICAgfVxuXHQgICAgLypcblx0ICAgICAgaWYgdGltZSBpcyBpbnNpZGUgdGhlIGFjdGl2ZSBhcmVhIG9mIHRoZSB0d2Vlbi5cblx0ICAgICAgYWN0aXZlIGFyZWEgaXMgdGhlIGFyZWEgZnJvbSBzdGFydCB0aW1lIHRvIGVuZCB0aW1lLFxuXHQgICAgICB3aXRoIGFsbCB0aGUgcmVwZWF0IGFuZCBkZWxheXMgaW4gaXRcblx0ICAgICovXG5cdCAgICBpZiAodGltZSA+PSBwLnN0YXJ0VGltZSAmJiB0aW1lIDw9IHAuZW5kVGltZSkge1xuXHQgICAgICB0aGlzLl91cGRhdGVJbkFjdGl2ZUFyZWEodGltZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBpZiB3YXMgaW4gYWN0aXZlIGFyZWEgLSB1cGRhdGUgaW4gaW5hY3RpdmUgYXJlYSBidXQganVzdCBvbmNlIC1cblx0ICAgICAgLy8gcmlnaHQgYWZ0ZXIgdGhlIGFjdGl2ZSBhcmVhXG5cdCAgICAgIGlmICh0aGlzLl9pc0luQWN0aXZlQXJlYSkge1xuXHQgICAgICAgIHRoaXMuX3VwZGF0ZUluSW5hY3RpdmVBcmVhKHRpbWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1JlZnJlc2hlZCkge1xuXHQgICAgICAgIC8vIG9uUmVmcmVzaCBjYWxsYmFja1xuXHQgICAgICAgIC8vIGJlZm9yZSBzdGFydFRpbWVcblx0ICAgICAgICBpZiAodGltZSA8IHAuc3RhcnRUaW1lICYmIHRoaXMucHJvZ3Jlc3MgIT09IDApIHtcblx0ICAgICAgICAgIHRoaXMuX3JlZnJlc2godHJ1ZSk7XG5cdCAgICAgICAgICB0aGlzLl9pc1JlZnJlc2hlZCA9IHRydWU7XG5cdCAgICAgICAgICAvLyBhZnRlciBlbmRUaW1lXG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGVsc2UgaWYgKCB0aW1lID4gcC5lbmRUaW1lICkgeyB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lO1xuXHQgICAgcmV0dXJuIHRpbWUgPj0gcC5lbmRUaW1lIHx8IHRpbWUgPD0gc3RhcnRQb2ludDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaGFuZGxlIHR3ZWVuJ3MgcHJvZ3Jlc3MgaW4gaW5hY3RpdmUgYXJlYS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZUluSW5hY3RpdmVBcmVhID0gZnVuY3Rpb24gX3VwZGF0ZUluSW5hY3RpdmVBcmVhKHRpbWUpIHtcblx0ICAgIGlmICghdGhpcy5faXNJbkFjdGl2ZUFyZWEpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIGNvbXBsZXRlIGlmIHRpbWUgaXMgbGFyZ2VyIHRoZW4gZW5kIHRpbWVcblx0ICAgIGlmICh0aW1lID4gcC5lbmRUaW1lICYmICF0aGlzLl9pc0NvbXBsZXRlZCkge1xuXHQgICAgICB0aGlzLl9wcm9ncmVzcygxLCB0aW1lKTtcblx0ICAgICAgLy8gZ2V0IHBlcmlvZCBudW1iZXJcblx0ICAgICAgdmFyIFQgPSB0aGlzLl9nZXRQZXJpb2QocC5lbmRUaW1lKSxcblx0ICAgICAgICAgIGlzWW95byA9IHAuaXNZb3lvICYmIFQgJSAyID09PSAwO1xuXG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKGlzWW95byA/IDAgOiAxLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgd2FzIGFjdGl2ZSBhbmQgd2VudCB0byAtIGluYWN0aXZlIGFyZWEgXCItXCJcblx0ICAgIGlmICh0aW1lIDwgdGhpcy5fcHJldlRpbWUgJiYgdGltZSA8IHAuc3RhcnRUaW1lICYmICF0aGlzLl9pc1N0YXJ0ZWQgJiYgIXRoaXMuX2lzQ29tcGxldGVkKSB7XG5cdCAgICAgIC8vIGlmIHdhcyBpbiBhY3RpdmUgYXJlYSBhbmQgZGlkbid0IGZpcmUgb25TdGFydCBjYWxsYmFja1xuXHQgICAgICB0aGlzLl9wcm9ncmVzcygwLCB0aW1lLCBmYWxzZSk7XG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKDAsIHRpbWUsIGZhbHNlKTtcblx0ICAgICAgdGhpcy5faXNSZXBlYXRTdGFydCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBmYWxzZSk7XG5cdCAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGZhbHNlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzSW5BY3RpdmVBcmVhID0gZmFsc2U7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGhhbmRsZSB0d2VlbidzIHByb2dyZXNzIGluIGFjdGl2ZSBhcmVhLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fdXBkYXRlSW5BY3RpdmVBcmVhID0gZnVuY3Rpb24gX3VwZGF0ZUluQWN0aXZlQXJlYSh0aW1lKSB7XG5cblx0ICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGRlbGF5RHVyYXRpb24gPSBwcm9wcy5kZWxheSArIHByb3BzLmR1cmF0aW9uLFxuXHQgICAgICAgIHN0YXJ0UG9pbnQgPSBwcm9wcy5zdGFydFRpbWUgLSBwcm9wcy5kZWxheSxcblx0ICAgICAgICBlbGFwc2VkID0gKHRpbWUgLSBwcm9wcy5zdGFydFRpbWUgKyBwcm9wcy5kZWxheSkgJSBkZWxheUR1cmF0aW9uLFxuXHQgICAgICAgIFRDb3VudCA9IE1hdGgucm91bmQoKHByb3BzLmVuZFRpbWUgLSBwcm9wcy5zdGFydFRpbWUgKyBwcm9wcy5kZWxheSkgLyBkZWxheUR1cmF0aW9uKSxcblx0ICAgICAgICBUID0gdGhpcy5fZ2V0UGVyaW9kKHRpbWUpLFxuXHQgICAgICAgIFRWYWx1ZSA9IHRoaXMuX2RlbGF5VCxcblx0ICAgICAgICBwcmV2VCA9IHRoaXMuX2dldFBlcmlvZCh0aGlzLl9wcmV2VGltZSksXG5cdCAgICAgICAgVFByZXZWYWx1ZSA9IHRoaXMuX2RlbGF5VDtcblxuXHQgICAgLy8gXCJ6ZXJvXCIgYW5kIFwib25lXCIgdmFsdWUgcmVnYXJkaW5nIHlveW8gYW5kIGl0J3MgcGVyaW9kXG5cdCAgICB2YXIgaXNZb3lvID0gcHJvcHMuaXNZb3lvICYmIFQgJSAyID09PSAxLFxuXHQgICAgICAgIGlzWW95b1ByZXYgPSBwcm9wcy5pc1lveW8gJiYgcHJldlQgJSAyID09PSAxLFxuXHQgICAgICAgIHlveW9aZXJvID0gaXNZb3lvID8gMSA6IDAsXG5cdCAgICAgICAgeW95b09uZSA9IDEgLSB5b3lvWmVybztcblxuXHQgICAgaWYgKHRpbWUgPT09IHByb3BzLmVuZFRpbWUpIHtcblx0ICAgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gZmFsc2U7XG5cdCAgICAgIC8vIGlmIGB0aW1lYCBpcyBlcXVhbCB0byBgZW5kVGltZWAsIFQgcmVwcmVzZW50cyB0aGUgbmV4dCBwZXJpb2QsXG5cdCAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZGVjcmVtZW50IFQgYW5kIGNhbGN1bGF0ZSBcIm9uZVwiIHZhbHVlIHJlZ2FyZGluZyB5b3lvXG5cdCAgICAgIHZhciBpc1lveW8gPSBwcm9wcy5pc1lveW8gJiYgKFQgLSAxKSAlIDIgPT09IDE7XG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKGlzWW95byA/IDAgOiAxLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICBpZiAodGltZSA+IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgdGhpcy5faXNSZXBlYXRDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgIH1cblxuXHQgICAgLy8gcmVzZXQgY2FsbGJhY2sgZmxhZ3Ncblx0ICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9pc1JlZnJlc2hlZCA9IGZhbHNlO1xuXHQgICAgLy8gaWYgdGltZSBpcyBpbnNpZGUgdGhlIGR1cmF0aW9uIGFyZWEgb2YgdGhlIHR3ZWVuXG5cdCAgICBpZiAoc3RhcnRQb2ludCArIGVsYXBzZWQgPj0gcHJvcHMuc3RhcnRUaW1lKSB7XG5cdCAgICAgIHRoaXMuX2lzSW5BY3RpdmVBcmVhID0gdHJ1ZTt0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9pc1JlcGVhdFN0YXJ0ID0gZmFsc2U7dGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG5cdCAgICAgIC8vIGFjdGl2ZSB6b25lIG9yIGxhcmdlciB0aGVuIGVuZFxuXHQgICAgICB2YXIgZWxhcHNlZDIgPSAodGltZSAtIHByb3BzLnN0YXJ0VGltZSkgJSBkZWxheUR1cmF0aW9uLFxuXHQgICAgICAgICAgcHJvYyA9IGVsYXBzZWQyIC8gcHJvcHMuZHVyYXRpb247XG5cdCAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPj4+XG5cdCAgICAgIC8vICAgICAgXjFeMlxuXHQgICAgICB2YXIgaXNPbkVkZ2UgPSBUID4gMCAmJiBwcmV2VCA8IFQ7XG5cdCAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPDw8XG5cdCAgICAgIC8vICAgICAgXjJeMVxuXHQgICAgICB2YXIgaXNPblJldmVyc2VFZGdlID0gcHJldlQgPiBUO1xuXG5cdCAgICAgIC8vIGZvciB1c2UgaW4gdGltZWxpbmVcblx0ICAgICAgdGhpcy5fb25FZGdlID0gMDtcblx0ICAgICAgaXNPbkVkZ2UgJiYgKHRoaXMuX29uRWRnZSA9IDEpO1xuXHQgICAgICBpc09uUmV2ZXJzZUVkZ2UgJiYgKHRoaXMuX29uRWRnZSA9IC0xKTtcblxuXHQgICAgICBpZiAodGhpcy5fd2FzVWtub3duVXBkYXRlKSB7XG5cdCAgICAgICAgaWYgKHRpbWUgPiB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9maXJzdFVwZGF0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBiYWNrd2FyZCBkaXJlY3Rpb24gYW5kIFxuXHQgICAgICAgIC8vIGlmICggdGltZSA8IHRoaXMuX3ByZXZUaW1lICYmIHRpbWUgIT09IHRoaXMuX3Byb3BzLnN0YXJ0VGltZSApIHtcblx0ICAgICAgICBpZiAodGltZSA8IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX2ZpcnN0VXBkYXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICAvLyByZXNldCBpc0NvbXBsZXRlZCBpbW1lZGlhdGVseVxuXHQgICAgICAgICAgdGhpcy5faXNDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaXNPbkVkZ2UpIHtcblx0ICAgICAgICAvLyBpZiBub3QganVzdCBhZnRlciBkZWxheVxuXHQgICAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPj4+XG5cdCAgICAgICAgLy8gICAgICAgICAgICBeMSBeMlxuXHQgICAgICAgIC8vIGJlY2F1c2Ugd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcblx0ICAgICAgICAvLyAxIGFuZCBvblJlcGVhdENvbXBsZXRlIGluIGRlbGF5IGdhcFxuXHQgICAgICAgIGlmICh0aGlzLnByb2dyZXNzICE9PSAxKSB7XG5cdCAgICAgICAgICAvLyBwcmV2VFxuXHQgICAgICAgICAgdmFyIGlzVGhpc1lveW8gPSBwcm9wcy5pc1lveW8gJiYgKFQgLSAxKSAlIDIgPT09IDE7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1RoaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYgb24gZWRnZSBidXQgbm90IGF0IHZlcnkgc3RhcnRcblx0ICAgICAgICAvLyB8PT09PT18PT09PT18PT09PT18ID4+PlxuXHQgICAgICAgIC8vIF4hICAgIF5oZXJlIF5oZXJlIFxuXHQgICAgICAgIGlmIChwcmV2VCA+PSAwKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aW1lID4gdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAvLyAgfD09PT09fD09PT09fD09PT09fCA+Pj5cblx0ICAgICAgICAvLyBeMSAgXjJcblx0ICAgICAgICBpZiAoIXRoaXMuX2lzU3RhcnRlZCAmJiB0aGlzLl9wcmV2VGltZSA8PSBwcm9wcy5zdGFydFRpbWUpIHtcblx0ICAgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgLy8gaXQgd2FzIHplcm8gYW55d2F5c1xuXG5cdCAgICAgICAgICAvLyByZXN0YXJ0IGZsYWdzIGltbWVkaWF0ZWx5IGluIGNhc2UgaWYgd2Ugd2lsbFxuXHQgICAgICAgICAgLy8gcmV0dXJuIHRvICctJyBpbmFjdGl2ZSBhcmVhIG9uIHRoZSBuZXh0IHN0ZXBcblx0ICAgICAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgdGhpcy5faXNSZXBlYXRTdGFydCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9maXJzdFVwZGF0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlzT25SZXZlcnNlRWRnZSkge1xuXHQgICAgICAgIC8vIGlmIG9uIGVkZ2UgYnV0IG5vdCBhdCB2ZXJ5IGVuZFxuXHQgICAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPDw8XG5cdCAgICAgICAgLy8gICAgICAgXmhlcmUgXmhlcmUgXm5vdCBoZXJlXG5cdCAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgIT09IDAgJiYgdGhpcy5wcm9ncmVzcyAhPT0gMSAmJiBwcmV2VCAhPSBUQ291bnQpIHtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95b1ByZXYpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBvbiB2ZXJ5IGVuZCBlZGdlXG5cdCAgICAgICAgLy8gfD09PT09fD09PT09fD09PT09fCA8PDxcblx0ICAgICAgICAvLyAgICAgICBeISAgICBeISBeMiBeMVxuXHQgICAgICAgIC8vIHdlIGhhdmUgaGFuZGxlZCB0aGUgY2FzZSBpbiB0aGlzLl93YXNVa25vd25VcGRhdGVcblx0ICAgICAgICAvLyBibG9jayBzbyBmaWx0ZXIgdGhhdFxuXHQgICAgICAgIGlmIChwcmV2VCA9PT0gVENvdW50ICYmICF0aGlzLl93YXNVa25vd25VcGRhdGUpIHtcblx0ICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fZmlyc3RVcGRhdGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIC8vIHJlc2V0IGlzQ29tcGxldGUgZmxhZyBjYWxsXG5cdCAgICAgICAgICAvLyBjdXogd2UgcmV0dXJuZWQgdG8gYWN0aXZlIGFyZWFcblx0ICAgICAgICAgIC8vIHRoaXMuX2lzUmVwZWF0Q29tcGxldGVkID0gZmFsc2U7XG5cdCAgICAgICAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHByZXZUID09PSAnZGVsYXknKSB7XG5cdCAgICAgICAgLy8gaWYganVzdCBiZWZvcmUgZGVsYXkgZ2FwXG5cdCAgICAgICAgLy8gfC0tLT09PT09fC0tLT09PT09fC0tLT09PT09fCA8PDxcblx0ICAgICAgICAvLyAgICAgICAgICAgICAgIF4yICAgIF4xXG5cdCAgICAgICAgaWYgKFQgPCBUUHJldlZhbHVlKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBqdXN0IGFmdGVyIGRlbGF5IGdhcFxuXHQgICAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPj4+XG5cdCAgICAgICAgLy8gICAgICAgICAgICBeMSAgXjJcblx0ICAgICAgICBpZiAoVCA9PT0gVFByZXZWYWx1ZSAmJiBUID4gMCkge1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBzd2FwIHByb2dyZXNzIGFuZCByZXBlYXRTdGFydCBiYXNlZCBvbiBkaXJlY3Rpb25cblx0ICAgICAgaWYgKHRpbWUgPiB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgIC8vIGlmIHByb2dyZXNzIGlzIGVxdWFsIDAgYW5kIHByb2dyZXNzIGdyb3dzXG5cdCAgICAgICAgaWYgKHByb2MgPT09IDApIHtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0aW1lICE9PSBwcm9wcy5lbmRUaW1lKSB7XG5cdCAgICAgICAgICB0aGlzLl9zZXRQcm9ncmVzcyhpc1lveW8gPyAxIC0gcHJvYyA6IHByb2MsIHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0aW1lICE9PSBwcm9wcy5lbmRUaW1lKSB7XG5cdCAgICAgICAgICB0aGlzLl9zZXRQcm9ncmVzcyhpc1lveW8gPyAxIC0gcHJvYyA6IHByb2MsIHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGlmIHByb2dyZXNzIGlzIGVxdWFsIDAgYW5kIHByb2dyZXNzIGdyb3dzXG5cdCAgICAgICAgaWYgKHByb2MgPT09IDApIHtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRpbWUgPT09IHByb3BzLnN0YXJ0VGltZSkge1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gZGVsYXkgZ2FwIC0gcmVhY3Qgb25seSBvbmNlXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX2lzSW5BY3RpdmVBcmVhKSB7XG5cdCAgICAgIC8vIGJlY2F1c2UgVCB3aWxsIGJlIHN0cmluZyBvZiBcImRlbGF5XCIgaGVyZSxcblx0ICAgICAgLy8gbGV0J3Mgbm9ybWFsaXplIGl0IGJlIHNldHRpbmcgdG8gVFZhbHVlXG5cdCAgICAgIHZhciB0ID0gVCA9PT0gJ2RlbGF5JyA/IFRWYWx1ZSA6IFQsXG5cdCAgICAgICAgICBpc0dyb3dzID0gdGltZSA+IHRoaXMuX3ByZXZUaW1lO1xuXHQgICAgICAvLyBkZWNyZW1lbnQgcGVyaW9kIGlmIGZvcndhcmQgZGlyZWN0aW9uIG9mIHVwZGF0ZVxuXHQgICAgICBpc0dyb3dzICYmIHQtLTtcblx0ICAgICAgLy8gY2FsY3VsYXRlIG5vcm1hbGl6ZWQgeW95b1plcm8gdmFsdWVcblx0ICAgICAgeW95b1plcm8gPSBwcm9wcy5pc1lveW8gJiYgdCAlIDIgPT09IDEgPyAxIDogMDtcblx0ICAgICAgLy8gaWYgd2FzIGluIGFjdGl2ZSBhcmVhIGFuZCBwcmV2aW91cyB0aW1lIHdhcyBsYXJnZXJcblx0ICAgICAgLy8gfC0tLT09PT09fC0tLT09PT09fC0tLT09PT09fCA8PDxcblx0ICAgICAgLy8gICBeMiBeMSAgICBeMiBeMSAgICBeMiBeMVxuXHQgICAgICBpZiAodGltZSA8IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoeW95b1plcm8sIHRpbWUsIHlveW9aZXJvID09PSAxKTtcblx0ICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCB5b3lvWmVybyA9PT0gMSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gc2V0IDEgb3IgMCByZWdhcmRpbmcgZGlyZWN0aW9uIGFuZCB5b3lvXG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKGlzR3Jvd3MgPyAxIC0geW95b1plcm8gOiB5b3lvWmVybywgdGltZSwgeW95b1plcm8gPT09IDEpO1xuXHQgICAgICAvLyBpZiB0aW1lIGdyb3dzXG5cdCAgICAgIGlmICh0aW1lID4gdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAvLyBpZiByZXZlcnNlIGRpcmVjdGlvbiBhbmQgaW4gZGVsYXkgZ2FwLCB0aGVuIHByb2dyZXNzIHdpbGwgYmUgMFxuXHQgICAgICAgIC8vIGlmIHNvIHdlIGRvbid0IG5lZWQgdG8gY2FsbCB0aGUgb25SZXBlYXRDb21wbGV0ZSBjYWxsYmFja1xuXHQgICAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPDw8XG5cdCAgICAgICAgLy8gICBeMCAgICAgICBeMCAgICAgICBeMCAgIFxuXHQgICAgICAgIC8vIE9SIHdlIGhhdmUgZmxpcHBlZCAwIHRvIDEgcmVnYXJkaW5nIHlveW8gb3B0aW9uXG5cdCAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgIT09IDAgfHwgeW95b1plcm8gPT09IDEpIHtcblx0ICAgICAgICAgIC8vIHNpbmNlIHdlIHJlcGVhdENvbXBsZXRlIGZvciBwcmV2aW91cyBwZXJpb2Rcblx0ICAgICAgICAgIC8vIGludmVydCBpc1lveW8gb3B0aW9uXG5cdCAgICAgICAgICAvLyBpcyBlbGFwc2VkIGlzIDAgLSBjb3VudCBhcyBwcmV2aW91cyBwZXJpb2Rcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdENvbXBsZXRlKHRpbWUsIHlveW9aZXJvID09PSAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgLy8gc2V0IGZsYWcgdG8gaW5kaWNhdGUgaW5hY3RpdmUgYXJlYVxuXHQgICAgICB0aGlzLl9pc0luQWN0aXZlQXJlYSA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgLy8gd2UndmUgZ290IHRoZSBmaXJzdCB1cGRhdGUgbm93XG5cdCAgICB0aGlzLl93YXNVa25vd25VcGRhdGUgPSBmYWxzZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVtb3ZlIHRoZSBUd2VlbiBmcm9tIHRoZSB0d2VlbmVyLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9yZW1vdmVGcm9tVHdlZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tVHdlZW5lcigpIHtcblx0ICAgIF90d2VlbmVyMi5kZWZhdWx0LnJlbW92ZSh0aGlzKTtyZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGN1cnJlbnQgcGVyaW9kIG51bWJlci5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gVGltZSB0byBnZXQgdGhlIHBlcmlvZCBmb3IuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBDdXJyZW50IHBlcmlvZCBudW1iZXIuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9nZXRQZXJpb2QgPSBmdW5jdGlvbiBfZ2V0UGVyaW9kKHRpbWUpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgVFRpbWUgPSBwLmRlbGF5ICsgcC5kdXJhdGlvbixcblx0ICAgICAgICBkVGltZSA9IHAuZGVsYXkgKyB0aW1lIC0gcC5zdGFydFRpbWUsXG5cdCAgICAgICAgVCA9IGRUaW1lIC8gVFRpbWUsXG5cblx0ICAgIC8vIGlmIHRpbWUgaWYgZXF1YWwgdG8gZW5kVGltZSB3ZSBuZWVkIHRvIHNldCB0aGUgZWxhcHNlZFxuXHQgICAgLy8gdGltZSB0byAwIHRvIGZpeCB0aGUgb2NjYXNpb25hbCBwcmVjaXNpb24ganMgYnVnLCB3aGljaFxuXHQgICAgLy8gY2F1c2VzIDAgdG8gYmUgc29tZXRoaW5nIGxpa2UgMWUtMTJcblx0ICAgIGVsYXBzZWQgPSB0aW1lIDwgcC5lbmRUaW1lID8gZFRpbWUgJSBUVGltZSA6IDA7XG5cdCAgICAvLyBJZiB0aGUgbGF0ZXN0IHBlcmlvZCwgcm91bmQgdGhlIHJlc3VsdCwgb3RoZXJ3aXNlIGZsb29yIGl0LlxuXHQgICAgLy8gQmFzaWNhbGx5IHdlIGFsd2F5cyBjYW4gZmxvb3IgdGhlIHJlc3VsdCwgYnV0IGJlY2F1c2Ugb2YganNcblx0ICAgIC8vIHByZWNpc2lvbiBpc3N1ZXMsIHNvbWV0aW1lcyB0aGUgcmVzdWx0IGlzIDIuOTk5OTk5OTggd2hpY2hcblx0ICAgIC8vIHdpbGwgcmVzdWx0IGluIDIgaW5zdGVhZCBvZiAzIGFmdGVyIHRoZSBmbG9vciBvcGVyYXRpb24uXG5cdCAgICBUID0gdGltZSA+PSBwLmVuZFRpbWUgPyBNYXRoLnJvdW5kKFQpIDogTWF0aC5mbG9vcihUKTtcblx0ICAgIC8vIGlmIHRpbWUgaXMgbGFyZ2VyIHRoZW4gdGhlIGVuZCB0aW1lXG5cdCAgICBpZiAodGltZSA+IHAuZW5kVGltZSkge1xuXHQgICAgICAvLyBzZXQgZXF1YWwgdG8gdGhlIHBlcmlvZHMgY291bnRcblx0ICAgICAgVCA9IE1hdGgucm91bmQoKHAuZW5kVGltZSAtIHAuc3RhcnRUaW1lICsgcC5kZWxheSkgLyBUVGltZSk7XG5cdCAgICAgIC8vIGlmIGluIGRlbGF5IGdhcCwgc2V0IF9kZWxheVQgdG8gY3VycmVudFxuXHQgICAgICAvLyBwZXJpb2QgbnVtYmVyIGFuZCByZXR1cm4gXCJkZWxheVwiXG5cdCAgICB9IGVsc2UgaWYgKGVsYXBzZWQgPiAwICYmIGVsYXBzZWQgPCBwLmRlbGF5KSB7XG5cdCAgICAgIHRoaXMuX2RlbGF5VCA9IFQ7VCA9ICdkZWxheSc7XG5cdCAgICB9XG5cdCAgICAvLyBpZiB0aGUgZW5kIG9mIHBlcmlvZCBhbmQgdGhlcmUgaXMgYSBkZWxheVxuXHQgICAgcmV0dXJuIFQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBUd2VlbidzIHByb2dyZXNzIGFuZCBjYWxsIG9uVXBkYXRlIGNhbGxiYWNrLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIE1vZHVsZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJcyB5b3lvIHBlcmlkby4gVXNlZCBpbiBUaW1lbGluZSB0byBwYXNzIHRvIFR3ZWVuLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKHByb2MsIHRpbWUsIGlzWW95bykge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBpc1lveW9DaGFuZ2VkID0gcC53YXNZb3lvICE9PSBpc1lveW8sXG5cdCAgICAgICAgaXNGb3J3YXJkID0gdGltZSA+IHRoaXMuX3ByZXZUaW1lO1xuXG5cdCAgICB0aGlzLnByb2dyZXNzID0gcHJvYztcblx0ICAgIC8vIGdldCB0aGUgY3VycmVudCBlYXNpbmcgZm9yIGBmb3J3YXJkYCBkaXJlY3Rpb24gcmVnYXJkaW5nIGB5b3lvYFxuXHQgICAgaWYgKGlzRm9yd2FyZCAmJiAhaXNZb3lvIHx8ICFpc0ZvcndhcmQgJiYgaXNZb3lvKSB7XG5cdCAgICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IHAuZWFzaW5nKHByb2MpO1xuXHQgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgZWFzaW5nIGZvciBgYmFja3dhcmRgIGRpcmVjdGlvbiByZWdhcmRpbmcgYHlveW9gXG5cdCAgICB9IGVsc2UgaWYgKCFpc0ZvcndhcmQgJiYgIWlzWW95byB8fCBpc0ZvcndhcmQgJiYgaXNZb3lvKSB7XG5cdCAgICAgIHZhciBlYXNpbmcgPSBwLmJhY2t3YXJkRWFzaW5nICE9IG51bGwgPyBwLmJhY2t3YXJkRWFzaW5nIDogcC5lYXNpbmc7XG5cblx0ICAgICAgdGhpcy5lYXNlZFByb2dyZXNzID0gZWFzaW5nKHByb2MpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAocC5wcmV2RWFzZWRQcm9ncmVzcyAhPT0gdGhpcy5lYXNlZFByb2dyZXNzIHx8IGlzWW95b0NoYW5nZWQpIHtcblx0ICAgICAgaWYgKHAub25VcGRhdGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHAub25VcGRhdGUuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGhpcy5lYXNlZFByb2dyZXNzLCB0aGlzLnByb2dyZXNzLCBpc0ZvcndhcmQsIGlzWW95byk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHAucHJldkVhc2VkUHJvZ3Jlc3MgPSB0aGlzLmVhc2VkUHJvZ3Jlc3M7XG5cdCAgICBwLndhc1lveW8gPSBpc1lveW87XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHR3ZWVuJ3Mgc3RhdGUgdG8gc3RhcnQgYW5kIGNhbGwgb25TdGFydCBjYWxsYmFjay5cblx0ICAgIEBtZXRob2QgX3N0YXJ0XG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIF9zdGFydCh0aW1lLCBpc1lveW8pIHtcblx0ICAgIGlmICh0aGlzLl9pc1N0YXJ0ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uU3RhcnQgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25TdGFydC5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IGZhbHNlO3RoaXMuX2lzU3RhcnRlZCA9IHRydWU7XG5cdCAgICB0aGlzLl9pc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgb25QbGF5YmFja1N0YXJ0IGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tTdGFydCA9IGZ1bmN0aW9uIF9wbGF5YmFja1N0YXJ0KCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUGxheWJhY2tTdGFydCAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUGxheWJhY2tTdGFydC5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBvblBsYXliYWNrUGF1c2UgY2FsbGJhY2tcblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9wbGF5YmFja1BhdXNlID0gZnVuY3Rpb24gX3BsYXliYWNrUGF1c2UoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25QbGF5YmFja1BhdXNlICE9IG51bGwgJiYgdHlwZW9mIHAub25QbGF5YmFja1BhdXNlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25QbGF5YmFja1BhdXNlLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIG9uUGxheWJhY2tTdG9wIGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tTdG9wID0gZnVuY3Rpb24gX3BsYXliYWNrU3RvcCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblBsYXliYWNrU3RvcCAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tTdG9wID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25QbGF5YmFja1N0b3AuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcyk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgb25QbGF5YmFja0NvbXBsZXRlIGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tDb21wbGV0ZSA9IGZ1bmN0aW9uIF9wbGF5YmFja0NvbXBsZXRlKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUGxheWJhY2tDb21wbGV0ZSAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUGxheWJhY2tDb21wbGV0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHR3ZWVuJ3Mgc3RhdGUgdG8gY29tcGxldGUuXG5cdCAgICBAbWV0aG9kIF9jb21wbGV0ZVxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiBfY29tcGxldGUodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNDb21wbGV0ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uQ29tcGxldGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25Db21wbGV0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2lzQ29tcGxldGVkID0gdHJ1ZTt0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2lzRmlyc3RVcGRhdGUgPSBmYWxzZTtcblx0ICAgIC8vIHJlc2V0IF9wcmV2WW95byBmb3IgdGltZWxpbmUgdXNhZ2Vcblx0ICAgIHRoaXMuX3ByZXZZb3lvID0gdW5kZWZpbmVkO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJ1biBvbkZpcnN0VXBkYXRlIGNhbGxiYWNrLlxuXHQgICAgQG1ldGhvZCBfZmlyc3RVcGRhdGVcblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9maXJzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9maXJzdFVwZGF0ZSh0aW1lLCBpc1lveW8pIHtcblx0ICAgIGlmICh0aGlzLl9pc0ZpcnN0VXBkYXRlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vbkZpcnN0VXBkYXRlICE9IG51bGwgJiYgdHlwZW9mIHAub25GaXJzdFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAvLyBvbkZpcnN0VXBkYXRlIHNob3VsZCBoYXZlIHR3ZWVuIHBvaW50ZXJcblx0ICAgICAgcC5vbkZpcnN0VXBkYXRlLnR3ZWVuID0gdGhpcztcblx0ICAgICAgcC5vbkZpcnN0VXBkYXRlLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMsIHRpbWUgPiB0aGlzLl9wcmV2VGltZSwgaXNZb3lvKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzRmlyc3RVcGRhdGUgPSB0cnVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBjYWxsIG9uUmVwZWF0Q29tcGxldGUgY2FsYmFjayBhbmQgc2V0IGZsYWdzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJcyByZXBlYXQgcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcmVwZWF0Q29tcGxldGUgPSBmdW5jdGlvbiBfcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNSZXBlYXRDb21wbGV0ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUmVwZWF0Q29tcGxldGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblJlcGVhdENvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25SZXBlYXRDb21wbGV0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IHRydWU7XG5cdCAgICAvLyB0aGlzLl9wcmV2WW95byA9IG51bGw7XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsbCBvblJlcGVhdFN0YXJ0IGNhbGJhY2sgYW5kIHNldCBmbGFncy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9yZXBlYXRTdGFydCA9IGZ1bmN0aW9uIF9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pIHtcblx0ICAgIGlmICh0aGlzLl9pc1JlcGVhdFN0YXJ0KSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblJlcGVhdFN0YXJ0ICE9IG51bGwgJiYgdHlwZW9mIHAub25SZXBlYXRTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUmVwZWF0U3RhcnQuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGltZSA+IHRoaXMuX3ByZXZUaW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5faXNSZXBlYXRTdGFydCA9IHRydWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxhdW5jaCBvblByb2dyZXNzIGNhbGxiYWNrLlxuXHQgICAgQG1ldGhvZCBfcHJvZ3Jlc3Ncblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gc2V0LlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcHJvZ3Jlc3MgPSBmdW5jdGlvbiBfcHJvZ3Jlc3MocHJvZ3Jlc3MsIHRpbWUpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblByb2dyZXNzICE9IG51bGwgJiYgdHlwZW9mIHAub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUHJvZ3Jlc3MuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgcHJvZ3Jlc3MsIHRpbWUgPiB0aGlzLl9wcmV2VGltZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxhdW5jaCBvblJlZnJlc2ggY2FsbGJhY2suXG5cdCAgICBAbWV0aG9kIF9yZWZyZXNoXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJZiByZWZyZXNoIGV2ZW4gYmVmb3JlIHN0YXJ0IHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gX3JlZnJlc2goaXNCZWZvcmUpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblJlZnJlc2ggIT0gbnVsbCkge1xuXHQgICAgICB2YXIgY29udGV4dCA9IHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLFxuXHQgICAgICAgICAgcHJvZ3Jlc3MgPSBpc0JlZm9yZSA/IDAgOiAxO1xuXG5cdCAgICAgIHAub25SZWZyZXNoLmNhbGwoY29udGV4dCwgaXNCZWZvcmUsIHAuZWFzaW5nKHByb2dyZXNzKSwgcHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgdHdlZW4gaXMgcmVtb3ZlZCBmcm9tIHR3ZWVuZXIuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fb25Ud2VlbmVyUmVtb3ZlID0gZnVuY3Rpb24gX29uVHdlZW5lclJlbW92ZSgpIHt9O1xuXHQgIC8qXG5cdCAgICBNZXRob2Qgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIGlzIHJlbW92ZWRcblx0ICAgIGZyb20gdHdlZW5lciB3aGVuIGZpbmlzaGVkLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX29uVHdlZW5lckZpbmlzaCA9IGZ1bmN0aW9uIF9vblR3ZWVuZXJGaW5pc2goKSB7XG5cdCAgICB0aGlzLl9zZXRQbGF5YmFja1N0YXRlKCdzdG9wJyk7XG5cdCAgICB0aGlzLl9wbGF5YmFja0NvbXBsZXRlKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBwcm9wZXJ0eVtzXSBvbiBUd2Vlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0LCBTdHJpbmd9IEhhc2ggb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycywgb3IgcHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7X30gUHJvcGVydHkncyB2YWx1ZSB0byBzZXQuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRQcm9wID0gZnVuY3Rpb24gX3NldFByb3Aob2JqLCB2YWx1ZSkge1xuXHQgICAgX01vZHVsZS5wcm90b3R5cGUuX3NldFByb3AuY2FsbCh0aGlzLCBvYmosIHZhbHVlKTtcblx0ICAgIHRoaXMuX2NhbGNEaW1lbnRpb25zKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBzaW5nbGUgcHJvcGVydHkuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgTW9kdWxlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX2Fzc2lnblByb3AgPSBmdW5jdGlvbiBfYXNzaWduUHJvcChrZXksIHZhbHVlKSB7XG5cdCAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0c1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgdmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHQgICAgfVxuXHQgICAgLy8gcGFyc2UgZWFzaW5nXG5cdCAgICBpZiAoa2V5ID09PSAnZWFzaW5nJykge1xuXHQgICAgICB2YWx1ZSA9IF9lYXNpbmcyLmRlZmF1bHQucGFyc2VFYXNpbmcodmFsdWUpO1xuXHQgICAgICB2YWx1ZS5fcGFyZW50ID0gdGhpcztcblx0ICAgIH1cblx0ICAgIC8vIGhhbmRsZSBjb250cm9sIGNhbGxiYWNrcyBvdmVycmlkZXNcblx0ICAgIHZhciBjb250cm9sID0gdGhpcy5fY2FsbGJhY2tPdmVycmlkZXNba2V5XSxcblx0ICAgICAgICBpc250T3ZlcnJpZGVuID0gIXZhbHVlIHx8ICF2YWx1ZS5pc01vanNDYWxsYmFja092ZXJyaWRlO1xuXHQgICAgaWYgKGNvbnRyb2wgJiYgaXNudE92ZXJyaWRlbikge1xuXHQgICAgICB2YWx1ZSA9IHRoaXMuX292ZXJyaWRlQ2FsbGJhY2sodmFsdWUsIGNvbnRyb2wpO1xuXHQgICAgfVxuXHQgICAgLy8gY2FsbCBzdXBlciBvbiBNb2R1bGVcblx0ICAgIF9Nb2R1bGUucHJvdG90eXBlLl9hc3NpZ25Qcm9wLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIG92ZXJyaWRlIGNhbGxiYWNrIGZvciBjb250cm9sbCBwdXByb3Blcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gICAgQ2FsbGJhY2sgbmFtZS5cblx0ICAgIEBwYXJtYSB7RnVuY3Rpb259ICBNZXRob2QgdG8gY2FsbCAgXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9vdmVycmlkZUNhbGxiYWNrID0gZnVuY3Rpb24gX292ZXJyaWRlQ2FsbGJhY2soY2FsbGJhY2ssIGZ1bikge1xuXHQgICAgdmFyIGlzQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsXG5cdCAgICAgICAgb3ZlcnJpZGUgPSBmdW5jdGlvbiBjYWxsYmFja092ZXJyaWRlKCkge1xuXHQgICAgICAvLyBjYWxsIG92ZXJyaWRlbiBjYWxsYmFjayBpZiBpdCBleGlzdHNcblx0ICAgICAgaXNDYWxsYmFjayAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAvLyBjYWxsIHRoZSBwYXNzZWQgY2xlYW51cCBmdW5jdGlvblxuXHQgICAgICBmdW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cdCAgICAvLyBhZGQgb3ZlcnJpZGRlbiBmbGFnXG5cdCAgICBvdmVycmlkZS5pc01vanNDYWxsYmFja092ZXJyaWRlID0gdHJ1ZTtcblx0ICAgIHJldHVybiBvdmVycmlkZTtcblx0ICB9O1xuXG5cdCAgLy8gX3Zpc3VhbGl6ZVByb2dyZXNzKHRpbWUpIHtcblx0ICAvLyAgIHZhciBzdHIgPSAnfCcsXG5cdCAgLy8gICAgICAgcHJvY1N0ciA9ICcgJyxcblx0ICAvLyAgICAgICBwID0gdGhpcy5fcHJvcHMsXG5cdCAgLy8gICAgICAgcHJvYyA9IHAuc3RhcnRUaW1lIC0gcC5kZWxheTtcblxuXHQgIC8vICAgd2hpbGUgKCBwcm9jIDwgcC5lbmRUaW1lICkge1xuXHQgIC8vICAgICBpZiAocC5kZWxheSA+IDAgKSB7XG5cdCAgLy8gICAgICAgdmFyIG5ld1Byb2MgPSBwcm9jICsgcC5kZWxheTtcblx0ICAvLyAgICAgICBpZiAoIHRpbWUgPiBwcm9jICYmIHRpbWUgPCBuZXdQcm9jICkge1xuXHQgIC8vICAgICAgICAgcHJvY1N0ciArPSAnIF4gJztcblx0ICAvLyAgICAgICB9IGVsc2Uge1xuXHQgIC8vICAgICAgICAgcHJvY1N0ciArPSAnICAgJztcblx0ICAvLyAgICAgICB9XG5cdCAgLy8gICAgICAgcHJvYyA9IG5ld1Byb2M7XG5cdCAgLy8gICAgICAgc3RyICArPSAnLS0tJztcblx0ICAvLyAgICAgfVxuXHQgIC8vICAgICB2YXIgbmV3UHJvYyA9IHByb2MgKyBwLmR1cmF0aW9uO1xuXHQgIC8vICAgICBpZiAoIHRpbWUgPiBwcm9jICYmIHRpbWUgPCBuZXdQcm9jICkge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJyAgXiAgICc7XG5cdCAgLy8gICAgIH0gZWxzZSBpZiAodGltZSA9PT0gcHJvYykge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJ14gICAgICc7XG5cdCAgLy8gICAgIH0gZWxzZSBpZiAodGltZSA9PT0gbmV3UHJvYykge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJyAgICBeICc7XG5cdCAgLy8gICAgIH0gZWxzZSB7XG5cdCAgLy8gICAgICAgcHJvY1N0ciArPSAnICAgICAgJztcblx0ICAvLyAgICAgfVxuXHQgIC8vICAgICBwcm9jID0gbmV3UHJvYztcblx0ICAvLyAgICAgc3RyICs9ICc9PT09PXwnO1xuXHQgIC8vICAgfVxuXG5cdCAgLy8gICBjb25zb2xlLmxvZyhzdHIpO1xuXHQgIC8vICAgY29uc29sZS5sb2cocHJvY1N0cik7XG5cdCAgLy8gfVxuXG5cblx0ICByZXR1cm4gVHdlZW47XG5cdH0oX21vZHVsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVHdlZW47XG5cbi8qKiovIH0pLFxuLyogMTAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMDMpO1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oMTA0KTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgVHdlZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBUd2VlbmVyKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVHdlZW5lcik7XG5cblx0ICAgIHRoaXMuX3ZhcnMoKTtcblx0ICAgIHRoaXMuX2xpc3RlblZpc2liaWxpdHlDaGFuZ2UoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICB0aGlzLnR3ZWVucyA9IFtdO1xuXHQgICAgdGhpcy5fc2F2ZWRUd2VlbnMgPSBbXTtcblx0ICAgIHRoaXMuX2xvb3AgPSB0aGlzLl9sb29wLmJpbmQodGhpcyk7XG5cdCAgICB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UgPSB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UuYmluZCh0aGlzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNYWluIGFuaW1hdGlvbiBsb29wLiBTaG91bGQgaGF2ZSBvbmx5IG9uZSBjb25jdXJyZW50IGxvb3AuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMgdGhpc1xuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG5cdCAgICBpZiAoIXRoaXMuX2lzUnVubmluZykge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICB0aGlzLl91cGRhdGUod2luZG93LnBlcmZvcm1hbmNlLm5vdygpKTtcblx0ICAgIGlmICghdGhpcy50d2VlbnMubGVuZ3RoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9sb29wKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzdGFydCBhbmltYXRpb24gbG9vcC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX3N0YXJ0TG9vcCA9IGZ1bmN0aW9uIF9zdGFydExvb3AoKSB7XG5cdCAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH07dGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblx0ICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9sb29wKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc3RvcCBhbmltYXRpb24gbG9vcC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX3N0b3BMb29wID0gZnVuY3Rpb24gX3N0b3BMb29wKCkge1xuXHQgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHVwZGF0ZSBldmVyeSB0d2Vlbi90aW1lbGluZSBvbiBhbmltYXRpb24gZnJhbWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKHRpbWUpIHtcblx0ICAgIHZhciBpID0gdGhpcy50d2VlbnMubGVuZ3RoO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICAvLyBjYWNoZSB0aGUgY3VycmVudCB0d2VlblxuXHQgICAgICB2YXIgdHdlZW4gPSB0aGlzLnR3ZWVuc1tpXTtcblx0ICAgICAgaWYgKHR3ZWVuICYmIHR3ZWVuLl91cGRhdGUodGltZSkgPT09IHRydWUpIHtcblx0ICAgICAgICB0aGlzLnJlbW92ZSh0d2Vlbik7XG5cdCAgICAgICAgdHdlZW4uX29uVHdlZW5lckZpbmlzaCgpO1xuXHQgICAgICAgIHR3ZWVuLl9wcmV2VGltZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgYSBUd2Vlbi9UaW1lbGluZSB0byBsb29wIHBvb2wuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVHdlZW4vVGltZWxpbmUgdG8gYWRkLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCh0d2Vlbikge1xuXHQgICAgLy8gcmV0dXJuIGlmIHR3ZWVuIGlzIGFscmVhZHkgcnVubmluZ1xuXHQgICAgaWYgKHR3ZWVuLl9pc1J1bm5pbmcpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdHdlZW4uX2lzUnVubmluZyA9IHRydWU7XG5cdCAgICB0aGlzLnR3ZWVucy5wdXNoKHR3ZWVuKTtcblx0ICAgIHRoaXMuX3N0YXJ0TG9vcCgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBzdG9wIHVwZGF0aW5nIGFsbCB0aGUgY2hpbGQgdHdlZW5zL3RpbWVsaW5lcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUucmVtb3ZlQWxsID0gZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuXHQgICAgdGhpcy50d2VlbnMubGVuZ3RoID0gMDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVtb3ZlIHNwZWNpZmljIHR3ZWVuL3RpbWVsaW5lIGZvcm0gdXBkYXRpbmcuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSh0d2Vlbikge1xuXHQgICAgdmFyIGluZGV4ID0gdHlwZW9mIHR3ZWVuID09PSAnbnVtYmVyJyA/IHR3ZWVuIDogdGhpcy50d2VlbnMuaW5kZXhPZih0d2Vlbik7XG5cblx0ICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgdHdlZW4gPSB0aGlzLnR3ZWVuc1tpbmRleF07XG5cdCAgICAgIGlmICh0d2Vlbikge1xuXHQgICAgICAgIHR3ZWVuLl9pc1J1bm5pbmcgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLnR3ZWVucy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgIHR3ZWVuLl9vblR3ZWVuZXJSZW1vdmUoKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGluaXRpYWxpemUgZXZlbnQgbGlzdGVuZXJzIHRvIHZpc2liaWxpdHkgY2hhbmdlIGV2ZW50cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX2xpc3RlblZpc2liaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiBfbGlzdGVuVmlzaWJpbGl0eUNoYW5nZSgpIHtcblx0ICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuaGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlIaWRkZW4gPSBcImhpZGRlblwiO1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlID0gXCJ2aXNpYmlsaXR5Y2hhbmdlXCI7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUhpZGRlbiA9IFwibW96SGlkZGVuXCI7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2UgPSBcIm1venZpc2liaWxpdHljaGFuZ2VcIjtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1zSGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlIaWRkZW4gPSBcIm1zSGlkZGVuXCI7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2UgPSBcIm1zdmlzaWJpbGl0eWNoYW5nZVwiO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQud2Via2l0SGlkZGVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlIaWRkZW4gPSBcIndlYmtpdEhpZGRlblwiO1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlID0gXCJ3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlXCI7XG5cdCAgICB9XG5cblx0ICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fdmlzaWJpbGl0eUNoYW5nZSwgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlLCBmYWxzZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRoYXQgd2lsbCBmaXJlIG9uIHZpc2liaWxpdHkgY2hhbmdlLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9vblZpc2liaWxpdHlDaGFuZ2UgPSBmdW5jdGlvbiBfb25WaXNpYmlsaXR5Q2hhbmdlKCkge1xuXHQgICAgaWYgKGRvY3VtZW50W3RoaXMuX3Zpc2liaWxpdHlIaWRkZW5dKSB7XG5cdCAgICAgIHRoaXMuX3NhdmVQbGF5aW5nVHdlZW5zKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLl9yZXN0b3JlUGxheWluZ1R3ZWVucygpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzYXZlIGFsbCBwbGF5aW5nIHR3ZWVucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX3NhdmVQbGF5aW5nVHdlZW5zID0gZnVuY3Rpb24gX3NhdmVQbGF5aW5nVHdlZW5zKCkge1xuXHQgICAgdGhpcy5fc2F2ZWRUd2VlbnMgPSB0aGlzLnR3ZWVucy5zbGljZSgwKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2F2ZWRUd2VlbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fc2F2ZWRUd2VlbnNbaV0ucGF1c2UoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzdG9yZSBhbGwgcGxheWluZyB0d2VlbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl9yZXN0b3JlUGxheWluZ1R3ZWVucyA9IGZ1bmN0aW9uIF9yZXN0b3JlUGxheWluZ1R3ZWVucygpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2F2ZWRUd2VlbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fc2F2ZWRUd2VlbnNbaV0ucmVzdW1lKCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHJldHVybiBUd2VlbmVyO1xuXHR9KCk7XG5cblx0dmFyIHQgPSBuZXcgVHdlZW5lcigpO1xuXHRleHBvcnRzLmRlZmF1bHQgPSB0O1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cdCAgJ3VzZSBzdHJpY3QnO1xuXHQgIHZhciBjYW5jZWwsIGksIGlzT2xkQnJvd3NlciwgbGFzdFRpbWUsIHZlbmRvcnMsIHZwLCB3O1xuXHQgIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcblx0ICBpID0gMDtcblx0ICB3ID0gd2luZG93O1xuXHQgIHdoaWxlIChpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdCAgICB2cCA9IHZlbmRvcnNbaV07XG5cdCAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdbdnAgKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG5cdCAgICBjYW5jZWwgPSB3W3ZwICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ107XG5cdCAgICB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2FuY2VsIHx8IHdbdnAgKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG5cdCAgICArK2k7XG5cdCAgfVxuXHQgIGlzT2xkQnJvd3NlciA9ICF3LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhdy5jYW5jZWxBbmltYXRpb25GcmFtZTtcblx0ICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHcubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgaXNPbGRCcm93c2VyKSB7XG5cdCAgICBsYXN0VGltZSA9IDA7XG5cdCAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgIHZhciBuZXh0VGltZSwgbm93O1xuXHQgICAgICBub3cgPSBEYXRlLm5vdygpO1xuXHQgICAgICBuZXh0VGltZSA9IE1hdGgubWF4KGxhc3RUaW1lICsgMTYsIG5vdyk7XG5cdCAgICAgIHJldHVybiBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICBjYWxsYmFjayhsYXN0VGltZSA9IG5leHRUaW1lKTtcblx0ICAgICAgfSksIG5leHRUaW1lIC0gbm93KTtcblx0ICAgIH07XG5cdCAgICB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xuXHQgIH1cblx0fSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDEwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQoZnVuY3Rpb24ocm9vdCkge1xuXHQgIHZhciBvZmZzZXQsIHJlZiwgcmVmMTtcblx0ICBpZiAocm9vdC5wZXJmb3JtYW5jZSA9PSBudWxsKSB7XG5cdCAgICByb290LnBlcmZvcm1hbmNlID0ge307XG5cdCAgfVxuXHQgIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gKG5ldyBEYXRlKS5nZXRUaW1lKCk7XG5cdCAgfTtcblx0ICBpZiAocm9vdC5wZXJmb3JtYW5jZS5ub3cgPT0gbnVsbCkge1xuXHQgICAgb2Zmc2V0ID0gKChyZWYgPSByb290LnBlcmZvcm1hbmNlKSAhPSBudWxsID8gKHJlZjEgPSByZWYudGltaW5nKSAhPSBudWxsID8gcmVmMS5uYXZpZ2F0aW9uU3RhcnQgOiB2b2lkIDAgOiB2b2lkIDApID8gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCA6IERhdGUubm93KCk7XG5cdCAgICByZXR1cm4gcm9vdC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBvZmZzZXQ7XG5cdCAgICB9O1xuXHQgIH1cblx0fSkod2luZG93KTtcblxuXG4vKioqLyB9KSxcbi8qIDEwNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBFYXNpbmcsIFBJLCBQYXRoRWFzaW5nLCBhcHByb3hpbWF0ZSwgYmV6aWVyLCBlYXNpbmcsIGgsIG1peCwgc2luO1xuXG5cdGJlemllciA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblxuXHRQYXRoRWFzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xuXG5cdG1peCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA4KTtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0YXBwcm94aW1hdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSlbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMTA5KTtcblxuXHRzaW4gPSBNYXRoLnNpbjtcblxuXHRQSSA9IE1hdGguUEk7XG5cblx0RWFzaW5nID0gKGZ1bmN0aW9uKCkge1xuXHQgIGZ1bmN0aW9uIEVhc2luZygpIHt9XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLmJlemllciA9IGJlemllcjtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuUGF0aEVhc2luZyA9IFBhdGhFYXNpbmc7XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnBhdGggPSAobmV3IFBhdGhFYXNpbmcoJ2NyZWF0b3InKSkuY3JlYXRlO1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5hcHByb3hpbWF0ZSA9IGFwcHJveGltYXRlO1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuXHQgICAgcmV0dXJuIDEgLSBwO1xuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLmxpbmVhciA9IHtcblx0ICAgIG5vbmU6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIGs7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuZWFzZSA9IHtcblx0ICAgIFwiaW5cIjogYmV6aWVyLmFwcGx5KEVhc2luZywgWzAuNDIsIDAsIDEsIDFdKSxcblx0ICAgIG91dDogYmV6aWVyLmFwcGx5KEVhc2luZywgWzAsIDAsIDAuNTgsIDFdKSxcblx0ICAgIGlub3V0OiBiZXppZXIuYXBwbHkoRWFzaW5nLCBbMC40MiwgMCwgMC41OCwgMV0pXG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuc2luID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIFBJIC8gMik7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBzaW4oayAqIFBJIC8gMik7XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoUEkgKiBrKSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUucXVhZCA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqIGs7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBrICogKDIgLSBrKTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5jdWJpYyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqIGsgKiBrO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnF1YXJ0ID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnF1aW50ID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5leHBvID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIGlmIChrID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblx0ICAgICAgfVxuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChrID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuXHQgICAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5jaXJjID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLWsgKiBrKSk7XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuXHQgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspIC0gMSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5iYWNrID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBzO1xuXHQgICAgICBzID0gMS43MDE1ODtcblx0ICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBzO1xuXHQgICAgICBzID0gMS43MDE1ODtcblx0ICAgICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgdmFyIHM7XG5cdCAgICAgIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5lbGFzdGljID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBhLCBwLCBzO1xuXHQgICAgICBzID0gdm9pZCAwO1xuXHQgICAgICBwID0gMC40O1xuXHQgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChrID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgYSA9IDE7XG5cdCAgICAgIHMgPSBwIC8gNDtcblx0ICAgICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBhLCBwLCBzO1xuXHQgICAgICBzID0gdm9pZCAwO1xuXHQgICAgICBwID0gMC40O1xuXHQgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChrID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgYSA9IDE7XG5cdCAgICAgIHMgPSBwIC8gNDtcblx0ICAgICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBhLCBwLCBzO1xuXHQgICAgICBzID0gdm9pZCAwO1xuXHQgICAgICBwID0gMC40O1xuXHQgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChrID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgYSA9IDE7XG5cdCAgICAgIHMgPSBwIC8gNDtcblx0ICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuXHQgICAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuYm91bmNlID0ge1xuXHQgICAgXCJpblwiOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZS5vdXQoMSAtIGspO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoayA8ICgxIC8gMi43NSkpIHtcblx0ICAgICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG5cdCAgICAgIH0gZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcblx0ICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMS41IC8gMi43NSkgKiBrICsgMC43NTtcblx0ICAgICAgfSBlbHNlIGlmIChrIDwgKDIuNSAvIDIuNzUpKSB7XG5cdCAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuMjUgLyAyLjc1KSAqIGsgKyAwLjkzNzU7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoayA8IDAuNSkge1xuXHQgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlW1wiaW5cIl0oayAqIDIpICogMC41O1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlLm91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnBhcnNlRWFzaW5nID0gZnVuY3Rpb24oZWFzaW5nKSB7XG5cdCAgICB2YXIgZWFzaW5nUGFyZW50LCB0eXBlO1xuXHQgICAgaWYgKGVhc2luZyA9PSBudWxsKSB7XG5cdCAgICAgIGVhc2luZyA9ICdsaW5lYXIubm9uZSc7XG5cdCAgICB9XG5cdCAgICB0eXBlID0gdHlwZW9mIGVhc2luZztcblx0ICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAoZWFzaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpID09PSAnbScpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5wYXRoKGVhc2luZyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZWFzaW5nID0gdGhpcy5fc3BsaXRFYXNpbmcoZWFzaW5nKTtcblx0ICAgICAgICBlYXNpbmdQYXJlbnQgPSB0aGlzW2Vhc2luZ1swXV07XG5cdCAgICAgICAgaWYgKCFlYXNpbmdQYXJlbnQpIHtcblx0ICAgICAgICAgIGguZXJyb3IoXCJFYXNpbmcgd2l0aCBuYW1lIFxcXCJcIiArIGVhc2luZ1swXSArIFwiXFxcIiB3YXMgbm90IGZvdW5kLCBmYWxsYmFjayB0byBcXFwibGluZWFyLm5vbmVcXFwiIGluc3RlYWRcIik7XG5cdCAgICAgICAgICByZXR1cm4gdGhpc1snbGluZWFyJ11bJ25vbmUnXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGVhc2luZ1BhcmVudFtlYXNpbmdbMV1dO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoaC5pc0FycmF5KGVhc2luZykpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYmV6aWVyLmFwcGx5KHRoaXMsIGVhc2luZyk7XG5cdCAgICB9XG5cdCAgICBpZiAoJ2Z1bmN0aW9uJykge1xuXHQgICAgICByZXR1cm4gZWFzaW5nO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLl9zcGxpdEVhc2luZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHQgICAgdmFyIGZpcnN0UGFydCwgc2Vjb25kUGFydCwgc3BsaXQ7XG5cdCAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICByZXR1cm4gc3RyaW5nO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHN0cmluZy5sZW5ndGgpIHtcblx0ICAgICAgc3BsaXQgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0ICAgICAgZmlyc3RQYXJ0ID0gc3BsaXRbMF0udG9Mb3dlckNhc2UoKSB8fCAnbGluZWFyJztcblx0ICAgICAgc2Vjb25kUGFydCA9IHNwbGl0WzFdLnRvTG93ZXJDYXNlKCkgfHwgJ25vbmUnO1xuXHQgICAgICByZXR1cm4gW2ZpcnN0UGFydCwgc2Vjb25kUGFydF07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gWydsaW5lYXInLCAnbm9uZSddO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gRWFzaW5nO1xuXG5cdH0pKCk7XG5cblx0ZWFzaW5nID0gbmV3IEVhc2luZztcblxuXHRlYXNpbmcubWl4ID0gbWl4KGVhc2luZyk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBlYXNpbmc7XG5cblxuLyoqKi8gfSksXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIEJlemllckVhc2luZywgYmV6aWVyRWFzaW5nLCBoLFxuXHQgIGluZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblxuXHQvKipcblx0ICogQ29weXJpZ2h0IChjKSAyMDE0IEdhw6t0YW4gUmVuYXVkZWF1IGh0dHA6Ly9nb28uZ2wvRWwzazd1XG5cdCAqIEFkb3B0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcblx0ICovXG5cblx0QmV6aWVyRWFzaW5nID0gKGZ1bmN0aW9uKCkge1xuXHQgIGZ1bmN0aW9uIEJlemllckVhc2luZyhvKSB7XG5cdCAgICB0aGlzLnZhcnMoKTtcblx0ICAgIHJldHVybiB0aGlzLmdlbmVyYXRlO1xuXHQgIH1cblxuXHQgIEJlemllckVhc2luZy5wcm90b3R5cGUudmFycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUgPSBoLmJpbmQodGhpcy5nZW5lcmF0ZSwgdGhpcyk7XG5cdCAgfTtcblxuXHQgIEJlemllckVhc2luZy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcblx0ICAgIHZhciBBLCBCLCBDLCBORVdUT05fSVRFUkFUSU9OUywgTkVXVE9OX01JTl9TTE9QRSwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMsIFNVQkRJVklTSU9OX1BSRUNJU0lPTiwgX3ByZWNvbXB1dGVkLCBhcmcsIGJpbmFyeVN1YmRpdmlkZSwgY2FsY0JlemllciwgY2FsY1NhbXBsZVZhbHVlcywgZiwgZmxvYXQzMkFycmF5U3VwcG9ydGVkLCBnZXRTbG9wZSwgZ2V0VEZvclgsIGksIGosIGtTYW1wbGVTdGVwU2l6ZSwga1NwbGluZVRhYmxlU2l6ZSwgbVNhbXBsZVZhbHVlcywgbmV3dG9uUmFwaHNvbkl0ZXJhdGUsIHByZWNvbXB1dGUsIHN0cjtcblx0ICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5lcnJvcignQmV6aWVyIGZ1bmN0aW9uIGV4cGVjdHMgNCBhcmd1bWVudHMnKTtcblx0ICAgIH1cblx0ICAgIGZvciAoaSA9IGogPSAwOyBqIDwgNDsgaSA9ICsraikge1xuXHQgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG5cdCAgICAgIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKGFyZykgfHwgIWlzRmluaXRlKGFyZykpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignQmV6aWVyIGZ1bmN0aW9uIGV4cGVjdHMgNCBhcmd1bWVudHMnKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKG1YMSA8IDAgfHwgbVgxID4gMSB8fCBtWDIgPCAwIHx8IG1YMiA+IDEpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0JlemllciB4IHZhbHVlcyBzaG91bGQgYmUgPiAwIGFuZCA8IDEnKTtcblx0ICAgIH1cblx0ICAgIE5FV1RPTl9JVEVSQVRJT05TID0gNDtcblx0ICAgIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcblx0ICAgIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcblx0ICAgIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG5cdCAgICBrU3BsaW5lVGFibGVTaXplID0gMTE7XG5cdCAgICBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cdCAgICBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSBpbmRleE9mLmNhbGwoZ2xvYmFsLCAnRmxvYXQzMkFycmF5JykgPj0gMDtcblx0ICAgIEEgPSBmdW5jdGlvbihhQTEsIGFBMikge1xuXHQgICAgICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuXHQgICAgfTtcblx0ICAgIEIgPSBmdW5jdGlvbihhQTEsIGFBMikge1xuXHQgICAgICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuXHQgICAgfTtcblx0ICAgIEMgPSBmdW5jdGlvbihhQTEpIHtcblx0ICAgICAgcmV0dXJuIDMuMCAqIGFBMTtcblx0ICAgIH07XG5cdCAgICBjYWxjQmV6aWVyID0gZnVuY3Rpb24oYVQsIGFBMSwgYUEyKSB7XG5cdCAgICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcblx0ICAgIH07XG5cdCAgICBnZXRTbG9wZSA9IGZ1bmN0aW9uKGFULCBhQTEsIGFBMikge1xuXHQgICAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcblx0ICAgIH07XG5cdCAgICBuZXd0b25SYXBoc29uSXRlcmF0ZSA9IGZ1bmN0aW9uKGFYLCBhR3Vlc3NUKSB7XG5cdCAgICAgIHZhciBjdXJyZW50U2xvcGUsIGN1cnJlbnRYO1xuXHQgICAgICBpID0gMDtcblx0ICAgICAgd2hpbGUgKGkgPCBORVdUT05fSVRFUkFUSU9OUykge1xuXHQgICAgICAgIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcblxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuXHQgICAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihhR3Vlc3NULCBtWDEsIG1YMikgLSBhWDtcblx0ICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuXHQgICAgICAgICsraTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYUd1ZXNzVDtcblx0ICAgIH07XG5cdCAgICBjYWxjU2FtcGxlVmFsdWVzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIGkgPSAwO1xuXHQgICAgICB3aGlsZSAoaSA8IGtTcGxpbmVUYWJsZVNpemUpIHtcblx0ICAgICAgICBtU2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG5cdCAgICAgICAgKytpO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQgICAgYmluYXJ5U3ViZGl2aWRlID0gZnVuY3Rpb24oYVgsIGFBLCBhQikge1xuXHQgICAgICB2YXIgY3VycmVudFQsIGN1cnJlbnRYLCBpc0JpZztcblx0ICAgICAgY3VycmVudFggPSB2b2lkIDA7XG5cdCAgICAgIGN1cnJlbnRUID0gdm9pZCAwO1xuXHQgICAgICBpID0gMDtcblx0ICAgICAgd2hpbGUgKHRydWUpIHtcblx0ICAgICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuXHQgICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG5cdCAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBhQSA9IGN1cnJlbnRUO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpc0JpZyA9IE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTjtcblx0ICAgICAgICBpZiAoIShpc0JpZyAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUykpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gY3VycmVudFQ7XG5cdCAgICB9O1xuXHQgICAgZ2V0VEZvclggPSBmdW5jdGlvbihhWCkge1xuXHQgICAgICB2YXIgY3VycmVudFNhbXBsZSwgZGVsdGEsIGRpc3QsIGd1ZXNzRm9yVCwgaW5pdGlhbFNsb3BlLCBpbnRlcnZhbFN0YXJ0LCBsYXN0U2FtcGxlO1xuXHQgICAgICBpbnRlcnZhbFN0YXJ0ID0gMC4wO1xuXHQgICAgICBjdXJyZW50U2FtcGxlID0gMTtcblx0ICAgICAgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXHQgICAgICB3aGlsZSAoY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYKSB7XG5cdCAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG5cdCAgICAgICAgKytjdXJyZW50U2FtcGxlO1xuXHQgICAgICB9XG5cdCAgICAgIC0tY3VycmVudFNhbXBsZTtcblx0ICAgICAgZGVsdGEgPSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV07XG5cdCAgICAgIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIGRlbHRhO1xuXHQgICAgICBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcblx0ICAgICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cdCAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuXHQgICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcblx0ICAgICAgfSBlbHNlIHtcblxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG5cdCAgICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBwcmVjb21wdXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBfcHJlY29tcHV0ZWQ7XG5cdCAgICAgIF9wcmVjb21wdXRlZCA9IHRydWU7XG5cdCAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuXHQgICAgICAgIHJldHVybiBjYWxjU2FtcGxlVmFsdWVzKCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICBtU2FtcGxlVmFsdWVzID0gIWZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cdCAgICBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcblx0ICAgIGYgPSBmdW5jdGlvbihhWCkge1xuXHQgICAgICBpZiAoIV9wcmVjb21wdXRlZCkge1xuXHQgICAgICAgIHByZWNvbXB1dGUoKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcblx0ICAgICAgICByZXR1cm4gYVg7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGFYID09PSAwKSB7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGFYID09PSAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG5cdCAgICB9O1xuXHQgICAgc3RyID0gXCJiZXppZXIoXCIgKyBbbVgxLCBtWTEsIG1YMiwgbVkyXSArIFwiKVwiO1xuXHQgICAgZi50b1N0ciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gc3RyO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmO1xuXHQgIH07XG5cblx0ICBCZXppZXJFYXNpbmcucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24obXNnKSB7XG5cdCAgICByZXR1cm4gaC5lcnJvcihtc2cpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQmV6aWVyRWFzaW5nO1xuXG5cdH0pKCk7XG5cblx0YmV6aWVyRWFzaW5nID0gbmV3IEJlemllckVhc2luZztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGJlemllckVhc2luZztcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0pLFxuLyogMTA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIFBhdGhFYXNpbmcsIGg7XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5cdFBhdGhFYXNpbmcgPSAoZnVuY3Rpb24oKSB7XG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuX3ByZWNvbXB1dGUgPSBoLmNsYW1wKHRoaXMuby5wcmVjb21wdXRlIHx8IDE0NTAsIDEwMCwgMTAwMDApO1xuXHQgICAgdGhpcy5fc3RlcCA9IDEgLyB0aGlzLl9wcmVjb21wdXRlO1xuXHQgICAgdGhpcy5fcmVjdCA9IHRoaXMuby5yZWN0IHx8IDEwMDtcblx0ICAgIHRoaXMuX2FwcHJveGltYXRlTWF4ID0gdGhpcy5vLmFwcHJveGltYXRlTWF4IHx8IDU7XG5cdCAgICB0aGlzLl9lcHMgPSB0aGlzLm8uZXBzIHx8IDAuMDAxO1xuXHQgICAgcmV0dXJuIHRoaXMuX2JvdW5kc1ByZXZQcm9ncmVzcyA9IC0xO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBQYXRoRWFzaW5nKHBhdGgsIG8xKSB7XG5cdCAgICB0aGlzLm8gPSBvMSAhPSBudWxsID8gbzEgOiB7fTtcblx0ICAgIGlmIChwYXRoID09PSAnY3JlYXRvcicpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdGhpcy5wYXRoID0gaC5wYXJzZVBhdGgocGF0aCk7XG5cdCAgICBpZiAodGhpcy5wYXRoID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGguZXJyb3IoJ0Vycm9yIHdoaWxlIHBhcnNpbmcgdGhlIHBhdGgnKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3ZhcnMoKTtcblx0ICAgIHRoaXMucGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLl9ub3JtYWxpemVQYXRoKHRoaXMucGF0aC5nZXRBdHRyaWJ1dGUoJ2QnKSkpO1xuXHQgICAgdGhpcy5wYXRoTGVuZ3RoID0gdGhpcy5wYXRoLmdldFRvdGFsTGVuZ3RoKCk7XG5cdCAgICB0aGlzLnNhbXBsZSA9IGguYmluZCh0aGlzLnNhbXBsZSwgdGhpcyk7XG5cdCAgICB0aGlzLl9oYXJkU2FtcGxlID0gaC5iaW5kKHRoaXMuX2hhcmRTYW1wbGUsIHRoaXMpO1xuXHQgICAgdGhpcy5fcHJlU2FtcGxlKCk7XG5cdCAgICB0aGlzO1xuXHQgIH1cblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9wcmVTYW1wbGUgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBpLCBqLCBsZW5ndGgsIHBvaW50LCBwcm9ncmVzcywgcmVmLCByZXN1bHRzO1xuXHQgICAgdGhpcy5fc2FtcGxlcyA9IFtdO1xuXHQgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3ByZWNvbXB1dGU7IDAgPD0gcmVmID8gaiA8PSByZWYgOiBqID49IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG5cdCAgICAgIHByb2dyZXNzID0gaSAqIHRoaXMuX3N0ZXA7XG5cdCAgICAgIGxlbmd0aCA9IHRoaXMucGF0aExlbmd0aCAqIHByb2dyZXNzO1xuXHQgICAgICBwb2ludCA9IHRoaXMucGF0aC5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aCk7XG5cdCAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9zYW1wbGVzW2ldID0ge1xuXHQgICAgICAgIHBvaW50OiBwb2ludCxcblx0ICAgICAgICBsZW5ndGg6IGxlbmd0aCxcblx0ICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3Ncblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0cztcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2ZpbmRCb3VuZHMgPSBmdW5jdGlvbihhcnJheSwgcCkge1xuXHQgICAgdmFyIGJ1ZmZlciwgZGlyZWN0aW9uLCBlbmQsIGksIGosIGxlbiwgbG9vcEVuZCwgcG9pbnRQLCBwb2ludFgsIHJlZiwgcmVmMSwgc3RhcnQsIHZhbHVlO1xuXHQgICAgaWYgKHAgPT09IHRoaXMuX2JvdW5kc1ByZXZQcm9ncmVzcykge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcHJldkJvdW5kcztcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9ib3VuZHNTdGFydEluZGV4ID09IG51bGwpIHtcblx0ICAgICAgdGhpcy5fYm91bmRzU3RhcnRJbmRleCA9IDA7XG5cdCAgICB9XG5cdCAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG5cdCAgICBpZiAodGhpcy5fYm91bmRzUHJldlByb2dyZXNzID4gcCkge1xuXHQgICAgICBsb29wRW5kID0gMDtcblx0ICAgICAgZGlyZWN0aW9uID0gJ3JldmVyc2UnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbG9vcEVuZCA9IGxlbjtcblx0ICAgICAgZGlyZWN0aW9uID0gJ2ZvcndhcmQnO1xuXHQgICAgfVxuXHQgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG5cdCAgICAgIHN0YXJ0ID0gYXJyYXlbMF07XG5cdCAgICAgIGVuZCA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgc3RhcnQgPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcblx0ICAgICAgZW5kID0gYXJyYXlbMF07XG5cdCAgICB9XG5cdCAgICBmb3IgKGkgPSBqID0gcmVmID0gdGhpcy5fYm91bmRzU3RhcnRJbmRleCwgcmVmMSA9IGxvb3BFbmQ7IHJlZiA8PSByZWYxID8gaiA8IHJlZjEgOiBqID4gcmVmMTsgaSA9IHJlZiA8PSByZWYxID8gKytqIDogLS1qKSB7XG5cdCAgICAgIHZhbHVlID0gYXJyYXlbaV07XG5cdCAgICAgIHBvaW50WCA9IHZhbHVlLnBvaW50LnggLyB0aGlzLl9yZWN0O1xuXHQgICAgICBwb2ludFAgPSBwO1xuXHQgICAgICBpZiAoZGlyZWN0aW9uID09PSAncmV2ZXJzZScpIHtcblx0ICAgICAgICBidWZmZXIgPSBwb2ludFg7XG5cdCAgICAgICAgcG9pbnRYID0gcG9pbnRQO1xuXHQgICAgICAgIHBvaW50UCA9IGJ1ZmZlcjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAocG9pbnRYIDwgcG9pbnRQKSB7XG5cdCAgICAgICAgc3RhcnQgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLl9ib3VuZHNTdGFydEluZGV4ID0gaTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBlbmQgPSB2YWx1ZTtcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5fYm91bmRzUHJldlByb2dyZXNzID0gcDtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2Qm91bmRzID0ge1xuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogZW5kXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihwKSB7XG5cdCAgICB2YXIgYm91bmRzLCByZXM7XG5cdCAgICBwID0gaC5jbGFtcChwLCAwLCAxKTtcblx0ICAgIGJvdW5kcyA9IHRoaXMuX2ZpbmRCb3VuZHModGhpcy5fc2FtcGxlcywgcCk7XG5cdCAgICByZXMgPSB0aGlzLl9jaGVja0lmQm91bmRzQ2xvc2VFbm91Z2gocCwgYm91bmRzKTtcblx0ICAgIGlmIChyZXMgIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX2ZpbmRBcHByb3hpbWF0ZShwLCBib3VuZHMuc3RhcnQsIGJvdW5kcy5lbmQpO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fY2hlY2tJZkJvdW5kc0Nsb3NlRW5vdWdoID0gZnVuY3Rpb24ocCwgYm91bmRzKSB7XG5cdCAgICB2YXIgcG9pbnQsIHk7XG5cdCAgICBwb2ludCA9IHZvaWQgMDtcblx0ICAgIHkgPSB0aGlzLl9jaGVja0lmUG9pbnRDbG9zZUVub3VnaChwLCBib3VuZHMuc3RhcnQucG9pbnQpO1xuXHQgICAgaWYgKHkgIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4geTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLl9jaGVja0lmUG9pbnRDbG9zZUVub3VnaChwLCBib3VuZHMuZW5kLnBvaW50KTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2NoZWNrSWZQb2ludENsb3NlRW5vdWdoID0gZnVuY3Rpb24ocCwgcG9pbnQpIHtcblx0ICAgIGlmIChoLmNsb3NlRW5vdWdoKHAsIHBvaW50LnggLyB0aGlzLl9yZWN0LCB0aGlzLl9lcHMpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlWShwb2ludCk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9hcHByb3hpbWF0ZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHApIHtcblx0ICAgIHZhciBkZWx0YVAsIHBlcmNlbnRQO1xuXHQgICAgZGVsdGFQID0gZW5kLnBvaW50LnggLSBzdGFydC5wb2ludC54O1xuXHQgICAgcGVyY2VudFAgPSAocCAtIChzdGFydC5wb2ludC54IC8gdGhpcy5fcmVjdCkpIC8gKGRlbHRhUCAvIHRoaXMuX3JlY3QpO1xuXHQgICAgcmV0dXJuIHN0YXJ0Lmxlbmd0aCArIHBlcmNlbnRQICogKGVuZC5sZW5ndGggLSBzdGFydC5sZW5ndGgpO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fZmluZEFwcHJveGltYXRlID0gZnVuY3Rpb24ocCwgc3RhcnQsIGVuZCwgYXBwcm94aW1hdGVNYXgpIHtcblx0ICAgIHZhciBhcHByb3hpbWF0aW9uLCBhcmdzLCBuZXdQb2ludCwgcG9pbnQsIHg7XG5cdCAgICBpZiAoYXBwcm94aW1hdGVNYXggPT0gbnVsbCkge1xuXHQgICAgICBhcHByb3hpbWF0ZU1heCA9IHRoaXMuX2FwcHJveGltYXRlTWF4O1xuXHQgICAgfVxuXHQgICAgYXBwcm94aW1hdGlvbiA9IHRoaXMuX2FwcHJveGltYXRlKHN0YXJ0LCBlbmQsIHApO1xuXHQgICAgcG9pbnQgPSB0aGlzLnBhdGguZ2V0UG9pbnRBdExlbmd0aChhcHByb3hpbWF0aW9uKTtcblx0ICAgIHggPSBwb2ludC54IC8gdGhpcy5fcmVjdDtcblx0ICAgIGlmIChoLmNsb3NlRW5vdWdoKHAsIHgsIHRoaXMuX2VwcykpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVZKHBvaW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICgtLWFwcHJveGltYXRlTWF4IDwgMSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlWShwb2ludCk7XG5cdCAgICAgIH1cblx0ICAgICAgbmV3UG9pbnQgPSB7XG5cdCAgICAgICAgcG9pbnQ6IHBvaW50LFxuXHQgICAgICAgIGxlbmd0aDogYXBwcm94aW1hdGlvblxuXHQgICAgICB9O1xuXHQgICAgICBhcmdzID0gcCA8IHggPyBbcCwgc3RhcnQsIG5ld1BvaW50LCBhcHByb3hpbWF0ZU1heF0gOiBbcCwgbmV3UG9pbnQsIGVuZCwgYXBwcm94aW1hdGVNYXhdO1xuXHQgICAgICByZXR1cm4gdGhpcy5fZmluZEFwcHJveGltYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fcmVzb2x2ZVkgPSBmdW5jdGlvbihwb2ludCkge1xuXHQgICAgcmV0dXJuIDEgLSAocG9pbnQueSAvIHRoaXMuX3JlY3QpO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fbm9ybWFsaXplUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcblx0ICAgIHZhciBjb21tYW5kcywgZW5kSW5kZXgsIG5vcm1hbGl6ZWRQYXRoLCBwb2ludHMsIHN0YXJ0SW5kZXgsIHN2Z0NvbW1hbmRzUmVnZXhwO1xuXHQgICAgc3ZnQ29tbWFuZHNSZWdleHAgPSAvW018THxIfFZ8Q3xTfFF8VHxBXS9naW07XG5cdCAgICBwb2ludHMgPSBwYXRoLnNwbGl0KHN2Z0NvbW1hbmRzUmVnZXhwKTtcblx0ICAgIHBvaW50cy5zaGlmdCgpO1xuXHQgICAgY29tbWFuZHMgPSBwYXRoLm1hdGNoKHN2Z0NvbW1hbmRzUmVnZXhwKTtcblx0ICAgIHN0YXJ0SW5kZXggPSAwO1xuXHQgICAgcG9pbnRzW3N0YXJ0SW5kZXhdID0gdGhpcy5fbm9ybWFsaXplU2VnbWVudChwb2ludHNbc3RhcnRJbmRleF0pO1xuXHQgICAgZW5kSW5kZXggPSBwb2ludHMubGVuZ3RoIC0gMTtcblx0ICAgIHBvaW50c1tlbmRJbmRleF0gPSB0aGlzLl9ub3JtYWxpemVTZWdtZW50KHBvaW50c1tlbmRJbmRleF0sIHRoaXMuX3JlY3QgfHwgMTAwKTtcblx0ICAgIHJldHVybiBub3JtYWxpemVkUGF0aCA9IHRoaXMuX2pvaW5Ob3JtYWxpemVkUGF0aChjb21tYW5kcywgcG9pbnRzKTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2pvaW5Ob3JtYWxpemVkUGF0aCA9IGZ1bmN0aW9uKGNvbW1hbmRzLCBwb2ludHMpIHtcblx0ICAgIHZhciBjb21tYW5kLCBpLCBqLCBsZW4xLCBub3JtYWxpemVkUGF0aCwgc3BhY2U7XG5cdCAgICBub3JtYWxpemVkUGF0aCA9ICcnO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIGxlbjEgPSBjb21tYW5kcy5sZW5ndGg7IGogPCBsZW4xOyBpID0gKytqKSB7XG5cdCAgICAgIGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcblx0ICAgICAgc3BhY2UgPSBpID09PSAwID8gJycgOiAnICc7XG5cdCAgICAgIG5vcm1hbGl6ZWRQYXRoICs9IFwiXCIgKyBzcGFjZSArIGNvbW1hbmQgKyAocG9pbnRzW2ldLnRyaW0oKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbm9ybWFsaXplZFBhdGg7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9ub3JtYWxpemVTZWdtZW50ID0gZnVuY3Rpb24oc2VnbWVudCwgdmFsdWUpIHtcblx0ICAgIHZhciBpLCBqLCBsYXN0UG9pbnQsIGxlbjEsIG5SZ3gsIHBhaXJzLCBwYXJzZWRYLCBwb2ludCwgc3BhY2UsIHg7XG5cdCAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICB2YWx1ZSA9IDA7XG5cdCAgICB9XG5cdCAgICBzZWdtZW50ID0gc2VnbWVudC50cmltKCk7XG5cdCAgICBuUmd4ID0gLygtfFxcKyk/KChcXGQrKFxcLihcXGR8XFxlKC18XFwrKT8pKyk/KXwoXFwuPyhcXGR8XFxlfChcXC18XFwrKSkrKSkvZ2ltO1xuXHQgICAgcGFpcnMgPSB0aGlzLl9nZXRTZWdtZW50UGFpcnMoc2VnbWVudC5tYXRjaChuUmd4KSk7XG5cdCAgICBsYXN0UG9pbnQgPSBwYWlyc1twYWlycy5sZW5ndGggLSAxXTtcblx0ICAgIHggPSBsYXN0UG9pbnRbMF07XG5cdCAgICBwYXJzZWRYID0gTnVtYmVyKHgpO1xuXHQgICAgaWYgKHBhcnNlZFggIT09IHZhbHVlKSB7XG5cdCAgICAgIHNlZ21lbnQgPSAnJztcblx0ICAgICAgbGFzdFBvaW50WzBdID0gdmFsdWU7XG5cdCAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4xID0gcGFpcnMubGVuZ3RoOyBqIDwgbGVuMTsgaSA9ICsraikge1xuXHQgICAgICAgIHBvaW50ID0gcGFpcnNbaV07XG5cdCAgICAgICAgc3BhY2UgPSBpID09PSAwID8gJycgOiAnICc7XG5cdCAgICAgICAgc2VnbWVudCArPSBcIlwiICsgc3BhY2UgKyBwb2ludFswXSArIFwiLFwiICsgcG9pbnRbMV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBzZWdtZW50O1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fZ2V0U2VnbWVudFBhaXJzID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0ICAgIHZhciBpLCBqLCBsZW4xLCBuZXdBcnJheSwgcGFpciwgdmFsdWU7XG5cdCAgICBpZiAoYXJyYXkubGVuZ3RoICUgMiAhPT0gMCkge1xuXHQgICAgICBoLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgdGhlIHBhdGggLSBzZWdtZW50IHBhaXJzIGFyZSBub3QgZXZlbi4nLCBhcnJheSk7XG5cdCAgICB9XG5cdCAgICBuZXdBcnJheSA9IFtdO1xuXHQgICAgZm9yIChpID0gaiA9IDAsIGxlbjEgPSBhcnJheS5sZW5ndGg7IGogPCBsZW4xOyBpID0gaiArPSAyKSB7XG5cdCAgICAgIHZhbHVlID0gYXJyYXlbaV07XG5cdCAgICAgIHBhaXIgPSBbYXJyYXlbaV0sIGFycmF5W2kgKyAxXV07XG5cdCAgICAgIG5ld0FycmF5LnB1c2gocGFpcik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3QXJyYXk7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdGgsIG8pIHtcblx0ICAgIHZhciBoYW5kbGVyO1xuXHQgICAgaGFuZGxlciA9IG5ldyBQYXRoRWFzaW5nKHBhdGgsIG8pO1xuXHQgICAgaGFuZGxlci5zYW1wbGUucGF0aCA9IGhhbmRsZXIucGF0aDtcblx0ICAgIHJldHVybiBoYW5kbGVyLnNhbXBsZTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFBhdGhFYXNpbmc7XG5cblx0fSkoKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFBhdGhFYXNpbmc7XG5cblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHR2YXIgY3JlYXRlLCBlYXNpbmcsIGdldE5lYXJlc3QsIG1peCwgcGFyc2VJZkVhc2luZywgc29ydCxcblx0ICBzbGljZSA9IFtdLnNsaWNlO1xuXG5cdGVhc2luZyA9IG51bGw7XG5cblx0cGFyc2VJZkVhc2luZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICBpZiAodHlwZW9mIGl0ZW0udmFsdWUgPT09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gaXRlbS52YWx1ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIGVhc2luZy5wYXJzZUVhc2luZyhpdGVtLnZhbHVlKTtcblx0ICB9XG5cdH07XG5cblx0c29ydCA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICB2YXIgcmV0dXJuVmFsdWU7XG5cdCAgYS52YWx1ZSA9IHBhcnNlSWZFYXNpbmcoYSk7XG5cdCAgYi52YWx1ZSA9IHBhcnNlSWZFYXNpbmcoYik7XG5cdCAgcmV0dXJuVmFsdWUgPSAwO1xuXHQgIGEudG8gPCBiLnRvICYmIChyZXR1cm5WYWx1ZSA9IC0xKTtcblx0ICBhLnRvID4gYi50byAmJiAocmV0dXJuVmFsdWUgPSAxKTtcblx0ICByZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG5cblx0Z2V0TmVhcmVzdCA9IGZ1bmN0aW9uKGFycmF5LCBwcm9ncmVzcykge1xuXHQgIHZhciBpLCBpbmRleCwgaiwgbGVuLCB2YWx1ZTtcblx0ICBpbmRleCA9IDA7XG5cdCAgZm9yIChpID0gaiA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuXHQgICAgdmFsdWUgPSBhcnJheVtpXTtcblx0ICAgIGluZGV4ID0gaTtcblx0ICAgIGlmICh2YWx1ZS50byA+IHByb2dyZXNzKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gaW5kZXg7XG5cdH07XG5cblx0bWl4ID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIGFyZ3M7XG5cdCAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuXHQgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcblx0ICAgIGFyZ3MgPSBhcmdzLnNvcnQoc29ydCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGFyZ3NbMF0udmFsdWUgPSBwYXJzZUlmRWFzaW5nKGFyZ3NbMF0pO1xuXHQgIH1cblx0ICByZXR1cm4gZnVuY3Rpb24ocHJvZ3Jlc3MpIHtcblx0ICAgIHZhciBpbmRleCwgdmFsdWU7XG5cdCAgICBpbmRleCA9IGdldE5lYXJlc3QoYXJncywgcHJvZ3Jlc3MpO1xuXHQgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICB2YWx1ZSA9IGFyZ3NbaW5kZXhdLnZhbHVlO1xuXHQgICAgICBpZiAoaW5kZXggPT09IGFyZ3MubGVuZ3RoIC0gMSAmJiBwcm9ncmVzcyA+IGFyZ3NbaW5kZXhdLnRvKSB7XG5cdCAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZShwcm9ncmVzcyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fTtcblxuXHRjcmVhdGUgPSBmdW5jdGlvbihlKSB7XG5cdCAgZWFzaW5nID0gZTtcblx0ICByZXR1cm4gbWl4O1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvKlxuXHQgIE1ldGhvZCB0byBib290c3RyYXAgYXBwcm94aW1hdGlvbiBmdW5jdGlvbi5cblx0ICBAcHJpdmF0ZVxuXHQgIEBwYXJhbSAgIHtPYmplY3R9IFNhbXBsZXMgT2JqZWN0LlxuXHQgIEByZXR1cm5zIHtGdW5jdGlvbn0gQXBwcm94aW1hdGUgZnVuY3Rpb24uXG5cdCovXG5cdHZhciBfcHJveGltYXRlID0gZnVuY3Rpb24gX3Byb3hpbWF0ZShzYW1wbGVzKSB7XG5cdCAgdmFyIG4gPSBzYW1wbGVzLmJhc2UsXG5cdCAgICAgIHNhbXBsZXNBbW91bnQgPSBNYXRoLnBvdygxMCwgbiksXG5cdCAgICAgIHNhbXBsZXNTdGVwID0gMSAvIHNhbXBsZXNBbW91bnQ7XG5cblx0ICBmdW5jdGlvbiBSb3VuZE51bWJlcihpbnB1dCwgbnVtYmVyRGVjaW1hbHMpIHtcblx0ICAgIG51bWJlckRlY2ltYWxzID0gK251bWJlckRlY2ltYWxzIHx8IDA7IC8vICt2YXIgbWFnaWMhXG5cblx0ICAgIHZhciBtdWx0aXBseWVyID0gTWF0aC5wb3coMTAuMCwgbnVtYmVyRGVjaW1hbHMpO1xuXG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChpbnB1dCAqIG11bHRpcGx5ZXIpIC8gbXVsdGlwbHllcjtcblx0ICB9XG5cblx0ICB2YXIgY2FjaGVkID0gZnVuY3Rpb24gY2FjaGVkKHApIHtcblx0ICAgIHZhciBuZXdLZXkgPSBSb3VuZE51bWJlcihwLCBuKSxcblx0ICAgICAgICBzYW1wbGUgPSBzYW1wbGVzW25ld0tleS50b1N0cmluZygpXTtcblxuXHQgICAgaWYgKE1hdGguYWJzKHAgLSBuZXdLZXkpIDwgc2FtcGxlc1N0ZXApIHtcblx0ICAgICAgcmV0dXJuIHNhbXBsZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHAgPiBuZXdLZXkpIHtcblx0ICAgICAgdmFyIG5leHRJbmRleCA9IG5ld0tleSArIHNhbXBsZXNTdGVwO1xuXHQgICAgICB2YXIgbmV4dFZhbHVlID0gc2FtcGxlc1tuZXh0SW5kZXhdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIG5leHRJbmRleCA9IG5ld0tleSAtIHNhbXBsZXNTdGVwO1xuXHQgICAgICB2YXIgbmV4dFZhbHVlID0gc2FtcGxlc1tuZXh0SW5kZXhdO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZExlbmd0aCA9IG5leHRJbmRleCAtIG5ld0tleTtcblx0ICAgIHZhciBkVmFsdWUgPSBuZXh0VmFsdWUgLSBzYW1wbGU7XG5cdCAgICBpZiAoZFZhbHVlIDwgc2FtcGxlc1N0ZXApIHtcblx0ICAgICAgcmV0dXJuIHNhbXBsZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByb2dyZXNzU2NhbGUgPSAocCAtIG5ld0tleSkgLyBkTGVuZ3RoO1xuXHQgICAgdmFyIGNvZWYgPSBuZXh0VmFsdWUgPiBzYW1wbGUgPyAtMSA6IDE7XG5cdCAgICB2YXIgc2NhbGVkRGlmZmVyZW5jZSA9IGNvZWYgKiBwcm9ncmVzc1NjYWxlICogZFZhbHVlO1xuXG5cdCAgICByZXR1cm4gc2FtcGxlICsgc2NhbGVkRGlmZmVyZW5jZTtcblx0ICB9O1xuXG5cdCAgY2FjaGVkLmdldFNhbXBsZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gc2FtcGxlcztcblx0ICB9O1xuXG5cdCAgcmV0dXJuIGNhY2hlZDtcblx0fTtcblx0Lypcblx0ICAgIE1ldGhvZCB0byB0YWtlIHNhbXBsZXMgb2YgdGhlIGZ1bmN0aW9uIGFuZCBjYWxsIHRoZSBfcHJveGltYXRlXG5cdCAgICBtZXRob2Qgd2l0aCB0aGUgZHVuY3Rpb24gYW5kIHNhbXBsZXMuIE9yIGlmIHNhbXBsZXMgcGFzc2VkIC0gcGlwZVxuXHQgICAgdGhlbSB0byB0aGUgX3Byb3hpbWF0ZSBtZXRob2Qgd2l0aG91dCBzYW1wbGluZy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0Z1bmN0aW9ufSBGdW5jdGlvbiB0byBzYW1wbGUuXG5cdCAgICBAcGFyYW0ge051bWJlciwgT2JqZWN0LCBTdHJpbmd9IFByZWNpc2lvbiBvciBwcmVjb21wdXRlZCBzYW1wbGVzLlxuXHQgICovXG5cdHZhciBfc2FtcGxlID0gZnVuY3Rpb24gX3NhbXBsZShmbikge1xuXHQgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA0O1xuXG5cblx0ICB2YXIgblR5cGUgPSB0eXBlb2YgbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShuKTtcblxuXHQgIHZhciBzYW1wbGVzID0ge307XG5cdCAgaWYgKG5UeXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgdmFyIHAgPSAwLFxuXHQgICAgICAgIHNhbXBsZXNDb3VudCA9IE1hdGgucG93KDEwLCBuKSxcblx0ICAgICAgICBzdGVwID0gMSAvIHNhbXBsZXNDb3VudDtcblxuXHQgICAgc2FtcGxlc1swXSA9IGZuKDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVzQ291bnQgLSAxOyBpKyspIHtcblx0ICAgICAgcCArPSBzdGVwO1xuXG5cdCAgICAgIHZhciBpbmRleCA9IHBhcnNlRmxvYXQocC50b0ZpeGVkKG4pKTtcblx0ICAgICAgc2FtcGxlc1tpbmRleF0gPSBmbihwKTtcblx0ICAgIH1cblx0ICAgIHNhbXBsZXNbMV0gPSBmbigxKTtcblxuXHQgICAgc2FtcGxlcy5iYXNlID0gbjtcblx0ICB9IGVsc2UgaWYgKG5UeXBlID09PSAnb2JqZWN0Jykge1xuXHQgICAgc2FtcGxlcyA9IG47XG5cdCAgfSBlbHNlIGlmIChuVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgIHNhbXBsZXMgPSBKU09OLnBhcnNlKG4pO1xuXHQgIH1cblxuXHQgIHJldHVybiBBcHByb3hpbWF0ZS5fc2FtcGxlLl9wcm94aW1hdGUoc2FtcGxlcyk7XG5cdH07XG5cblx0dmFyIEFwcHJveGltYXRlID0geyBfc2FtcGxlOiBfc2FtcGxlLCBfcHJveGltYXRlOiBfcHJveGltYXRlIH07XG5cdEFwcHJveGltYXRlLl9zYW1wbGUuX3Byb3hpbWF0ZSA9IEFwcHJveGltYXRlLl9wcm94aW1hdGU7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gQXBwcm94aW1hdGUuX3NhbXBsZTtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2dldEl0ZXJhdG9yMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTExKTtcblxuXHR2YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdHZhciBfdHdlZW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMTAyKTtcblxuXHR2YXIgX3R3ZWVuZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW5lcik7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblxuXHR2YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBUaW1lbGluZSA9IGZ1bmN0aW9uIChfVHdlZW4pIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShUaW1lbGluZSwgX1R3ZWVuKTtcblxuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIGFkZCBjaGlsZCB0d2VlbnMvdGltZWxpbmVzLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtPYmplY3QsIEFycmF5fSBUd2Vlbi9UaW1lbGluZSBvciBhbiBhcnJheSBvZiBzdWNoLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG5cdCAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHQgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9wdXNoVGltZWxpbmVBcnJheShhcmdzKTtcblx0ICAgIHRoaXMuX2NhbGNEaW1lbnRpb25zKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIGFwcGVuZCB0aGUgVHdlZW4vVGltZWxpbmUgdG8gdGhlIGVuZCBvZiB0aGVcblx0ICAgIHRpbWVsaW5lLiBFYWNoIGFyZ3VtZW50IGlzIHRyZWF0ZWQgYXMgYSBuZXcgYXBwZW5kLlxuXHQgICAgQXJyYXkgb2YgdHdlZW5zIGlzIHRyZWF0ZWQgYXMgYSBwYXJhbGxlbCBzZXF1ZW5jZS4gXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge09iamVjdCwgQXJyYXl9IFR3ZWVuL1RpbWVsaW5lIHRvIGFwcGVuZCBvciBhcnJheSBvZiBzdWNoLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuXHQgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCB0aW1lbGluZSA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG5cdCAgICAgIHRpbWVsaW5lW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHRpbWVsaW5lLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKF9pdGVyYXRvcik7Oykge1xuXHQgICAgICB2YXIgX3JlZjtcblxuXHQgICAgICBpZiAoX2lzQXJyYXkpIHtcblx0ICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG5cdCAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG5cdCAgICAgICAgaWYgKF9pLmRvbmUpIGJyZWFrO1xuXHQgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciB0bSA9IF9yZWY7XG5cblx0ICAgICAgaWYgKF9oMi5kZWZhdWx0LmlzQXJyYXkodG0pKSB7XG5cdCAgICAgICAgdGhpcy5fYXBwZW5kVGltZWxpbmVBcnJheSh0bSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fYXBwZW5kVGltZWxpbmUodG0sIHRoaXMuX3RpbWVsaW5lcy5sZW5ndGgpO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX2NhbGNEaW1lbnRpb25zKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBBUEkgbWV0aG9kIHRvIHN0b3AgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICAge051bWJlcn0gUHJvZ3Jlc3MgWzAuLjFdIHRvIHNldCB3aGVuIHN0b3BwZWQuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcChwcm9ncmVzcykge1xuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5zdG9wLmNhbGwodGhpcywgcHJvZ3Jlc3MpO1xuXHQgICAgdGhpcy5fc3RvcENoaWxkcmVuKHByb2dyZXNzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXNldCB0d2VlbidzIHN0YXRlIGFuZCBwcm9wZXJ0aWVzLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQG92ZXJyaWRlcyBAIFR3ZWVuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fcmVzZXRDaGlsZHJlbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgYHJlc2V0YCBtZXRob2Qgb24gYWxsIGNoaWxkcmVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3Jlc2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBfcmVzZXRDaGlsZHJlbigpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGltZWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX3RpbWVsaW5lc1tpXS5yZXNldCgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIGBzdG9wYCBtZXRob2Qgb24gYWxsIGNoaWxkcmVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IFByb2dyZXNzIFswLi4xXSB0byBzZXQgd2hlbiBzdG9wcGVkLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fc3RvcENoaWxkcmVuID0gZnVuY3Rpb24gX3N0b3BDaGlsZHJlbihwcm9ncmVzcykge1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICB0aGlzLl90aW1lbGluZXNbaV0uc3RvcChwcm9ncmVzcyk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCB0d2VlbidzIHN0YXRlIHRvIGNvbXBsZXRlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBUd2VlblxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblx0ICAvLyBfY29tcGxldGUgKCB0aW1lLCBpc1lveW8gKSB7XG5cdCAgLy8gICAvLyB0aGlzLl91cGRhdGVDaGlsZHJlbiggMSwgdGltZSwgaXNZb3lvICk7XG5cdCAgLy8gICAvLyB0aGlzLl9zZXRQcm9ncmVzcyggMSwgdGltZSwgaXNZb3lvICk7XG5cdCAgLy8gICBzdXBlci5fY29tcGxldGUoIHRpbWUsIGlzWW95byApO1xuXHQgIC8vICAgLy8gdGhpcy5fcmVzZXRDaGlsZHJlbigpO1xuXHQgIC8vIH1cblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhcHBlbmQgVHdlZW4vVGltZWxpbmUgYXJyYXkgb3IgbWl4IG9mIHN1Y2guXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBcnJheX0gQXJyYXkgb2YgVHdlZW5zL1RpbWVsaW5lcy5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX2FwcGVuZFRpbWVsaW5lQXJyYXkgPSBmdW5jdGlvbiBfYXBwZW5kVGltZWxpbmVBcnJheSh0aW1lbGluZUFycmF5KSB7XG5cdCAgICB2YXIgaSA9IHRpbWVsaW5lQXJyYXkubGVuZ3RoLFxuXHQgICAgICAgIHRpbWUgPSB0aGlzLl9wcm9wcy5yZXBlYXRUaW1lIC0gdGhpcy5fcHJvcHMuZGVsYXksXG5cdCAgICAgICAgbGVuID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblxuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICB0aGlzLl9hcHBlbmRUaW1lbGluZSh0aW1lbGluZUFycmF5W2ldLCBsZW4sIHRpbWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhcHBlbmQgYSBzaW5nbGUgdGltZWxpbmUgdG8gdGhlIFRpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2Vlbi9UaW1saW5lIHRvIGFwcGVuZC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgYXBwZW5kLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFNoaWZ0IHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9hcHBlbmRUaW1lbGluZSA9IGZ1bmN0aW9uIF9hcHBlbmRUaW1lbGluZSh0aW1lbGluZSwgaW5kZXgsIHRpbWUpIHtcblx0ICAgIC8vIGlmIHRpbWVsaW5lIGlzIGEgbW9kdWxlIHdpdGggdGltZWxpbmUgcHJvcGVydHkgdGhlbiBleHRyYWN0IGl0XG5cdCAgICBpZiAodGltZWxpbmUudGltZWxpbmUgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuXHQgICAgICB0aW1lbGluZSA9IHRpbWVsaW5lLnRpbWVsaW5lO1xuXHQgICAgfVxuXHQgICAgaWYgKHRpbWVsaW5lLnR3ZWVuIGluc3RhbmNlb2YgX3R3ZWVuMi5kZWZhdWx0KSB7XG5cdCAgICAgIHRpbWVsaW5lID0gdGltZWxpbmUudHdlZW47XG5cdCAgICB9XG5cblx0ICAgIHZhciBzaGlmdCA9IHRpbWUgIT0gbnVsbCA/IHRpbWUgOiB0aGlzLl9wcm9wcy5kdXJhdGlvbjtcblx0ICAgIHNoaWZ0ICs9IHRpbWVsaW5lLl9wcm9wcy5zaGlmdFRpbWUgfHwgMDtcblx0ICAgIHRpbWVsaW5lLmluZGV4ID0gaW5kZXg7dGhpcy5fcHVzaFRpbWVsaW5lKHRpbWVsaW5lLCBzaGlmdCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgUHJpdmF0ZU1ldGhvZCB0byBwdXNoIFR3ZWVuL1RpbWVsaW5lIGFycmF5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIFR3ZWVucy9UaW1lbGluZXMuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9wdXNoVGltZWxpbmVBcnJheSA9IGZ1bmN0aW9uIF9wdXNoVGltZWxpbmVBcnJheShhcnJheSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdG0gPSBhcnJheVtpXTtcblx0ICAgICAgLy8gcmVjdXJzaXZlIHB1c2ggdG8gaGFuZGxlIGFycmF5cyBvZiBhcnJheXNcblx0ICAgICAgaWYgKF9oMi5kZWZhdWx0LmlzQXJyYXkodG0pKSB7XG5cdCAgICAgICAgdGhpcy5fcHVzaFRpbWVsaW5lQXJyYXkodG0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX3B1c2hUaW1lbGluZSh0bSk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHB1c2ggYSBzaW5nbGUgVHdlZW4vVGltZWxpbmUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuIG9yIFRpbWVsaW5lIHRvIHB1c2guXG5cdCAgICBAcGFyYW0ge051bWJlcn0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBzaGlmdCB0aGUgc3RhcnQgdGltZVxuXHQgICAgICAgICAgICAgICAgICAgIG9mIHRoZSBUd2Vlbi9UaW1lbGluZS5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3B1c2hUaW1lbGluZSA9IGZ1bmN0aW9uIF9wdXNoVGltZWxpbmUodGltZWxpbmUsIHNoaWZ0KSB7XG5cdCAgICAvLyBpZiB0aW1lbGluZSBpcyBhIG1vZHVsZSB3aXRoIHRpbWVsaW5lIHByb3BlcnR5IHRoZW4gZXh0cmFjdCBpdFxuXHQgICAgaWYgKHRpbWVsaW5lLnRpbWVsaW5lIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcblx0ICAgICAgdGltZWxpbmUgPSB0aW1lbGluZS50aW1lbGluZTtcblx0ICAgIH1cblx0ICAgIGlmICh0aW1lbGluZS50d2VlbiBpbnN0YW5jZW9mIF90d2VlbjIuZGVmYXVsdCkge1xuXHQgICAgICB0aW1lbGluZSA9IHRpbWVsaW5lLnR3ZWVuO1xuXHQgICAgfVxuXHQgICAgLy8gYWRkIHNlbGYgZGVsYXkgdG8gdGhlIHRpbWVsaW5lXG5cdCAgICBzaGlmdCAhPSBudWxsICYmIHRpbWVsaW5lLl9zZXRQcm9wKHsgJ3NoaWZ0VGltZSc6IHNoaWZ0IH0pO1xuXHQgICAgdGhpcy5fdGltZWxpbmVzLnB1c2godGltZWxpbmUpO1xuXHQgICAgdGhpcy5fcmVjYWxjRHVyYXRpb24odGltZWxpbmUpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBzZXQgcHJvZ3Jlc3Mgb24gc2VsZiBhbmQgY2hpbGQgVHdlZW5zL1RpbWVsaW5lcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gc2V0LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgdXBkYXRlIHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9zZXRQcm9ncmVzcyhwLCB0aW1lLCBpc1lveW8pIHtcblx0ICAgIC8vIHdlIG5lZWQgdG8gcGFzcyBzZWxmIHByZXZpb3VzIHRpbWUgdG8gY2hpbGRyZW5cblx0ICAgIC8vIHRvIHByZXZlbnQgaW5pdGlhbCBfd2FzVW5rbm93blVwZGF0ZSBuZXN0ZWQgd2F0ZXJmYWxsXG5cdCAgICAvLyBpZiBub3QgeW95byBvcHRpb24gc2V0LCBwYXNzIHRoZSBwcmV2aW91cyB0aW1lXG5cdCAgICAvLyBvdGhlcndpc2UsIHBhc3MgcHJldmlvdXMgb3IgbmV4dCB0aW1lIHJlZ2FyZGluZyB5b3lvIHBlcmlvZC5cblxuXHQgICAgLy8gQ09WRVIgQ1VSUkVOVCBTV0FQUEVEIE9SREVSXG5cdCAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihwLCB0aW1lLCBpc1lveW8pO1xuXG5cdCAgICBfdHdlZW4yLmRlZmF1bHQucHJvdG90eXBlLl9zZXRQcm9ncmVzcy5jYWxsKHRoaXMsIHAsIHRpbWUpO1xuXHQgIH07XG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3VwZGF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gX3VwZGF0ZUNoaWxkcmVuKHAsIHRpbWUsIGlzWW95bykge1xuXHQgICAgdmFyIGNvZWYgPSB0aW1lID4gdGhpcy5fcHJldlRpbWUgPyAtMSA6IDE7XG5cdCAgICBpZiAodGhpcy5fcHJvcHMuaXNZb3lvICYmIGlzWW95bykge1xuXHQgICAgICBjb2VmICo9IC0xO1xuXHQgICAgfVxuXHQgICAgdmFyIHRpbWVUb1RpbWVsaW5lcyA9IHRoaXMuX3Byb3BzLnN0YXJ0VGltZSArIHAgKiB0aGlzLl9wcm9wcy5kdXJhdGlvbixcblx0ICAgICAgICBwcmV2VGltZVRvVGltZWxpbmVzID0gdGltZVRvVGltZWxpbmVzICsgY29lZixcblx0ICAgICAgICBsZW4gPSB0aGlzLl90aW1lbGluZXMubGVuZ3RoO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIC8vIHNwZWNpZnkgdGhlIGNoaWxkcmVuJ3MgYXJyYXkgdXBkYXRlIGxvb3AgZGlyZWN0aW9uXG5cdCAgICAgIC8vIGlmIHRpbWUgPiBwcmV2VGltZSBnbyBmcm9tIDAtPmxlbmd0aCBlbHNlIGZyb20gbGVuZ3RoLT4wXG5cdCAgICAgIC8vIHZhciBqID0gKCB0aW1lID4gdGhpcy5fcHJldlRpbWUgKSA/IGkgOiAobGVuLTEpIC0gaSA7XG5cdCAgICAgIHZhciBqID0gdGltZVRvVGltZWxpbmVzID4gcHJldlRpbWVUb1RpbWVsaW5lcyA/IGkgOiBsZW4gLSAxIC0gaTtcblx0ICAgICAgdGhpcy5fdGltZWxpbmVzW2pdLl91cGRhdGUodGltZVRvVGltZWxpbmVzLCBwcmV2VGltZVRvVGltZWxpbmVzLCB0aGlzLl9wcmV2WW95bywgdGhpcy5fb25FZGdlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3ByZXZZb3lvID0gaXNZb3lvO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBjYWxjdWxhdGUgc2VsZiBkdXJhdGlvbiBiYXNlZCBvbiB0aW1lbGluZSdzIGR1cmF0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2VlbiBvciBUaW1lbGluZSB0byBjYWxjdWxhdGUuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9yZWNhbGNEdXJhdGlvbiA9IGZ1bmN0aW9uIF9yZWNhbGNEdXJhdGlvbih0aW1lbGluZSkge1xuXHQgICAgdmFyIHAgPSB0aW1lbGluZS5fcHJvcHMsXG5cdCAgICAgICAgdGltZWxpbmVUaW1lID0gcC5yZXBlYXRUaW1lIC8gcC5zcGVlZCArIChwLnNoaWZ0VGltZSB8fCAwKSArIHRpbWVsaW5lLl9uZWdhdGl2ZVNoaWZ0O1xuXG5cdCAgICB0aGlzLl9wcm9wcy5kdXJhdGlvbiA9IE1hdGgubWF4KHRpbWVsaW5lVGltZSwgdGhpcy5fcHJvcHMuZHVyYXRpb24pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBjYWxjdWxhdGUgc2VsZiBkdXJhdGlvbiBmcm9tIHNrcmV0Y2guXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcmVjYWxjVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9yZWNhbGNUb3RhbER1cmF0aW9uKCkge1xuXHQgICAgdmFyIGkgPSB0aGlzLl90aW1lbGluZXMubGVuZ3RoO1xuXHQgICAgdGhpcy5fcHJvcHMuZHVyYXRpb24gPSAwO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICB2YXIgdG0gPSB0aGlzLl90aW1lbGluZXNbaV07XG5cdCAgICAgIC8vIHJlY2FsYyB0b3RhbCBkdXJhdGlvbiBvbiBjaGlsZCB0aW1lbGluZXNcblx0ICAgICAgdG0uX3JlY2FsY1RvdGFsRHVyYXRpb24gJiYgdG0uX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICAgICAgLy8gYWRkIHRoZSB0aW1lbGluZSdzIGR1cmF0aW9uIHRvIHNlbGZ0IGR1cmF0aW9uXG5cdCAgICAgIHRoaXMuX3JlY2FsY0R1cmF0aW9uKHRtKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2NhbGNEaW1lbnRpb25zKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHNldCBzdGFydCBhbmQgZW5kIHRpbWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyLCBOdWxsfSBUaW1lIHRvIHN0YXJ0IHdpdGguXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9zZXRTdGFydFRpbWUgPSBmdW5jdGlvbiBfc2V0U3RhcnRUaW1lKHRpbWUpIHtcblx0ICAgIHZhciBpc1Jlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG5cdCAgICBfVHdlZW4ucHJvdG90eXBlLl9zZXRTdGFydFRpbWUuY2FsbCh0aGlzLCB0aW1lKTtcblx0ICAgIHRoaXMuX3N0YXJ0VGltZWxpbmVzKHRoaXMuX3Byb3BzLnN0YXJ0VGltZSwgaXNSZXNldCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGNhbGN1bGF0ZSBzZWxmIGR1cmF0aW9uIGJhc2VkIG9uIHRpbWVsaW5lJ3MgZHVyYXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXIsIE51bGx9IFRpbWUgdG8gc3RhcnQgd2l0aC5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3N0YXJ0VGltZWxpbmVzID0gZnVuY3Rpb24gX3N0YXJ0VGltZWxpbmVzKHRpbWUpIHtcblx0ICAgIHZhciBpc1Jlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGlzU3RvcCA9IHRoaXMuX3N0YXRlID09PSAnc3RvcCc7XG5cblx0ICAgIHRpbWUgPT0gbnVsbCAmJiAodGltZSA9IHRoaXMuX3Byb3BzLnN0YXJ0VGltZSk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGltZWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0bSA9IHRoaXMuX3RpbWVsaW5lc1tpXTtcblx0ICAgICAgdG0uX3NldFN0YXJ0VGltZSh0aW1lLCBpc1Jlc2V0KTtcblx0ICAgICAgLy8gaWYgZnJvbSBgX3N1YlBsYXlgIGFuZCBgX3ByZXZUaW1lYCBpcyBzZXQgYW5kIHN0YXRlIGlzIGBzdG9wYFxuXHQgICAgICAvLyBwcmV2VGltZSBub3JtYWxpemluZyBpcyBmb3IgcGxheS9wYXVzZSBmdW5jdGlvbmFsaXR5LCBzbyBub1xuXHQgICAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSBpZiB0aGUgdGltZWxpbmUgaXMgaW4gYHN0b3BgIHN0YXRlLlxuXHQgICAgICBpZiAoIWlzUmVzZXQgJiYgdG0uX3ByZXZUaW1lICE9IG51bGwgJiYgIWlzU3RvcCkge1xuXHQgICAgICAgIHRtLl9wcmV2VGltZSA9IHRtLl9ub3JtUHJldlRpbWVGb3J3YXJkKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gbGF1bmNoIG9uUmVmcmVzaCBjYWxsYmFjay5cblx0ICAgIEBtZXRob2QgX3JlZnJlc2hcblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgVHdlZW5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgcmVmcmVzaCBldmVuIGJlZm9yZSBzdGFydCB0aW1lLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcmVmcmVzaCA9IGZ1bmN0aW9uIF9yZWZyZXNoKGlzQmVmb3JlKSB7XG5cdCAgICB2YXIgbGVuID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgdGhpcy5fdGltZWxpbmVzW2ldLl9yZWZyZXNoKGlzQmVmb3JlKTtcblx0ICAgIH1cblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuX3JlZnJlc2guY2FsbCh0aGlzLCBpc0JlZm9yZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGRvIGRlY2xhcmUgZGVmYXVsdHMgYnkgdGhpcy5fZGVmYXVsdHMgb2JqZWN0XG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIC8vIGlmIGR1cmF0aW9uIHdhcyBwYXNzZWQgb24gaW5pdGlhbGl6YXRpb24gc3RhZ2UsIHdhcm4gdXNlciBhbmQgcmVzZXQgaXQuXG5cdCAgICBpZiAodGhpcy5fby5kdXJhdGlvbiAhPSBudWxsKSB7XG5cdCAgICAgIF9oMi5kZWZhdWx0LmVycm9yKCdEdXJhdGlvbiBjYW4gbm90IGJlIGRlY2xhcmVkIG9uIFRpbWVsaW5lLCBidXQgXCInICsgdGhpcy5fby5kdXJhdGlvbiArICdcIiBpcy4gWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIFR3ZWVuIGluc3RlYWQuJyk7XG5cdCAgICAgIHRoaXMuX28uZHVyYXRpb24gPSAwO1xuXHQgICAgfVxuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzLmNhbGwodGhpcyk7XG5cdCAgICAvLyByZW1vdmUgZGVmYXVsdCBcblx0ICAgIHRoaXMuX2RlZmF1bHRzLmR1cmF0aW9uID0gMDtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLmVhc2luZyA9ICdMaW5lYXIuTm9uZSc7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5iYWNrd2FyZEVhc2luZyA9ICdMaW5lYXIuTm9uZSc7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5uYW1lQmFzZSA9ICdUaW1lbGluZSc7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIFRpbWVsaW5lKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVGltZWxpbmUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R3ZWVuLmNhbGwodGhpcywgbykpO1xuXHQgIH1cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgc29tZSB2YXJzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMuX3RpbWVsaW5lcyA9IFtdO1xuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVGltZWxpbmU7XG5cdH0oX3R3ZWVuMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBUaW1lbGluZTtcblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMTEyKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9KSxcbi8qIDExMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KVxuXHQgICwgZ2V0ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG5cdCAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG5cdCAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuXHQgIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDExNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBjbGFzc29mICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNSlcblx0ICAsIElURVJBVE9SICA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpKCdpdGVyYXRvcicpXG5cdCAgLCBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuXHQgICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuXHQgICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxuXHR2YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNylcblx0ICAsIFRBRyA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpKCd0b1N0cmluZ1RhZycpXG5cdCAgLy8gRVMzIHdyb25nIGhlcmVcblx0ICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG5cdC8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG5cdHZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuIGl0W2tleV07XG5cdCAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHZhciBPLCBULCBCO1xuXHQgIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuXHQgICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG5cdCAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG5cdCAgICAvLyBidWlsdGluVGFnIGNhc2Vcblx0ICAgIDogQVJHID8gY29mKE8pXG5cdCAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG5cdCAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcblx0fTtcblxuLyoqKi8gfSksXG4vKiAxMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdHZhciBfdGhlbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KTtcblxuXHR2YXIgX3RoZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RoZW5hYmxlKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBUdW5lYWJsZSA9IGZ1bmN0aW9uIChfVGhlbmFibGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShUdW5lYWJsZSwgX1RoZW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIFR1bmVhYmxlKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVHVuZWFibGUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1RoZW5hYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRoIG9wdGlvbmFsIG5ldyBvcHRpb25zLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtPYmplY3R9IE5ldyBvcHRpb25zIHRvIHNldCBvbiB0aGUgcnVuLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS50dW5lID0gZnVuY3Rpb24gdHVuZShvKSB7XG5cdCAgICAvLyBpZiBvcHRpb25zIG9iamVjdCB3YXMgcGFzc2VkXG5cdCAgICBpZiAobyAmJiAoMCwgX2tleXMyLmRlZmF1bHQpKG8pLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLl90cmFuc2Zvcm1IaXN0b3J5KG8pO1xuXHQgICAgICB0aGlzLl90dW5lTmV3T3B0aW9ucyhvKTtcblx0ICAgICAgLy8gcmVzdG9yZSBhcnJheSBwcm9wIHZhbHVlcyBiZWNhdXNlIF9wcm9wc1xuXHQgICAgICAvLyBjb250YWluIHRoZW0gYXMgcGFyc2VkIGFycmF5c1xuXHQgICAgICAvLyBidXQgd2UgbmVlZCB0aGUgYXMgc3RyaW5ncyB0byBzdG9yZSBpbiBoaXN0b3J5XG5cdCAgICAgIC8vIGFuZCBtZXJnZSBpbiBoaXN0b3J5IGNoYWluc1xuXHQgICAgICB0aGlzLl9oaXN0b3J5WzBdID0gX2gyLmRlZmF1bHQuY2xvbmVPYmoodGhpcy5fcHJvcHMpO1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCkge1xuXHQgICAgICAgIGlmIChvW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgdGhpcy5faGlzdG9yeVswXVtrZXldID0gdGhpcy5fcHJlcGFyc2VQcm9wVmFsdWUoa2V5LCBvW2tleV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX3R1bmVTdWJNb2R1bGVzKCk7XG5cdCAgICAgIHRoaXMuX3Jlc2V0VHdlZW5zKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVnZW5lcmF0ZSBhbGwgdGhlIHJhbmRvbSBwcm9wZXJ0aWVzIGZvcm0gaW5pdGlhbCBvYmplY3QuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuXHQgICAgcmV0dXJuIHRoaXMudHVuZSh0aGlzLl9vKTtcblx0ICB9O1xuXG5cdCAgLy8gXiBQVUJMSUMgIE1FVEhPRChTKSBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRChTKSB2XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHByZXBhcnNlIG9wdGlvbnMgaW4gb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gcHJlcGFyc2UgcHJvcGVydGllcyBvbi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhc3NlZCBvYmplY3Qgd2l0aCBwcmVwYXJzZWQgcHJvcHMuXG5cdCAgKi9cblx0ICAvLyBfcHJlUGFyc2VPcHRpb25zICggbyApIHtcblx0ICAvLyAgIGZvciAodmFyIGtleSBpbiBvKSB7XG5cdCAgLy8gICAgIG9ba2V5XSA9IHRoaXMuX3ByZXBhcnNlUHJvcFZhbHVlKCBrZXksIG9ba2V5XSApO1xuXHQgIC8vICAgfVxuXHQgIC8vICAgcmV0dXJuIG87XG5cdCAgLy8gfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHJhbnNmb3JtIGhpc3RvcnkgcmV3cml0ZSBuZXcgb3B0aW9ucyBvYmplY3QgY2hhaW4gb24gcnVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byB0dW5lIGZvci5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3RyYW5zZm9ybUhpc3RvcnkgPSBmdW5jdGlvbiBfdHJhbnNmb3JtSGlzdG9yeShvKSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuXHQgICAgICB2YXIgdmFsdWUgPSBvW2tleV07XG5cdCAgICAgIC8vIGRvbid0IHRyYW5zZm9ybSBmb3IgY2hpbGRPcHRpb25zXG5cdCAgICAgIC8vIGlmICgga2V5ID09PSAnY2hpbGRPcHRpb25zJyApIHsgY29udGludWU7IH1cblx0ICAgICAgdGhpcy5fdHJhbnNmb3JtSGlzdG9yeUZvcihrZXksIHRoaXMuX3ByZXBhcnNlUHJvcFZhbHVlKGtleSwgdmFsdWUpKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHJhbnNmb3JtIGhpc3RvcnkgY2hhaW4gZm9yIHNwZWNpZmljIGtleS92YWx1ZS5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byB0cmFuc2Zvcm0gaGlzdG9yeSBmb3IuXG5cdCAgICBAcGFyYW0ge0FueX0gVGhlIG5ldyBwcm9wZXJ0eSdzIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS5fdHJhbnNmb3JtSGlzdG9yeUZvciA9IGZ1bmN0aW9uIF90cmFuc2Zvcm1IaXN0b3J5Rm9yKGtleSwgdmFsdWUpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faGlzdG9yeS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodmFsdWUgPSB0aGlzLl90cmFuc2Zvcm1IaXN0b3J5UmVjb3JkKGksIGtleSwgdmFsdWUpKSB7XG5cdCAgICAgICAgLy8gYnJlYWsgaWYgbm8gZnVydGhlciBoaXN0b3J5IG1vZGlmaWNhdGlvbnMgbmVlZGVkXG5cdCAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB0cmFuc2Zvcm0gaGlzdG9yeSByZWNvZCB3aXRoIGtleS92YWx1ZS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgaGlzdG9yeSByZWNvcmQgdG8gdHJhbnNmb3JtLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUgdG8gdHJhbnNmb3JtLlxuXHQgICAgQHBhcmFtIHtBbnl9IFByb3BlcnR5IHZhbHVlIHRvIHRyYW5zZm9ybSB0by5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0aGUgY3VycmVudCBoaXN0b3J5IHJlY29yZC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0aGUgbmV4dCBoaXN0b3J5IHJlY29yZC5cblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgbm8gZnVydGhlclxuXHQgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnkgbW9kaWZpY2F0aW9ucyBpcyBuZWVkZWQuXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl90cmFuc2Zvcm1IaXN0b3J5UmVjb3JkID0gZnVuY3Rpb24gX3RyYW5zZm9ybUhpc3RvcnlSZWNvcmQoaW5kZXgsIGtleSwgbmV3VmFsLCBjdXJyUmVjb3JkLCBuZXh0UmVjb3JkKSB7XG5cdCAgICAvLyBuZXdWYWwgPSB0aGlzLl9wYXJzZVByb3BlcnR5KCBrZXksIG5ld1ZhbCApO1xuXHQgICAgaWYgKG5ld1ZhbCA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICAvLyBmYWxsYmFjayB0byBoaXN0b3J5IHJlY29yZHMsIGlmIHdhc24ndCBzcGVjaWZpZWRcblx0ICAgIGN1cnJSZWNvcmQgPSBjdXJyUmVjb3JkID09IG51bGwgPyB0aGlzLl9oaXN0b3J5W2luZGV4XSA6IGN1cnJSZWNvcmQ7XG5cdCAgICBuZXh0UmVjb3JkID0gbmV4dFJlY29yZCA9PSBudWxsID8gdGhpcy5faGlzdG9yeVtpbmRleCArIDFdIDogbmV4dFJlY29yZDtcblxuXHQgICAgdmFyIG9sZFZhbCA9IGN1cnJSZWNvcmRba2V5XSxcblx0ICAgICAgICBuZXh0VmFsID0gbmV4dFJlY29yZCA9PSBudWxsID8gbnVsbCA6IG5leHRSZWNvcmRba2V5XTtcblxuXHQgICAgLy8gaWYgaW5kZXggaXMgMCAtIGFsd2F5cyBzYXZlIHRoZSBuZXdWYWxcblx0ICAgIC8vIGFuZCByZXR1cm4gbm9uLWRlbHRhIGZvciBzdWJzZXF1ZW50IG1vZGlmaWNhdGlvbnNcblx0ICAgIGlmIChpbmRleCA9PT0gMCkge1xuXHQgICAgICBjdXJyUmVjb3JkW2tleV0gPSBuZXdWYWw7XG5cdCAgICAgIC8vIGFsd2F5cyByZXR1cm4gb24gdHdlZW4gcHJvcGVydGllc1xuXHQgICAgICBpZiAoX2gyLmRlZmF1bHQuaXNUd2VlblByb3Aoa2V5KSAmJiBrZXkgIT09ICdkdXJhdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgICAvLyBub250d2VlbiBwcm9wZXJ0aWVzXG5cdCAgICAgIHZhciBpc1Jld3JpdGVOZXh0ID0gdGhpcy5faXNSZXdyaXRlTmV4dChvbGRWYWwsIG5leHRWYWwpLFxuXHQgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5faXNEZWx0YShuZXdWYWwpID8gX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQobmV3VmFsKSA6IG5ld1ZhbDtcblx0ICAgICAgcmV0dXJuIGlzUmV3cml0ZU5leHQgPyByZXR1cm5WYWwgOiBudWxsO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgd2FzIGRlbHRhIGFuZCBjYW1lIG5vbmUtZGVsdHRhIC0gcmV3cml0ZVxuXHQgICAgICAvLyB0aGUgc3RhcnQgb2YgdGhlIGRlbHRhIGFuZCBzdG9wXG5cdCAgICAgIGlmICh0aGlzLl9pc0RlbHRhKG9sZFZhbCkpIHtcblx0ICAgICAgICB2YXIgX2N1cnJSZWNvcmQka2V5O1xuXG5cdCAgICAgICAgY3VyclJlY29yZFtrZXldID0gKF9jdXJyUmVjb3JkJGtleSA9IHt9LCBfY3VyclJlY29yZCRrZXlbbmV3VmFsXSA9IF9oMi5kZWZhdWx0LmdldERlbHRhRW5kKG9sZFZhbCksIF9jdXJyUmVjb3JkJGtleSk7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gaWYgdGhlIG9sZCB2YWx1ZSBpcyBub3QgZGVsdGEgYW5kIHRoZSBuZXcgb25lIGlzXG5cdCAgICAgICAgY3VyclJlY29yZFtrZXldID0gbmV3VmFsO1xuXHQgICAgICAgIC8vIGlmIHRoZSBuZXh0IGl0ZW0gaGFzIHRoZSBzYW1lIHZhbHVlIC0gcmV0dXJuIHRoZVxuXHQgICAgICAgIC8vIGl0ZW0gZm9yIHN1YnNlcXVlbnQgbW9kaWZpY2F0aW9ucyBvciBzdG9wXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmV3cml0ZU5leHQob2xkVmFsLCBuZXh0VmFsKSA/IG5ld1ZhbCA6IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIG5leHQgaXRlbSBzaG91bGRcblx0ICAgIGJlIHJld3JpdGVkIGluIHRyYW5zZm9ybSBoaXN0b3J5IG9wZXJhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gQ3VycmVudCB2YWx1ZS5cblx0ICAgIEBwYXJhbSB7QW55fSBOZXh0IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIG5lZWQgdG8gcmV3cml0ZSB0aGUgbmV4dCB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX2lzUmV3cml0ZU5leHQgPSBmdW5jdGlvbiBfaXNSZXdyaXRlTmV4dChjdXJyVmFsLCBuZXh0VmFsKSB7XG5cdCAgICAvLyByZXR1cm4gZmFsc2UgaWYgbm90aGluZyB0byByZXdyaXRlIG5leHRcblx0ICAgIGlmIChuZXh0VmFsID09IG51bGwgJiYgY3VyclZhbCAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGlzRXF1YWwgPSBjdXJyVmFsID09PSBuZXh0VmFsLFxuXHQgICAgICAgIGlzTmV4dERlbHRhID0gdGhpcy5faXNEZWx0YShuZXh0VmFsKSxcblx0ICAgICAgICBpc0RlbHRhID0gdGhpcy5faXNEZWx0YShjdXJyVmFsKSxcblx0ICAgICAgICBpc1ZhbHVlRGVsdGFDaGFpbiA9IGZhbHNlLFxuXHQgICAgICAgIGlzRGVsdGFDaGFpbiA9IGZhbHNlO1xuXG5cdCAgICBpZiAoaXNEZWx0YSAmJiBpc05leHREZWx0YSkge1xuXHQgICAgICBpZiAoX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQoY3VyclZhbCkgPT0gX2gyLmRlZmF1bHQuZ2V0RGVsdGFTdGFydChuZXh0VmFsKSkge1xuXHQgICAgICAgIGlzRGVsdGFDaGFpbiA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoaXNOZXh0RGVsdGEpIHtcblx0ICAgICAgaXNWYWx1ZURlbHRhQ2hhaW4gPSBfaDIuZGVmYXVsdC5nZXREZWx0YVN0YXJ0KG5leHRWYWwpID09PSAnJyArIGN1cnJWYWw7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBpc0VxdWFsIHx8IGlzVmFsdWVEZWx0YUNoYWluIHx8IGlzRGVsdGFDaGFpbjtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBuZXcgaGlzdG9yeSBvcHRpb25zIHRvIGFsbCB0aGUgc3VibW9kdWxlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl90dW5lU3ViTW9kdWxlcyA9IGZ1bmN0aW9uIF90dW5lU3ViTW9kdWxlcygpIHtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9tb2R1bGVzW2ldLl90dW5lTmV3T3B0aW9ucyh0aGlzLl9oaXN0b3J5W2ldKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IG5ldyBvcHRpb25zIG9uIHJ1bi5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgZm9yZWlnbiBjb250ZXh0LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3Jlc2V0VHdlZW5zID0gZnVuY3Rpb24gX3Jlc2V0VHdlZW5zKCkge1xuXHQgICAgdmFyIGkgPSAwLFxuXHQgICAgICAgIHNoaWZ0ID0gMCxcblx0ICAgICAgICB0d2VlbnMgPSB0aGlzLnRpbWVsaW5lLl90aW1lbGluZXM7XG5cblx0ICAgIC8vIGlmIGBpc1RpbWVsaW5lTGVzc2AgcmV0dXJuXG5cdCAgICBpZiAodHdlZW5zID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbaV0sXG5cdCAgICAgICAgICBwcmV2VHdlZW4gPSB0d2VlbnNbaSAtIDFdO1xuXG5cdCAgICAgIHNoaWZ0ICs9IHByZXZUd2VlbiA/IHByZXZUd2Vlbi5fcHJvcHMucmVwZWF0VGltZSA6IDA7XG5cdCAgICAgIHRoaXMuX3Jlc2V0VHdlZW4odHdlZW4sIHRoaXMuX2hpc3RvcnlbaV0sIHNoaWZ0KTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3NldFByb3AodGhpcy5fcHJvcHMudGltZWxpbmUpO1xuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXNldCB0d2VlbiB3aXRoIG5ldyBvcHRpb25zLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuIHRvIHJlc2V0LlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuJ3MgdG8gcmVzZXQgdHdlZW4gd2l0aC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBPcHRpb25hbCBudW1iZXIgdG8gc2hpZnQgdHdlZW4gc3RhcnQgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3Jlc2V0VHdlZW4gPSBmdW5jdGlvbiBfcmVzZXRUd2Vlbih0d2Vlbiwgbykge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG5cdCAgICBvLnNoaWZ0VGltZSA9IHNoaWZ0O3R3ZWVuLl9zZXRQcm9wKG8pO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVHVuZWFibGU7XG5cdH0oX3RoZW5hYmxlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBUdW5lYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX3NoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XG5cblx0dmFyIF9zaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZSk7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICAqVE9ETzoqXG5cdCAgLS0tXG5cdCAgLSB0d2VhayB0aGVuIGNoYWluc1xuXHQqL1xuXG5cdHZhciBTaGFwZVN3aXJsID0gZnVuY3Rpb24gKF9TaGFwZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFNoYXBlU3dpcmwsIF9TaGFwZSk7XG5cblx0ICBmdW5jdGlvbiBTaGFwZVN3aXJsKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU2hhcGVTd2lybCk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIF9kZWZhdWx0cyBhbmQgb3RoZXIgZGVmYXVsdCBvYmplY3RzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIFNoYXBlXG5cdCAgKi9cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIF9TaGFwZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXG5cdCAgICAvKiBfREVGQVVMVFMgQVJFIC0gU2hhcGUgREVGQVVMVFMgKyBUSEVTRTogKi9cblxuXHQgICAgLyogW2Jvb2xlYW5dIDo6IElmIHNoYXBlIHNob3VsZCBmb2xsb3cgc2ludXNvaWRhbCBwYXRoLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuaXNTd2lybCA9IHRydWU7XG5cdCAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IERlZ3JlZSBzaXplIG9mIHRoZSBzaW51c29pZGFsIHBhdGguICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5zd2lybFNpemUgPSAxMDtcblx0ICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogRnJlcXVlbmN5IG9mIHRoZSBzaW51c29pZGFsIHBhdGguICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5zd2lybEZyZXF1ZW5jeSA9IDM7XG5cdCAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IFNpbnVzb2lkYWwgcGF0aCBsZW5ndGggc2NhbGUuICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5wYXRoU2NhbGUgPSAxO1xuXHQgICAgLyog4oiGIDo6IFtudW1iZXJdIDo6IERlZ3JlZSBzaGlmdCBmb3IgdGhlIHNpbnVzb2lkYWwgcGF0aC4gKi9cblx0ICAgIHRoaXMuX2RlZmF1bHRzLmRlZ3JlZVNoaWZ0ID0gMDtcblx0ICAgIC8qIOKIhiA6OiBbbnVtYmVyXSA6OiBSYWRpdXMgb2YgdGhlIHNoYXBlLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMucmFkaXVzID0gNTtcblx0ICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgdGhpcy5fZGVmYXVsdHMueCA9IDA7XG5cdCAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgIHRoaXMuX2RlZmF1bHRzLnkgPSAwO1xuXHQgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgdGhpcy5fZGVmYXVsdHMuc2NhbGUgPSB7IDE6IDAgfTtcblx0ICAgIC8qIFtudW1iZXI6IC0xLCAxXSA6OiBEaXJlY3RvbiBvZiBTd2lybC4gKi9cblx0ICAgIHRoaXMuX2RlZmF1bHRzLmRpcmVjdGlvbiA9IDE7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjb3B5IF9vIG9wdGlvbnMgdG8gX3Byb3BzIHdpdGhcblx0ICAgIGZhbGxiYWNrIHRvIF9kZWZhdWx0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICBfU2hhcGUucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fY2FsY1Bvc0RhdGEoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBuZXcgb3ByaW9ucyB0byBfbyBhbmQgX3Byb3BzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgTW9kdWxlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBvYmplY3QgdG8gdHVuZSB0by5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fdHVuZU5ld09wdGlvbnMgPSBmdW5jdGlvbiBfdHVuZU5ld09wdGlvbnMobykge1xuXHQgICAgaWYgKG8gPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIF9TaGFwZS5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zLmNhbGwodGhpcywgbyk7XG5cdCAgICBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcblx0ICAgICAgdGhpcy5fY2FsY1Bvc0RhdGEoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIFN3aXJsJ3MgcG9zaXRpb24gZGF0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX2NhbGNQb3NEYXRhID0gZnVuY3Rpb24gX2NhbGNQb3NEYXRhKCkge1xuXHQgICAgdmFyIHggPSB0aGlzLl9nZXRQb3NWYWx1ZSgneCcpLFxuXHQgICAgICAgIHkgPSB0aGlzLl9nZXRQb3NWYWx1ZSgneScpLFxuXHQgICAgICAgIGFuZ2xlID0gOTAgKyBNYXRoLmF0YW4oeS5kZWx0YSAvIHguZGVsdGEgfHwgMCkgKiBfaDIuZGVmYXVsdC5SQURfVE9fREVHO1xuXG5cdCAgICB0aGlzLl9wb3NEYXRhID0ge1xuXHQgICAgICByYWRpdXM6IE1hdGguc3FydCh4LmRlbHRhICogeC5kZWx0YSArIHkuZGVsdGEgKiB5LmRlbHRhKSxcblx0ICAgICAgYW5nbGU6IHguZGVsdGEgPCAwID8gYW5nbGUgKyAxODAgOiBhbmdsZSxcblx0ICAgICAgeDogeCwgeTogeVxuXHQgICAgfTtcblx0ICAgIC8vIHNldCB0aGUgbGFzdCBwb3NpdGlvbiB0byBfcHJvcHNcblx0ICAgIC8vIHRoaXMuX2NhbGNTd2lybFhZKCAxICk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgR2V0cyBgeGAgb3IgYHlgIHBvc2l0aW9uIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZ2V0UG9zVmFsdWUgPSBmdW5jdGlvbiBfZ2V0UG9zVmFsdWUobmFtZSkge1xuXHQgICAgdmFyIGRlbHRhID0gdGhpcy5fZGVsdGFzW25hbWVdO1xuXHQgICAgaWYgKGRlbHRhKSB7XG5cdCAgICAgIC8vIGRlbGV0ZSBmcm9tIGRlbHRhcyB0byBwcmV2ZW50IG5vcm1hbFxuXHQgICAgICBkZWxldGUgdGhpcy5fZGVsdGFzW25hbWVdO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHN0YXJ0OiBkZWx0YS5zdGFydC52YWx1ZSxcblx0ICAgICAgICBlbmQ6IGRlbHRhLmVuZC52YWx1ZSxcblx0ICAgICAgICBkZWx0YTogZGVsdGEuZGVsdGEsXG5cdCAgICAgICAgdW5pdHM6IGRlbHRhLmVuZC51bml0XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgcG9zID0gX2gyLmRlZmF1bHQucGFyc2VVbml0KHRoaXMuX3Byb3BzW25hbWVdKTtcblx0ICAgICAgcmV0dXJuIHsgc3RhcnQ6IHBvcy52YWx1ZSwgZW5kOiBwb3MudmFsdWUsIGRlbHRhOiAwLCB1bml0czogcG9zLnVuaXQgfTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBwcm9ncmVzcyBvZiB0aGUgU3dpcmwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIFNoYXBlXG5cdCAgICBAcGFyYW0ge051bWVyfSBFYXNlZCBwcm9ncmVzcyBvZiB0aGUgU3dpcmwgaW4gcmFuZ2Ugb2YgWzAuLjFdXG5cdCAgICBAcGFyYW0ge051bWVyfSBQcm9ncmVzcyBvZiB0aGUgU3dpcmwgaW4gcmFuZ2Ugb2YgWzAuLjFdXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG5cdCAgICB0aGlzLl9wcm9ncmVzcyA9IGVhc2VkUHJvZ3Jlc3M7XG5cdCAgICB0aGlzLl9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKTtcblx0ICAgIHRoaXMuX2NhbGNTd2lybFhZKGVhc2VkUHJvZ3Jlc3MpO1xuXHQgICAgLy8gdGhpcy5fY2FsY09yaWdpbigpO1xuXHQgICAgdGhpcy5fZHJhdyhlYXNlZFByb2dyZXNzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHgveSBmb3IgU3dpcmwncyBwcm9ncmVzc1xuXHQgICAgQHByaXZhdGVcblx0ICAgIEBtdXRhdGVzIF9wcm9wc1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgcHJvZ3Jlc3MgaW4gWzAuLi4xXVxuXHQgICovXG5cblxuXHQgIFNoYXBlU3dpcmwucHJvdG90eXBlLl9jYWxjU3dpcmxYWSA9IGZ1bmN0aW9uIF9jYWxjU3dpcmxYWShwcm9jKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGFuZ2xlID0gdGhpcy5fcG9zRGF0YS5hbmdsZSArIHAuZGVncmVlU2hpZnQsXG5cdCAgICAgICAgcG9pbnQgPSBfaDIuZGVmYXVsdC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgIGFuZ2xlOiBwLmlzU3dpcmwgPyBhbmdsZSArIHRoaXMuX2dldFN3aXJsKHByb2MpIDogYW5nbGUsXG5cdCAgICAgIHJhZGl1czogcHJvYyAqIHRoaXMuX3Bvc0RhdGEucmFkaXVzICogcC5wYXRoU2NhbGUsXG5cdCAgICAgIGNlbnRlcjoge1xuXHQgICAgICAgIHg6IHRoaXMuX3Bvc0RhdGEueC5zdGFydCxcblx0ICAgICAgICB5OiB0aGlzLl9wb3NEYXRhLnkuc3RhcnRcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBpZiBmb3JlaWduIHN2ZyBjYW52YXMgLSBzZXQgcG9zaXRpb24gd2l0aG91dCB1bml0c1xuXHQgICAgdmFyIHggPSBwb2ludC54LFxuXHQgICAgICAgIHkgPSBwb2ludC55LFxuXHQgICAgICAgIHNtYWxsTnVtYmVyID0gMC4wMDAwMDE7XG5cblx0ICAgIC8vIHJlbW92ZSB2ZXJ5IHNtYWxsIG51bWJlcnMgdG8gcHJldmVudCBleHBvbmVudGlhbCBmb3Jtc1xuXHQgICAgaWYgKHggPiAwICYmIHggPCBzbWFsbE51bWJlcikge1xuXHQgICAgICB4ID0gc21hbGxOdW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAoeSA+IDAgJiYgeSA8IHNtYWxsTnVtYmVyKSB7XG5cdCAgICAgIHkgPSBzbWFsbE51bWJlcjtcblx0ICAgIH1cblx0ICAgIGlmICh4IDwgMCAmJiB4ID4gLXNtYWxsTnVtYmVyKSB7XG5cdCAgICAgIHggPSAtc21hbGxOdW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAoeSA8IDAgJiYgeSA+IC1zbWFsbE51bWJlcikge1xuXHQgICAgICB5ID0gLXNtYWxsTnVtYmVyO1xuXHQgICAgfVxuXG5cdCAgICBwLnggPSB0aGlzLl9vLmN0eCA/IHggOiAnJyArIHggKyB0aGlzLl9wb3NEYXRhLngudW5pdHM7XG5cdCAgICBwLnkgPSB0aGlzLl9vLmN0eCA/IHkgOiAnJyArIHkgKyB0aGlzLl9wb3NEYXRhLnkudW5pdHM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBwcm9ncmVzcyBvZiB0aGUgc3dpcmwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIG9mIHRoZSBTd2lybC5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFByb2dyZXNzIG9mIHRoZSBzd2lybC5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZ2V0U3dpcmwgPSBmdW5jdGlvbiBfZ2V0U3dpcmwocHJvYykge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHJldHVybiBwLmRpcmVjdGlvbiAqIHAuc3dpcmxTaXplICogTWF0aC5zaW4ocC5zd2lybEZyZXF1ZW5jeSAqIHByb2MpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IHNoYXBlLlxuXHQgICAgSWYgIWlzV2l0aFNoYXBlIC0gZHJhdyBzZWxmIGVsIG9ubHksIGJ1dCBub3Qgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIFNoYXBlLlxuXHQgICovXG5cblxuXHQgIFNoYXBlU3dpcmwucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICAvLyBjYWxsIF9kcmF3IG9yIGp1c3QgX2RyYXdFbCBAIFNoYXBlIGRlcGVuZGluZyBpZiB0aGVyZSBpcyBgc2hhcGVgXG5cdCAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMuX3Byb3BzLmlzV2l0aFNoYXBlID8gJ19kcmF3JyA6ICdfZHJhd0VsJztcblx0ICAgIF9zaGFwZTIuZGVmYXVsdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0uY2FsbCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFNoYXBlU3dpcmw7XG5cdH0oX3NoYXBlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBTaGFwZVN3aXJsO1xuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG5cdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX3RpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTApO1xuXG5cdHZhciBfdGltZWxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZWxpbmUpO1xuXG5cdHZhciBfc2hhcGVTd2lybCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3KTtcblxuXHR2YXIgX3NoYXBlU3dpcmwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGVTd2lybCk7XG5cblx0dmFyIF90dW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuXG5cdHZhciBfdHVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90dW5hYmxlKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvLyBpbXBvcnQgU2hhcGUgICAgZnJvbSAnLi9zaGFwZSc7XG5cdHZhciBCdXJzdCA9IGZ1bmN0aW9uIChfVHVuYWJsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEJ1cnN0LCBfVHVuYWJsZSk7XG5cblx0ICBmdW5jdGlvbiBCdXJzdCgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIEJ1cnN0KTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9UdW5hYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBkZWZhdWx0cy5cblx0ICAgIEBvdmVycmlkZSBAIFNoYXBlU3dpcmwuXG5cdCAgKi9cblx0ICBCdXJzdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICB0aGlzLl9kZWZhdWx0cyA9IHtcblx0ICAgICAgLyogW251bWJlciA+IDBdIDo6IFF1YW50aXR5IG9mIEJ1cnN0IHBhcnRpY2xlcy4gKi9cblx0ICAgICAgY291bnQ6IDUsXG5cdCAgICAgIC8qIFswIDwgbnVtYmVyIDwgMzYwXSA6OiBEZWdyZWUgb2YgdGhlIEJ1cnN0LiAqL1xuXHQgICAgICBkZWdyZWU6IDM2MCxcblx0ICAgICAgLyog4oiGIDo6IFtudW1iZXIgPiAwXSA6OiBSYWRpdXMgb2YgdGhlIEJ1cnN0LiAqL1xuXHQgICAgICByYWRpdXM6IHsgMDogNTAgfSxcblx0ICAgICAgLyog4oiGIDo6IFtudW1iZXIgPiAwXSA6OiBYIHJhZGl1cyBvZiB0aGUgQnVyc3QuICovXG5cdCAgICAgIHJhZGl1c1g6IG51bGwsXG5cdCAgICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogWSByYWRpdXMgb2YgdGhlIEJ1cnN0LiAqL1xuXHQgICAgICByYWRpdXNZOiBudWxsLFxuXHQgICAgICAvKiBbbnVtYmVyID49IDBdIDo6IHdpZHRoIG9mIHRoZSBtYWluIHN3aXJsLiAqL1xuXHQgICAgICB3aWR0aDogMCxcblx0ICAgICAgLyogW251bWJlciA+PSAwXSA6OiBoZWlnaHQgb2YgdGhlIG1haW4gc3dpcmwuICovXG5cdCAgICAgIGhlaWdodDogMFxuXHQgICAgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIGEgdGhlbiByZWNvcmQgZm9yIHRoZSBtb2R1bGUuXG5cdCAgICBAcHVibGljXG5cdCAgICBvdmVycmlkZXMgQCBUaGVuYWJsZVxuXHQgICAgQHBhcmFtICAgIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbi5cblx0ICAgIEByZXR1cm5zICB7T2JqZWN0fSB0aGlzLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvKSB7XG5cdCAgICAvLyByZW1vdmUgdHdlZW4gcHJvcGVydGllcyAobm90IGNhbGxiYWNrcylcblx0ICAgIHRoaXMuX3JlbW92ZVR3ZWVuUHJvcGVydGllcyhvKTtcblxuXHQgICAgdmFyIG5ld01hc3RlciA9IHRoaXMuX21hc3RlclRoZW4obyksXG5cdCAgICAgICAgbmV3U3dpcmxzID0gdGhpcy5fY2hpbGRUaGVuKG8pO1xuXG5cdCAgICB0aGlzLl9zZXRTd2lybER1cmF0aW9uKG5ld01hc3RlciwgdGhpcy5fY2FsY1BhY2tUaW1lKG5ld1N3aXJscykpO1xuXG5cdCAgICB0aGlzLnRpbWVsaW5lLl9yZWNhbGNUb3RhbER1cmF0aW9uKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRoIG9wdGlvbmFsIG5ldyBvcHRpb25zLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtPYmplY3R9IE5ldyBvcHRpb25zIHRvIHNldCBvbiB0aGUgcnVuLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUudHVuZSA9IGZ1bmN0aW9uIHR1bmUobykge1xuXHQgICAgaWYgKG8gPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIC8vIHNhdmUgdGltZWxpbmUgb3B0aW9ucyB0byBfdGltZWxpbmVPcHRpb25zXG5cdCAgICAvLyBhbmQgZGVsZXRlIHRoZSB0aW1lbGluZSBvcHRpb25zIG9uIG9cblx0ICAgIC8vIGN1eiBtYXN0ZXJTd2lybCBzaG91bGQgbm90IGdldCB0aGVtXG5cdCAgICB0aGlzLl9zYXZlVGltZWxpbmVPcHRpb25zKG8pO1xuXG5cdCAgICAvLyBhZGQgbmV3IHRpbWVsaW5lIHByb3BlcnRpZXMgdG8gdGltZWxpbmVcblx0ICAgIHRoaXMudGltZWxpbmUuX3NldFByb3AodGhpcy5fdGltZWxpbmVPcHRpb25zKTtcblxuXHQgICAgLy8gcmVtb3ZlIHR3ZWVuIG9wdGlvbnMgKG5vdCBjYWxsYmFja3MpXG5cdCAgICB0aGlzLl9yZW1vdmVUd2VlblByb3BlcnRpZXMobyk7XG5cblx0ICAgIC8vIHR1bmUgX3Byb3BzXG5cdCAgICB0aGlzLl90dW5lTmV3T3B0aW9ucyhvKTtcblxuXHQgICAgLy8gdHVuZSBtYXN0ZXIgc3dpcmxcblx0ICAgIHRoaXMubWFzdGVyU3dpcmwudHVuZShvKTtcblxuXHQgICAgLy8gdHVuZSBjaGlsZCBzd2lybHNcblx0ICAgIHRoaXMuX3R1bmVTd2lybHMobyk7XG5cblx0ICAgIC8vIHJlY2FsYyB0aW1lIGZvciBtb2R1bGVzXG5cdCAgICB0aGlzLl9yZWNhbGNNb2R1bGVzVGltZSgpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0RTIF5cblx0ICAvLyB2IFBSSVZBVEUgTUVUSE9EUyB2XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNvcHkgYF9vYCBvcHRpb25zIHRvIGBfcHJvcHNgIG9iamVjdFxuXHQgICAgd2l0aCBmYWxsYmFjayB0byBgX2RlZmF1bHRzYC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgTW9kdWxlXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIF9leHRlbmREZWZhdWx0cygpIHtcblx0ICAgIC8vIHJlbW92ZSB0d2VlbiBwcm9wZXJ0aWVzIChub3QgY2FsbGJhY2tzKVxuXHQgICAgdGhpcy5fcmVtb3ZlVHdlZW5Qcm9wZXJ0aWVzKHRoaXMuX28pO1xuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZW1vdmUgYWxsIHR3ZWVuIChleGNsdWRpbmdcblx0ICAgIGNhbGxiYWNrcykgcHJvcHMgZnJvbSBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB3aGljaCBzaG91bGQgYmUgY2xlYW5lZFxuXHQgICAgICAgICAgICAgICAgICAgIHVwIGZyb20gdHdlZW4gcHJvcGVydGllcy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3JlbW92ZVR3ZWVuUHJvcGVydGllcyA9IGZ1bmN0aW9uIF9yZW1vdmVUd2VlblByb3BlcnRpZXMobykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIF9oMi5kZWZhdWx0LnR3ZWVuT3B0aW9uTWFwKSB7XG5cdCAgICAgIC8vIHJlbW92ZSBhbGwgaXRlbXMgdGhhdCBhcmUgbm90IGRlY2xhcmVkIGluIF9kZWZhdWx0c1xuXHQgICAgICBpZiAodGhpcy5fZGVmYXVsdHNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgZGVsZXRlIG9ba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZWNhbGMgbW9kdWxlcyBjaGFpbiB0d2VlblxuXHQgICAgdGltZXMgYWZ0ZXIgdHVuaW5nIG5ldyBvcHRpb25zLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3JlY2FsY01vZHVsZXNUaW1lID0gZnVuY3Rpb24gX3JlY2FsY01vZHVsZXNUaW1lKCkge1xuXHQgICAgdmFyIG1vZHVsZXMgPSB0aGlzLm1hc3RlclN3aXJsLl9tb2R1bGVzLFxuXHQgICAgICAgIHN3aXJscyA9IHRoaXMuX3N3aXJscyxcblx0ICAgICAgICBzaGlmdFRpbWUgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHR3ZWVuID0gbW9kdWxlc1tpXS50d2Vlbixcblx0ICAgICAgICAgIHBhY2tUaW1lID0gdGhpcy5fY2FsY1BhY2tUaW1lKHN3aXJsc1tpXSk7XG5cdCAgICAgIHR3ZWVuLl9zZXRQcm9wKHsgJ2R1cmF0aW9uJzogcGFja1RpbWUsICdzaGlmdFRpbWUnOiBzaGlmdFRpbWUgfSk7XG5cdCAgICAgIHNoaWZ0VGltZSArPSBwYWNrVGltZTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB0dW5lIFN3aXJscyB3aXRoIG5ldyBvcHRpb25zLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3R1bmVTd2lybHMgPSBmdW5jdGlvbiBfdHVuZVN3aXJscyhvKSB7XG5cdCAgICAvLyBnZXQgc3dpcmxzIGluIGZpcnN0IHBhY2tcblx0ICAgIHZhciBwYWNrMCA9IHRoaXMuX3N3aXJsc1swXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFjazAubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHN3aXJsID0gcGFjazBbaV0sXG5cdCAgICAgICAgICBvcHRpb24gPSB0aGlzLl9nZXRDaGlsZE9wdGlvbihvIHx8IHt9LCBpKTtcblxuXHQgICAgICAvLyBzaW5jZSB0aGUgYGRlZ3JlZVNoaWZ0YCBwYXJ0aWNpcGF0ZSBpblxuXHQgICAgICAvLyBjaGlsZHJlbiBwb3NpdGlvbiBjYWxjdWxhdGlvbnMsIHdlIG5lZWQgdG8ga2VlcFxuXHQgICAgICAvLyB0aGUgb2xkIGBkZWdyZWVTaGlmdGAgdmFsdWUgaWYgbmV3IG5vdCBzZXRcblx0ICAgICAgdmFyIGlzRGVncmVlU2hpZnQgPSBvcHRpb24uZGVncmVlU2hpZnQgIT0gbnVsbDtcblx0ICAgICAgaWYgKCFpc0RlZ3JlZVNoaWZ0KSB7XG5cdCAgICAgICAgb3B0aW9uLmRlZ3JlZVNoaWZ0ID0gdGhpcy5fc3dpcmxzWzBdW2ldLl9wcm9wcy5kZWdyZWVTaGlmdDtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX2FkZEJ1cnN0UHJvcGVydGllcyhvcHRpb24sIGkpO1xuXG5cdCAgICAgIC8vIGFmdGVyIGJ1cnN0IHBvc2l0aW9uIGNhbGN1bGF0aW9uIC0gZGVsZXRlIHRoZSBvbGQgYGRlZ3JlZVNoaWZ0YFxuXHQgICAgICAvLyBmcm9tIHRoZSBvcHRpb25zLCBzaW5jZSBhbnl3YXlzIHdlIGhhdmUgY29waWVkIGl0IGZyb20gdGhlIHN3aXJsXG5cdCAgICAgIGlmICghaXNEZWdyZWVTaGlmdCkge1xuXHQgICAgICAgIGRlbGV0ZSBvcHRpb24uZGVncmVlU2hpZnQ7XG5cdCAgICAgIH1cblxuXHQgICAgICBzd2lybC50dW5lKG9wdGlvbik7XG5cdCAgICAgIHRoaXMuX3JlZnJlc2hCdXJzdE9wdGlvbnMoc3dpcmwuX21vZHVsZXMsIGkpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZWZyZXNoIGJ1cnN0IHgveS9hbmdsZSBvcHRpb25zIG9uIGZ1cnRoZXIgY2hhaW5lZCBcblx0ICAgIHN3aXJscywgYmVjYXVzZSB0aGV5IHdpbGwgYmUgb3ZlcnJpZGVuIGFmdGVyIGB0dW5lYCBjYWxsIG9uXG5cdCAgICB2ZXJ5IGZpcnN0IHN3aXJsLlxuXHQgICAgQHBhcmFtIHtBcnJheX0gQ2hhaW5lZCBtb2R1bGVzIGFycmF5XG5cdCAgICBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgZmlyc3Qgc3dpcmwgaW4gdGhlIGNoYWluLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fcmVmcmVzaEJ1cnN0T3B0aW9ucyA9IGZ1bmN0aW9uIF9yZWZyZXNoQnVyc3RPcHRpb25zKG1vZHVsZXMsIGkpIHtcblx0ICAgIGZvciAodmFyIGogPSAxOyBqIDwgbW9kdWxlcy5sZW5ndGg7IGorKykge1xuXHQgICAgICB2YXIgbW9kdWxlID0gbW9kdWxlc1tqXSxcblx0ICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgdGhpcy5fYWRkQnVyc3RQcm9wZXJ0aWVzKG9wdGlvbnMsIGksIGopO1xuXHQgICAgICBtb2R1bGUuX3R1bmVOZXdPcHRpb25zKG9wdGlvbnMpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIHRoZW4gb24gbWFzdGVyU3dpcmwuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGhlbiBvcHRpb25zLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gTmV3IG1hc3RlciBzd2lybC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX21hc3RlclRoZW4gPSBmdW5jdGlvbiBfbWFzdGVyVGhlbihvKSB7XG5cdCAgICB0aGlzLm1hc3RlclN3aXJsLnRoZW4obyk7XG5cdCAgICAvLyBnZXQgdGhlIGxhdGVzdCBtYXN0ZXIgc3dpcmwgaW4gdGhlbiBjaGFpblxuXHQgICAgdmFyIG5ld01hc3RlclN3aXJsID0gX2gyLmRlZmF1bHQuZ2V0TGFzdEl0ZW0odGhpcy5tYXN0ZXJTd2lybC5fbW9kdWxlcyk7XG5cdCAgICAvLyBzYXZlIHRvIG1hc3RlclN3aXJsc1xuXHQgICAgdGhpcy5fbWFzdGVyU3dpcmxzLnB1c2gobmV3TWFzdGVyU3dpcmwpO1xuXHQgICAgcmV0dXJuIG5ld01hc3RlclN3aXJsO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIHRoZW4gb24gY2hpbGQgc3dpbHJzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFRoZW4gb3B0aW9ucy5cblx0ICAgIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBuZXcgU3dpcmxzLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fY2hpbGRUaGVuID0gZnVuY3Rpb24gX2NoaWxkVGhlbihvKSB7XG5cdCAgICB2YXIgcGFjayA9IHRoaXMuX3N3aXJsc1swXSxcblx0ICAgICAgICBuZXdQYWNrID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFjay5sZW5ndGg7IGkrKykge1xuXHQgICAgICAvLyBnZXQgb3B0aW9uIGJ5IG1vZHVsdXNcblx0ICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9nZXRDaGlsZE9wdGlvbihvLCBpKTtcblx0ICAgICAgdmFyIHN3aXJsID0gcGFja1tpXTtcblx0ICAgICAgdmFyIGxhc3RTd2lybCA9IF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKHN3aXJsLl9tb2R1bGVzKTtcblx0ICAgICAgLy8gYWRkIG5ldyBNYXN0ZXIgU3dpcmwgYXMgcGFyZW50IG9mIG5ldyBjaGlsZHN3aXJsXG5cdCAgICAgIG9wdGlvbnMucGFyZW50ID0gdGhpcy5lbDtcblxuXHQgICAgICB0aGlzLl9hZGRCdXJzdFByb3BlcnRpZXMob3B0aW9ucywgaSwgdGhpcy5fbWFzdGVyU3dpcmxzLmxlbmd0aCAtIDEpO1xuXG5cdCAgICAgIHN3aXJsLnRoZW4ob3B0aW9ucyk7XG5cblx0ICAgICAgLy8gc2F2ZSB0aGUgbmV3IGl0ZW0gaW4gYHRoZW5gIGNoYWluXG5cdCAgICAgIG5ld1BhY2sucHVzaChfaDIuZGVmYXVsdC5nZXRMYXN0SXRlbShzd2lybC5fbW9kdWxlcykpO1xuXHQgICAgfVxuXHQgICAgLy8gc2F2ZSB0aGUgcGFjayB0byBfc3dpcmxzIG9iamVjdFxuXHQgICAgdGhpcy5fc3dpcmxzW3RoaXMuX21hc3RlclN3aXJscy5sZW5ndGggLSAxXSA9IG5ld1BhY2s7XG5cdCAgICByZXR1cm4gbmV3UGFjaztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5pdGlhbGl6ZSBwcm9wZXJ0aWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBUaGVuYWJsZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLl92YXJzLmNhbGwodGhpcyk7XG5cdCAgICAvLyBqdXN0IGJ1ZmZlciB0aW1lbGluZSBmb3IgY2FsY3VsYXRpb25zXG5cdCAgICB0aGlzLl9idWZmZXJUaW1lbGluZSA9IG5ldyBfdGltZWxpbmUyLmRlZmF1bHQoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHRoZSBtb2R1bGUuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiBfcmVuZGVyKCkge1xuXHQgICAgdGhpcy5fby5pc1dpdGhTaGFwZSA9IGZhbHNlO1xuXHQgICAgdGhpcy5fby5pc1N3aXJsID0gdGhpcy5fcHJvcHMuaXNTd2lybDtcblx0ICAgIHRoaXMuX28uY2FsbGJhY2tzQ29udGV4dCA9IHRoaXM7XG5cdCAgICAvLyBzYXZlIHRpbWVsaW5lIG9wdGlvbnMgYW5kIHJlbW92ZSBmcm9tIF9vXG5cdCAgICAvLyBjdXogdGhlIG1hc3RlciBzd2lybCBzaG91bGQgbm90IGdldCB0aGVtXG5cdCAgICB0aGlzLl9zYXZlVGltZWxpbmVPcHRpb25zKHRoaXMuX28pO1xuXG5cdCAgICB0aGlzLm1hc3RlclN3aXJsID0gbmV3IE1haW5Td2lybCh0aGlzLl9vKTtcblx0ICAgIHRoaXMuX21hc3RlclN3aXJscyA9IFt0aGlzLm1hc3RlclN3aXJsXTtcblx0ICAgIHRoaXMuZWwgPSB0aGlzLm1hc3RlclN3aXJsLmVsO1xuXG5cdCAgICB0aGlzLl9yZW5kZXJTd2lybHMoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHN3aXJscy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9yZW5kZXJTd2lybHMgPSBmdW5jdGlvbiBfcmVuZGVyU3dpcmxzKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBwYWNrID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5jb3VudDsgaSsrKSB7XG5cdCAgICAgIHZhciBvcHRpb24gPSB0aGlzLl9nZXRDaGlsZE9wdGlvbih0aGlzLl9vLCBpKTtcblx0ICAgICAgcGFjay5wdXNoKG5ldyBDaGlsZFN3aXJsKHRoaXMuX2FkZE9wdGlvbmFsUHJvcHMob3B0aW9uLCBpKSkpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fc3dpcmxzID0geyAwOiBwYWNrIH07XG5cdCAgICB0aGlzLl9zZXRTd2lybER1cmF0aW9uKHRoaXMubWFzdGVyU3dpcmwsIHRoaXMuX2NhbGNQYWNrVGltZShwYWNrKSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNhdmUgdGltZWxpbmUgb3B0aW9ucyB0byBfdGltZWxpbmVPcHRpb25zXG5cdCAgICBhbmQgZGVsZXRlIHRoZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaGUgb2JqZWN0IHRvIHNhdmUgdGhlIHRpbWVsaW5lIG9wdGlvbnMgZnJvbS5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3NhdmVUaW1lbGluZU9wdGlvbnMgPSBmdW5jdGlvbiBfc2F2ZVRpbWVsaW5lT3B0aW9ucyhvKSB7XG5cdCAgICB0aGlzLl90aW1lbGluZU9wdGlvbnMgPSBvLnRpbWVsaW5lO1xuXHQgICAgZGVsZXRlIG8udGltZWxpbmU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSB0b3RhbCB0aW1lIG9mIGFycmF5IG9mXG5cdCAgICBjb25jdXJyZW50IHR3ZWVucy5cblx0ICAgIEBwYXJhbSAgIHtBcnJheX0gIFBhY2sgdG8gY2FsY3VsYXRlIHRoZSB0b3RhbCB0aW1lIGZvci5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFRvdGFsIHBhY2sgZHVyYXRpb24uXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9jYWxjUGFja1RpbWUgPSBmdW5jdGlvbiBfY2FsY1BhY2tUaW1lKHBhY2spIHtcblx0ICAgIHZhciBtYXhUaW1lID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFjay5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdHdlZW4gPSBwYWNrW2ldLnR3ZWVuLFxuXHQgICAgICAgICAgcCA9IHR3ZWVuLl9wcm9wcztcblxuXHQgICAgICBtYXhUaW1lID0gTWF0aC5tYXgocC5yZXBlYXRUaW1lIC8gcC5zcGVlZCwgbWF4VGltZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBtYXhUaW1lO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgZHVyYXRpb24gZm9yIFN3aXJsLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFN3aXJsIGluc3RhbmNlIHRvIHNldCB0aGUgZHVyYXRpb24gdG8uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRHVyYXRpb24gdG8gc2V0LlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fc2V0U3dpcmxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9zZXRTd2lybER1cmF0aW9uKHN3aXJsLCBkdXJhdGlvbikge1xuXHQgICAgc3dpcmwudHdlZW4uX3NldFByb3AoJ2R1cmF0aW9uJywgZHVyYXRpb24pO1xuXHQgICAgdmFyIGlzUmVjYWxjID0gc3dpcmwudGltZWxpbmUgJiYgc3dpcmwudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb247XG5cdCAgICBpc1JlY2FsYyAmJiBzd2lybC50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgY2hpbGRPcHRpb24gZm9ybSBvYmplY3QgY2FsbCBieSBtb2R1bHVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSAgIHtPYmplY3R9IE9iamVjdCB0byBsb29rIGluLlxuXHQgICAgQHBhcmFtICAge051bWJlcn0gSW5kZXggb2YgdGhlIGN1cnJlbnQgU3dpcmwuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGUgY3VycmVudCBzd2lybC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2dldENoaWxkT3B0aW9uID0gZnVuY3Rpb24gX2dldENoaWxkT3B0aW9uKG9iaiwgaSkge1xuXHQgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmouY2hpbGRyZW4pIHtcblx0ICAgICAgb3B0aW9uc1trZXldID0gdGhpcy5fZ2V0UHJvcEJ5TW9kKGtleSwgaSwgb2JqLmNoaWxkcmVuKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBvcHRpb25zO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcHJvcGVydHkgYnkgbW9kdWx1cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggZm9yIHRoZSBtb2R1bHVzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFNvdXJjZSBvYmplY3QgdG8gY2hlY2sgaW4uXG5cdCAgICBAcmV0dXJucyB7QW55fSBQcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2dldFByb3BCeU1vZCA9IGZ1bmN0aW9uIF9nZXRQcm9wQnlNb2QobmFtZSwgaW5kZXgpIHtcblx0ICAgIHZhciBzb3VyY2VPYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG5cdCAgICB2YXIgcHJvcCA9IHNvdXJjZU9ialtuYW1lXTtcblx0ICAgIHJldHVybiBfaDIuZGVmYXVsdC5pc0FycmF5KHByb3ApID8gcHJvcFtpbmRleCAlIHByb3AubGVuZ3RoXSA6IHByb3A7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBvcHRpb25hbCBTd2lybHMnIHByb3BlcnRpZXMgdG8gcGFzc2VkIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIGFkZCB0aGUgcHJvcGVydGllcyB0by5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgcHJvcGVydHkuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9hZGRPcHRpb25hbFByb3BzID0gZnVuY3Rpb24gX2FkZE9wdGlvbmFsUHJvcHMob3B0aW9ucywgaW5kZXgpIHtcblx0ICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcblx0ICAgIG9wdGlvbnMucGFyZW50ID0gdGhpcy5tYXN0ZXJTd2lybC5lbDtcblxuXHQgICAgdGhpcy5fYWRkQnVyc3RQcm9wZXJ0aWVzKG9wdGlvbnMsIGluZGV4KTtcblxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBCdXJzdCBvcHRpb25zIHRvIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyB0byBhZGQgdGhlIHByb3BlcnRpZXMgdG8uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIFN3aXJsLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBtYWluIHN3aXJsLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fYWRkQnVyc3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gX2FkZEJ1cnN0UHJvcGVydGllcyhvcHRpb25zLCBpbmRleCwgaSkge1xuXHQgICAgLy8gc2F2ZSBpbmRleCBvZiB0aGUgbW9kdWxlXG5cdCAgICB2YXIgbWFpbkluZGV4ID0gdGhpcy5faW5kZXg7XG5cdCAgICAvLyB0ZW1wb3JhcnkgY2hhbmdlIHRoZSBpbmRleCB0byBwYXJzZSBpbmRleCBiYXNlZCBwcm9wZXJ0aWVzIGxpa2Ugc3RhZ2dlclxuXHQgICAgdGhpcy5faW5kZXggPSBpbmRleDtcblx0ICAgIC8vIHBhcnNlIGRlZ3JlZSBzaGlmdCBmb3IgdGhlIGJpdFxuXHQgICAgdmFyIGRlZ3JlZVNoaWZ0ID0gdGhpcy5fcGFyc2VQcm9wZXJ0eSgnZGVncmVlU2hpZnQnLCBvcHRpb25zLmRlZ3JlZVNoaWZ0IHx8IDApO1xuXHQgICAgLy8gcHV0IHRoZSBpbmRleCBvZiB0aGUgbW9kdWxlIGJhY2tcblx0ICAgIHRoaXMuX2luZGV4ID0gbWFpbkluZGV4O1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGRlZ3JlZUNudCA9IHAuZGVncmVlICUgMzYwID09PSAwID8gcC5jb3VudCA6IHAuY291bnQgLSAxIHx8IDEsXG5cdCAgICAgICAgc3RlcCA9IHAuZGVncmVlIC8gZGVncmVlQ250LFxuXHQgICAgICAgIHBvaW50U3RhcnQgPSB0aGlzLl9nZXRTaWRlUG9pbnQoJ3N0YXJ0JywgaW5kZXggKiBzdGVwICsgZGVncmVlU2hpZnQsIGkpLFxuXHQgICAgICAgIHBvaW50RW5kID0gdGhpcy5fZ2V0U2lkZVBvaW50KCdlbmQnLCBpbmRleCAqIHN0ZXAgKyBkZWdyZWVTaGlmdCwgaSk7XG5cblx0ICAgIG9wdGlvbnMueCA9IHRoaXMuX2dldERlbHRhRnJvbVBvaW50cygneCcsIHBvaW50U3RhcnQsIHBvaW50RW5kKTtcblx0ICAgIG9wdGlvbnMueSA9IHRoaXMuX2dldERlbHRhRnJvbVBvaW50cygneScsIHBvaW50U3RhcnQsIHBvaW50RW5kKTtcblxuXHQgICAgb3B0aW9ucy5hbmdsZSA9IHRoaXMuX2dldEJpdEFuZ2xlKG9wdGlvbnMuYW5nbGUgfHwgMCwgZGVncmVlU2hpZnQsIGluZGV4KTtcblx0ICB9O1xuXHQgIC8qIFxuXHQgICAgTWV0aG9kIHRvIGdldCBzaGFwZXMgYW5nbGUgaW4gYnVyc3Qgc29cblx0ICAgIGl0IHdpbGwgZm9sbG93IGNpcmN1bGFyIHNoYXBlLlxuXHQgICAgIFxuXHQgICAgIEBwYXJhbSAgICB7TnVtYmVyLCBPYmplY3R9IEJhc2UgYW5nbGUuXG5cdCAgICAgQHBhcmFtICAgIHtOdW1iZXJ9ICAgICAgICAgQW5nbGUgc2hpZnQgZm9yIHRoZSBiaXRcblx0ICAgICBAcGFyYW0gICAge051bWJlcn0gICAgICAgICBTaGFwZSdzIGluZGV4IGluIGJ1cnN0LlxuXHQgICAgIEByZXR1cm5zICB7TnVtYmVyfSAgICAgICAgIEFuZ2xlIGluIGJ1cnN0LlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fZ2V0Qml0QW5nbGUgPSBmdW5jdGlvbiBfZ2V0Qml0QW5nbGUoKSB7XG5cdCAgICB2YXIgYW5nbGVQcm9wZXJ0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblx0ICAgIHZhciBhbmdsZVNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXHQgICAgdmFyIGkgPSBhcmd1bWVudHNbMl07XG5cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgZGVnQ250ID0gcC5kZWdyZWUgJSAzNjAgPT09IDAgPyBwLmNvdW50IDogcC5jb3VudCAtIDEgfHwgMSxcblx0ICAgICAgICBzdGVwID0gcC5kZWdyZWUgLyBkZWdDbnQsXG5cdCAgICAgICAgYW5nbGUgPSBpICogc3RlcCArIDkwO1xuXG5cdCAgICBhbmdsZSArPSBhbmdsZVNoaWZ0O1xuXHQgICAgLy8gaWYgbm90IGRlbHRhIG9wdGlvblxuXHQgICAgaWYgKCF0aGlzLl9pc0RlbHRhKGFuZ2xlUHJvcGVydHkpKSB7XG5cdCAgICAgIGFuZ2xlUHJvcGVydHkgKz0gYW5nbGU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgZGVsdGEgPSB7fSxcblx0ICAgICAgICAgIGtleXMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKGFuZ2xlUHJvcGVydHkpLFxuXHQgICAgICAgICAgc3RhcnQgPSBrZXlzWzBdLFxuXHQgICAgICAgICAgZW5kID0gYW5nbGVQcm9wZXJ0eVtzdGFydF07XG5cblx0ICAgICAgc3RhcnQgPSBfaDIuZGVmYXVsdC5wYXJzZVN0cmluZ09wdGlvbihzdGFydCwgaSk7XG5cdCAgICAgIGVuZCA9IF9oMi5kZWZhdWx0LnBhcnNlU3RyaW5nT3B0aW9uKGVuZCwgaSk7XG5cdCAgICAgIC8vIG5ldyBzdGFydCA9IG5ld0VuZFxuXHQgICAgICBkZWx0YVtwYXJzZUZsb2F0KHN0YXJ0KSArIGFuZ2xlXSA9IHBhcnNlRmxvYXQoZW5kKSArIGFuZ2xlO1xuXG5cdCAgICAgIGFuZ2xlUHJvcGVydHkgPSBkZWx0YTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBhbmdsZVByb3BlcnR5O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcmFkaWFsIHBvaW50IG9uIGBzdGFydGAgb3IgYGVuZGAuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHNpZGUgLSBbc3RhcnQsIGVuZF0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQW5nbGUgb2YgdGhlIHJhZGlhbCBwb2ludC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgbWFpbiBzd2lybC5cblx0ICAgIEByZXR1cm5zIHJhZGlhbCBwb2ludC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2dldFNpZGVQb2ludCA9IGZ1bmN0aW9uIF9nZXRTaWRlUG9pbnQoc2lkZSwgYW5nbGUsIGkpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc2lkZVJhZGl1cyA9IHRoaXMuX2dldFNpZGVSYWRpdXMoc2lkZSwgaSk7XG5cblx0ICAgIHJldHVybiBfaDIuZGVmYXVsdC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgIHJhZGl1czogc2lkZVJhZGl1cy5yYWRpdXMsXG5cdCAgICAgIHJhZGl1c1g6IHNpZGVSYWRpdXMucmFkaXVzWCxcblx0ICAgICAgcmFkaXVzWTogc2lkZVJhZGl1cy5yYWRpdXNZLFxuXHQgICAgICBhbmdsZTogYW5nbGUsXG5cdCAgICAgIC8vIGNlbnRlcjogIHsgeDogcC5jZW50ZXIsIHk6IHAuY2VudGVyIH1cblx0ICAgICAgY2VudGVyOiB7IHg6IDAsIHk6IDAgfVxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCByYWRpdXMgb2YgdGhlIHNpZGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHNpZGUgLSBbc3RhcnQsIGVuZF0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1haW4gc3dpcmwuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBSYWRpdXMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRTaWRlUmFkaXVzID0gZnVuY3Rpb24gX2dldFNpZGVSYWRpdXMoc2lkZSwgaSkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgcmFkaXVzOiB0aGlzLl9nZXRSYWRpdXNCeUtleSgncmFkaXVzJywgc2lkZSwgaSksXG5cdCAgICAgIHJhZGl1c1g6IHRoaXMuX2dldFJhZGl1c0J5S2V5KCdyYWRpdXNYJywgc2lkZSwgaSksXG5cdCAgICAgIHJhZGl1c1k6IHRoaXMuX2dldFJhZGl1c0J5S2V5KCdyYWRpdXNZJywgc2lkZSwgaSlcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCByYWRpdXMgZnJvbSDiiIYgb3IgcGxhaW4gcHJvcGVydHkuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IEtleSBuYW1lLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFNpZGUgbmFtZSAtIFtzdGFydCwgZW5kXS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgbWFpbiBzd2lybC5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFJhZGl1cyB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2dldFJhZGl1c0J5S2V5ID0gZnVuY3Rpb24gX2dldFJhZGl1c0J5S2V5KGtleSwgc2lkZSkge1xuXHQgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cblx0ICAgIHZhciBzd2lybCA9IHRoaXMuX21hc3RlclN3aXJsc1tpXSxcblx0ICAgICAgICBkZWx0YXMgPSBzd2lybC5fZGVsdGFzLFxuXHQgICAgICAgIHByb3BzID0gc3dpcmwuX3Byb3BzO1xuXG5cdCAgICBpZiAoZGVsdGFzW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gZGVsdGFzW2tleV1bc2lkZV07XG5cdCAgICB9IGVsc2UgaWYgKHByb3BzW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gcHJvcHNba2V5XTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGRlbHRhIGZyb20gc3RhcnQgYW5kIGVuZCBwb3NpdGlvbiBwb2ludHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IEtleSBuYW1lLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFN0YXJ0IHBvc2l0aW9uIHBvaW50LlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IEVuZCBwb3NpdGlvbiBwb2ludC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IERlbHRhIG9mIHRoZSBlbmQvc3RhcnQuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXREZWx0YUZyb21Qb2ludHMgPSBmdW5jdGlvbiBfZ2V0RGVsdGFGcm9tUG9pbnRzKGtleSwgcG9pbnRTdGFydCwgcG9pbnRFbmQpIHtcblx0ICAgIHZhciBkZWx0YSA9IHt9O1xuXHQgICAgaWYgKHBvaW50U3RhcnRba2V5XSA9PT0gcG9pbnRFbmRba2V5XSkge1xuXHQgICAgICBkZWx0YSA9IHBvaW50U3RhcnRba2V5XTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRlbHRhW3BvaW50U3RhcnRba2V5XV0gPSBwb2ludEVuZFtrZXldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdGltZWxpbmUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgVHdlZW5hYmxlXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9tYWtlVGltZWxpbmUgPSBmdW5jdGlvbiBfbWFrZVRpbWVsaW5lKCkge1xuXHQgICAgLy8gcmVzdG9yZSB0aW1lbGluZSBvcHRpb25zIHRoYXQgd2VyZSBkZWxldGVkIGluIF9yZW5kZXIgbWV0aG9kXG5cdCAgICB0aGlzLl9vLnRpbWVsaW5lID0gdGhpcy5fdGltZWxpbmVPcHRpb25zO1xuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLl9tYWtlVGltZWxpbmUuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMudGltZWxpbmUuYWRkKHRoaXMubWFzdGVyU3dpcmwsIHRoaXMuX3N3aXJsc1swXSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIG1ha2UgVHdlZW4gZm9yIHRoZSBtb2R1bGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgVHdlZW5hYmxlXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9tYWtlVHdlZW4gPSBmdW5jdGlvbiBfbWFrZVR3ZWVuKCkge30gLyogZG9uJ3QgY3JlYXRlIGFueSB0d2VlbiAqL1xuXHQgIC8qXG5cdCAgICBPdmVycmlkZSBgX2hpZGVgIGFuZCBgX3Nob3dgIG1ldGhvZHMgb24gbW9kdWxlXG5cdCAgICBzaW5jZSB3ZSBkb24ndCBoYXZlIHRvIGhpZGUgbm9yIHNob3cgb24gdGhlIG1vZHVsZS5cblx0ICAqL1xuXHQgIDtcblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5faGlkZSA9IGZ1bmN0aW9uIF9oaWRlKCkgey8qIGRvIG5vdGhpbmcgKi99O1xuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9zaG93ID0gZnVuY3Rpb24gX3Nob3coKSB7LyogZG8gbm90aGluZyAqL307XG5cblx0ICByZXR1cm4gQnVyc3Q7XG5cdH0oX3R1bmFibGUyLmRlZmF1bHQpO1xuXG5cdHZhciBDaGlsZFN3aXJsID0gZnVuY3Rpb24gKF9TaGFwZVN3aXJsKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQ2hpbGRTd2lybCwgX1NoYXBlU3dpcmwpO1xuXG5cdCAgZnVuY3Rpb24gQ2hpbGRTd2lybCgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIENoaWxkU3dpcmwpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1NoYXBlU3dpcmwuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgQ2hpbGRTd2lybC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICBfU2hhcGVTd2lybC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuaXNTd2lybCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fby5kdXJhdGlvbiA9IHRoaXMuX28uZHVyYXRpb24gIT0gbnVsbCA/IHRoaXMuX28uZHVyYXRpb24gOiA3MDA7XG5cdCAgfTtcblx0ICAvLyBkaXNhYmxlIGRlZ3JlZXNoaWZ0IGNhbGN1bGF0aW9uc1xuXG5cblx0ICBDaGlsZFN3aXJsLnByb3RvdHlwZS5fY2FsY1N3aXJsWFkgPSBmdW5jdGlvbiBfY2FsY1N3aXJsWFkocHJvYykge1xuXHQgICAgdmFyIGRlZ3JlZVNoaWZ0ID0gdGhpcy5fcHJvcHMuZGVncmVlU2hpZnQ7XG5cblx0ICAgIHRoaXMuX3Byb3BzLmRlZ3JlZVNoaWZ0ID0gMDtcblx0ICAgIF9TaGFwZVN3aXJsLnByb3RvdHlwZS5fY2FsY1N3aXJsWFkuY2FsbCh0aGlzLCBwcm9jKTtcblx0ICAgIHRoaXMuX3Byb3BzLmRlZ3JlZVNoaWZ0ID0gZGVncmVlU2hpZnQ7XG5cdCAgfTtcblxuXHQgIHJldHVybiBDaGlsZFN3aXJsO1xuXHR9KF9zaGFwZVN3aXJsMi5kZWZhdWx0KTtcblxuXHR2YXIgTWFpblN3aXJsID0gZnVuY3Rpb24gKF9DaGlsZFN3aXJsKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoTWFpblN3aXJsLCBfQ2hpbGRTd2lybCk7XG5cblx0ICBmdW5jdGlvbiBNYWluU3dpcmwoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBNYWluU3dpcmwpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX0NoaWxkU3dpcmwuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgTWFpblN3aXJsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIF9DaGlsZFN3aXJsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5zY2FsZSA9IDE7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy53aWR0aCA9IDA7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5oZWlnaHQgPSAwO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMucmFkaXVzID0geyAyNTogNzUgfTtcblx0ICAgIC8vIHRoaXMuX2RlZmF1bHRzLmR1cmF0aW9uID0gMjAwMDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIE1haW5Td2lybDtcblx0fShDaGlsZFN3aXJsKTtcblxuXHRCdXJzdC5DaGlsZFN3aXJsID0gQ2hpbGRTd2lybDtcblx0QnVyc3QuTWFpblN3aXJsID0gTWFpblN3aXJsO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEJ1cnN0O1xuXG4vKioqLyB9KSxcbi8qIDExOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfZXh0ZW5kczQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG5cblx0dmFyIF9leHRlbmRzNSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZHM0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF90aGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuXG5cdHZhciBfdGhlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbmFibGUpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF9kZWx0YXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNSk7XG5cblx0dmFyIF9kZWx0YXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVsdGFzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblxuXHQvLyBnZXQgdHdlZW4gcHJvcGVydGllc1xuXHR2YXIgb2JqID0ge307XG5cdF90d2VlbjIuZGVmYXVsdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKG9iaik7XG5cdHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShvYmouX2RlZmF1bHRzKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgb2JqLl9kZWZhdWx0c1trZXlzW2ldXSA9IDE7XG5cdH1cblx0b2JqLl9kZWZhdWx0c1sndGltZWxpbmUnXSA9IDE7XG5cdHZhciBUV0VFTl9QUk9QRVJUSUVTID0gb2JqLl9kZWZhdWx0cztcblxuXHQvKlxuXHQgIFRPRE86XG5cblx0ICAgIC0gY2hhbmdlIF9wcm9wcyB0byBfcHJvcHNPYmogZm9yIGFuaW1hdGlvbnNcblx0ICAgIC0gY3VycmVudCB2YWx1ZXMgaW4gZGVsdGFzXG5cdCovXG5cblx0dmFyIEh0bWwgPSBmdW5jdGlvbiAoX1RoZW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoSHRtbCwgX1RoZW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIEh0bWwoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBIdG1sKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9UaGVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICBIdG1sLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuXHQgICAgICB4OiAwLFxuXHQgICAgICB5OiAwLFxuXHQgICAgICB6OiAwLFxuXG5cdCAgICAgIHNrZXdYOiAwLFxuXHQgICAgICBza2V3WTogMCxcblxuXHQgICAgICAvLyBhbmdsZTogICAgICAwLFxuXHQgICAgICBhbmdsZVg6IDAsXG5cdCAgICAgIGFuZ2xlWTogMCxcblx0ICAgICAgYW5nbGVaOiAwLFxuXG5cdCAgICAgIHNjYWxlOiAxLFxuXHQgICAgICBzY2FsZVg6IDEsXG5cdCAgICAgIHNjYWxlWTogMSxcblxuXHQgICAgICBpc1NvZnRIaWRlOiB0cnVlLFxuXHQgICAgICBpc1Nob3dTdGFydDogdHJ1ZSxcblx0ICAgICAgaXNTaG93RW5kOiB0cnVlLFxuXHQgICAgICBpc0ZvcmNlM2Q6IGZhbHNlLFxuXHQgICAgICBpc1JlZnJlc2hTdGF0ZTogdHJ1ZVxuXG5cdCAgICB9O1xuXHQgICAgLy8gZXhjbHVkZSBmcm9tIGF1dG9tYXRpYyBkcmF3aW5nXG5cdCAgICB0aGlzLl9kcmF3RXhjbHVkZSA9IHsgZWw6IDEgfTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBjYXVzZSAzZCBsYXllclxuXHQgICAgdGhpcy5fM2RQcm9wZXJ0aWVzID0gWydhbmdsZVgnLCAnYW5nbGVZJywgJ3onXTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBoYXZlIGFycmF5IHZhbHVlc1xuXHQgICAgdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCA9IHsgdHJhbnNmb3JtT3JpZ2luOiAxLCBiYWNrZ3JvdW5kUG9zaXRpb246IDEgfTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBoYXZlIG5vIHVuaXRzXG5cdCAgICB0aGlzLl9udW1iZXJQcm9wZXJ0eU1hcCA9IHtcblx0ICAgICAgb3BhY2l0eTogMSwgc2NhbGU6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxLFxuXHQgICAgICAvLyBhbmdsZTogMSxcblx0ICAgICAgYW5nbGVYOiAxLCBhbmdsZVk6IDEsIGFuZ2xlWjogMSxcblx0ICAgICAgc2tld1g6IDEsIHNrZXdZOiAxXG5cdCAgICB9O1xuXHQgICAgLy8gcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBwcmVmaXhlZCBcblx0ICAgIHRoaXMuX3ByZWZpeFByb3BlcnR5TWFwID0geyB0cmFuc2Zvcm06IDEsIHRyYW5zZm9ybU9yaWdpbjogMSB9O1xuXHQgICAgLy8gc2F2ZSBwcmVmaXhcblx0ICAgIHRoaXMuX3ByZWZpeCA9IGgucHJlZml4LmNzcztcblx0ICB9O1xuXG5cdCAgSHRtbC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4obykge1xuXHQgICAgLy8gcmV0dXJuIGlmIG5vdGhpbmcgd2FzIHBhc3NlZFxuXHQgICAgaWYgKG8gPT0gbnVsbCB8fCAhKDAsIF9rZXlzMi5kZWZhdWx0KShvKS5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cblx0ICAgIC8vIGdldCB0aGUgbGFzdCBpdGVtIGluIGB0aGVuYCBjaGFpblxuXHQgICAgdmFyIHByZXZNb2R1bGUgPSBoLmdldExhc3RJdGVtKHRoaXMuX21vZHVsZXMpO1xuXHQgICAgLy8gc2V0IGRlbHRhcyB0byB0aGUgZmluaXNoIHN0YXRlXG5cdCAgICBwcmV2TW9kdWxlLmRlbHRhcy5yZWZyZXNoKGZhbHNlKTtcblx0ICAgIC8vIGNvcHkgZmluaXNoIHN0YXRlIHRvIHRoZSBsYXN0IGhpc3RvcnkgcmVjb3JkXG5cdCAgICB0aGlzLl9oaXN0b3J5W3RoaXMuX2hpc3RvcnkubGVuZ3RoIC0gMV0gPSBwcmV2TW9kdWxlLl9vO1xuXHQgICAgLy8gY2FsbCBzdXBlclxuXHQgICAgX1RoZW5hYmxlLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcywgbyk7XG5cdCAgICAvLyByZXN0b3JlIHRoZSBfcHJvcHNcblx0ICAgIHByZXZNb2R1bGUuZGVsdGFzLnJlc3RvcmUoKTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBpcGUgc3RhcnRWYWx1ZSBvZiB0aGUgZGVsdGEuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92YXJyaWRlcyBAIFRoZW5hYmxlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gU3RhcnQgcHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBTdGFydCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtBbnl9IFN0YXJ0IHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9jaGVja1N0YXJ0VmFsdWUgPSBmdW5jdGlvbiBfY2hlY2tTdGFydFZhbHVlKGtleSwgdmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgIC8vIHJldHVybiBkZWZhdWx0IHZhbHVlIGZvciB0cmFuc2Zvcm1zXG5cdCAgICAgIGlmICh0aGlzLl9kZWZhdWx0c1trZXldICE9IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0ICAgICAgfVxuXHQgICAgICAvLyByZXR1cm4gZGVmYXVsdCB2YWx1ZSBmcm9tIF9jdXN0b21Qcm9wc1xuXHQgICAgICBpZiAodGhpcy5fY3VzdG9tUHJvcHNba2V5XSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbVByb3BzW2tleV07XG5cdCAgICAgIH1cblx0ICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgZGVmYXVsdCB2YWx1ZVxuXHQgICAgICBpZiAoaC5kZWZhdWx0U3R5bGVzW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBoLmRlZmF1bHRTdHlsZXNba2V5XTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBhdCB0aGUgZW5kIHJldHVybiAwXG5cdCAgICAgIHJldHVybiAwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgX3Byb3BzIHRvIGVsLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uIF9kcmF3KCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZHJhd1Byb3BzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBuYW1lID0gdGhpcy5fZHJhd1Byb3BzW2ldO1xuXHQgICAgICB0aGlzLl9zZXRTdHlsZShuYW1lLCBwW25hbWVdKTtcblx0ICAgIH1cblx0ICAgIC8vIGRyYXcgdHJhbnNmb3Jtc1xuXHQgICAgdGhpcy5fZHJhd1RyYW5zZm9ybSgpO1xuXHQgICAgLy8gY2FsbCBjdXN0b20gdHJhbnNmb3JtIGNhbGxiYWNrIGlmIGV4aXN0XG5cdCAgICB0aGlzLl9jdXN0b21EcmF3ICYmIHRoaXMuX2N1c3RvbURyYXcodGhpcy5fcHJvcHMuZWwsIHRoaXMuX3Byb3BzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHRyYW5zZm9ybSBvbiBlbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fZHJhd1RyYW5zZm9ybSA9IGZ1bmN0aW9uIF9kcmF3VHJhbnNmb3JtKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHZhciBzdHJpbmcgPSAhdGhpcy5faXMzZCA/ICd0cmFuc2xhdGUoJyArIHAueCArICcsICcgKyBwLnkgKyAnKVxcbiAgICAgICAgICByb3RhdGUoJyArIHAuYW5nbGVaICsgJ2RlZylcXG4gICAgICAgICAgc2tldygnICsgcC5za2V3WCArICdkZWcsICcgKyBwLnNrZXdZICsgJ2RlZylcXG4gICAgICAgICAgc2NhbGUoJyArIHAuc2NhbGVYICsgJywgJyArIHAuc2NhbGVZICsgJyknIDogJ3RyYW5zbGF0ZTNkKCcgKyBwLnggKyAnLCAnICsgcC55ICsgJywgJyArIHAueiArICcpXFxuICAgICAgICAgIHJvdGF0ZVgoJyArIHAuYW5nbGVYICsgJ2RlZylcXG4gICAgICAgICAgcm90YXRlWSgnICsgcC5hbmdsZVkgKyAnZGVnKVxcbiAgICAgICAgICByb3RhdGVaKCcgKyBwLmFuZ2xlWiArICdkZWcpXFxuICAgICAgICAgIHNrZXcoJyArIHAuc2tld1ggKyAnZGVnLCAnICsgcC5za2V3WSArICdkZWcpXFxuICAgICAgICAgIHNjYWxlKCcgKyBwLnNjYWxlWCArICcsICcgKyBwLnNjYWxlWSArICcpJztcblxuXHQgICAgdGhpcy5fc2V0U3R5bGUoJ3RyYW5zZm9ybScsIHN0cmluZyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlbmRlciBvbiBpbml0aWFsaXphdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgTW9kdWxlXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIF9yZW5kZXIoKSB7XG5cdCAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaWYgbm90IHRoZSBmaXJzdCBpbiBgdGhlbmAgY2hhaW5cblx0ICAgIGlmICh0aGlzLl9vLnByZXZDaGFpbk1vZHVsZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVuZGVyUHJvcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG5hbWUgPSB0aGlzLl9yZW5kZXJQcm9wc1tpXSxcblx0ICAgICAgICAgIHZhbHVlID0gcFtuYW1lXTtcblxuXHQgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSArICdweCcgOiB2YWx1ZTtcblx0ICAgICAgdGhpcy5fc2V0U3R5bGUobmFtZSwgdmFsdWUpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl9kcmF3KCk7XG5cblx0ICAgIGlmICghcC5pc1Nob3dTdGFydCkge1xuXHQgICAgICB0aGlzLl9oaWRlKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBzdHlsZSBvbiBlbC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gU3R5bGUgcHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTdHlsZSBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fc2V0U3R5bGUgPSBmdW5jdGlvbiBfc2V0U3R5bGUobmFtZSwgdmFsdWUpIHtcblx0ICAgIGlmICh0aGlzLl9zdGF0ZVtuYW1lXSAhPT0gdmFsdWUpIHtcblx0ICAgICAgdmFyIHN0eWxlID0gdGhpcy5fcHJvcHMuZWwuc3R5bGU7XG5cdCAgICAgIC8vIHNldCBzdHlsZVxuXHQgICAgICBzdHlsZVtuYW1lXSA9IHZhbHVlO1xuXHQgICAgICAvLyBpZiBwcmVmaXggbmVlZGVkIC0gc2V0IGl0XG5cdCAgICAgIGlmICh0aGlzLl9wcmVmaXhQcm9wZXJ0eU1hcFtuYW1lXSkge1xuXHQgICAgICAgIHN0eWxlWycnICsgdGhpcy5fcHJlZml4ICsgbmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgfVxuXHQgICAgICAvLyBjYWNoZSB0aGUgbGFzdCBzZXQgdmFsdWVcblx0ICAgICAgdGhpcy5fc3RhdGVbbmFtZV0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY29weSBgX29gIG9wdGlvbnMgdG8gYF9wcm9wc2Agb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICB0aGlzLl9wcm9wcyA9IHRoaXMuX28ucHJvcHMgfHwge307XG5cdCAgICAvLyBwcm9wcyBmb3IgaW50aWFsIHJlbmRlciBvbmx5XG5cdCAgICB0aGlzLl9yZW5kZXJQcm9wcyA9IFtdO1xuXHQgICAgLy8gcHJvcHMgZm9yIGRyYXcgb24gZXZlcnkgZnJhbWUgdXBkYXRlXG5cdCAgICB0aGlzLl9kcmF3UHJvcHMgPSBbXTtcblx0ICAgIC8vIHNhdmUgY3VzdG9tIHByb3BlcnRpZXMgaWYgcHJlc2VudFxuXHQgICAgdGhpcy5fc2F2ZUN1c3RvbVByb3BlcnRpZXModGhpcy5fbyk7XG5cdCAgICAvLyBjb3B5IHRoZSBvcHRpb25zXG5cdCAgICB2YXIgbyA9ICgwLCBfZXh0ZW5kczUuZGVmYXVsdCkoe30sIHRoaXMuX28pO1xuXHQgICAgLy8gZXh0ZW5kIG9wdGlvbnMgd2l0aCBkZWZhdWx0c1xuXHQgICAgbyA9IHRoaXMuX2FkZERlZmF1bHRzKG8pO1xuXG5cdCAgICB2YXIga2V5cyA9ICgwLCBfa2V5czIuZGVmYXVsdCkobyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cdCAgICAgIC8vIGluY2x1ZGUgdGhlIHByb3BlcnR5IGlmIGl0IGlzIG5vdCBpbiBkcmF3RXhjbHVkZSBvYmplY3Rcblx0ICAgICAgLy8gYW5kIG5vdCBpbiBkZWZhdWx0cyA9IG5vdCBhIHRyYW5zZm9ybVxuXHQgICAgICB2YXIgaXNJbmNsdWRlID0gIXRoaXMuX2RyYXdFeGNsdWRlW2tleV0gJiYgLy8gbm90IGluIGV4Y2x1ZGUgbWFwXG5cdCAgICAgIHRoaXMuX2RlZmF1bHRzW2tleV0gPT0gbnVsbCAmJiAvLyBub3QgdHJhbnNmb3JtIHByb3BlcnR5XG5cdCAgICAgICFUV0VFTl9QUk9QRVJUSUVTW2tleV07IC8vIG5vdCB0d2VlbiBwcm9wZXJ0eVxuXG5cdCAgICAgIHZhciBpc0N1c3RvbSA9IHRoaXMuX2N1c3RvbVByb3BzW2tleV07XG5cdCAgICAgIC8vIGNvcHkgYWxsIG5vbi1kZWx0YSBwcm9wZXJ0aWVzIHRvIHRoZSBwcm9wc1xuXHQgICAgICAvLyBpZiBub3QgZGVsdGEgdGhlbiBhZGQgdGhlIHByb3BlcnR5IHRvIHJlbmRlclxuXHQgICAgICAvLyBsaXN0IHRoYXQgaXMgY2FsbGVkIG9uIGluaXRpYWxpemF0aW9uXG5cdCAgICAgIC8vIG90aGVyd2lzZSBhZGQgaXQgdG8gdGhlIGRyYXcgbGlzdCB0aGF0IHdpbGxcblx0ICAgICAgLy8gYmUgZHJhd2VkIG9uIGVhY2ggZnJhbWVcblx0ICAgICAgaWYgKCFoLmlzRGVsdGEob1trZXldKSAmJiAhVFdFRU5fUFJPUEVSVElFU1trZXldKSB7XG5cdCAgICAgICAgdGhpcy5fcGFyc2VPcHRpb24oa2V5LCBvW2tleV0pO1xuXHQgICAgICAgIGlmIChrZXkgPT09ICdlbCcpIHtcblx0ICAgICAgICAgIHRoaXMuX3Byb3BzLmVsID0gaC5wYXJzZUVsKG8uZWwpO1xuXHQgICAgICAgICAgdGhpcy5lbCA9IHRoaXMuX3Byb3BzLmVsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNJbmNsdWRlICYmICFpc0N1c3RvbSkge1xuXHQgICAgICAgICAgdGhpcy5fcmVuZGVyUHJvcHMucHVzaChrZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBjb3B5IGRlbHRhIHByb3AgYnV0IG5vdCB0cmFuc2Zvcm1zXG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIHB1c2ggaXQgdG8gZHJhdyBsaXN0IHRoYXQgZ2V0cyB0cmF2ZXJzZWQgb24gZXZlcnkgZHJhd1xuXHQgICAgICB9IGVsc2UgaWYgKGlzSW5jbHVkZSAmJiAhaXNDdXN0b20pIHtcblx0ICAgICAgICB0aGlzLl9kcmF3UHJvcHMucHVzaChrZXkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2NyZWF0ZURlbHRhcyhvKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2F2ZSBjdXN0b21Qcm9wZXJ0aWVzIHRvIF9jdXN0b21Qcm9wcy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9mIHRoZSBtb2R1bGUuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX3NhdmVDdXN0b21Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gX3NhdmVDdXN0b21Qcm9wZXJ0aWVzKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cdCAgICB0aGlzLl9jdXN0b21Qcm9wcyA9IG8uY3VzdG9tUHJvcGVydGllcyB8fCB7fTtcblx0ICAgIHRoaXMuX2N1c3RvbVByb3BzID0gKDAsIF9leHRlbmRzNS5kZWZhdWx0KSh7fSwgdGhpcy5fY3VzdG9tUHJvcHMpO1xuXHQgICAgdGhpcy5fY3VzdG9tRHJhdyA9IHRoaXMuX2N1c3RvbVByb3BzLmRyYXc7XG5cdCAgICBkZWxldGUgdGhpcy5fY3VzdG9tUHJvcHMuZHJhdztcblx0ICAgIGRlbGV0ZSBvLmN1c3RvbVByb3BlcnRpZXM7XG5cblx0ICAgIHRoaXMuX2NvcHlEZWZhdWx0Q3VzdG9tUHJvcHMoKTtcblxuXHQgICAgLy8gaWYgKCB0aGlzLl9jdXN0b21Qcm9wcyApIHt9XG5cdCAgICAvLyB0aGlzLl9jdXN0b21Qcm9wcyA9IHRoaXMuX2N1c3RvbVByb3BzIHx8IHt9O1xuXHQgIH07XG5cblx0ICBIdG1sLnByb3RvdHlwZS5fY29weURlZmF1bHRDdXN0b21Qcm9wcyA9IGZ1bmN0aW9uIF9jb3B5RGVmYXVsdEN1c3RvbVByb3BzKCkge1xuXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2N1c3RvbVByb3BzKSB7XG5cdCAgICAgIGlmICh0aGlzLl9vW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgIHRoaXMuX29ba2V5XSA9IHRoaXMuX2N1c3RvbVByb3BzW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzZXQgc29tZSBmbGFncyBvbiBtZXJnZWQgb3B0aW9ucyBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIFRoZW5hYmxlXG5cdCAgICBAcGFyYW0gICB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9yZXNldE1lcmdlZEZsYWdzID0gZnVuY3Rpb24gX3Jlc2V0TWVyZ2VkRmxhZ3Mobykge1xuXHQgICAgX1RoZW5hYmxlLnByb3RvdHlwZS5fcmVzZXRNZXJnZWRGbGFncy5jYWxsKHRoaXMsIG8pO1xuXHQgICAgby5wcm9wcyA9IHRoaXMuX3Byb3BzO1xuXHQgICAgby5jdXN0b21Qcm9wZXJ0aWVzID0gdGhpcy5fY3VzdG9tUHJvcHM7XG5cdCAgICByZXR1cm4gbztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2Ugb3B0aW9uIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBPcHRpb24gbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBPcHRpb24gdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX3BhcnNlT3B0aW9uID0gZnVuY3Rpb24gX3BhcnNlT3B0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgIF9UaGVuYWJsZS5wcm90b3R5cGUuX3BhcnNlT3B0aW9uLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG5cdCAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBwcm9wZXJ0eSBpcyBwYXJzZWRcblx0ICAgIHZhciBwYXJzZWQgPSB0aGlzLl9wcm9wc1trZXldO1xuXHQgICAgLy8gY2FzdCBpdCB0byBzdHJpbmcgaWYgaXQgaXMgYXJyYXlcblx0ICAgIGlmIChoLmlzQXJyYXkocGFyc2VkKSkge1xuXHQgICAgICB0aGlzLl9wcm9wc1trZXldID0gdGhpcy5fYXJyVG9TdHJpbmcocGFyc2VkKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FzdCBhcnJheSB0byBzdHJpbmcgdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBcnJheX0gQXJyYXkgb2YgcGFyc2VkIG51bWJlcnMgd2l0aCB1bml0cy5cblx0ICAgIEByZXR1cm5zIHtTdHJpbmd9IENhc3RlZCBhcnJheS5cblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fYXJyVG9TdHJpbmcgPSBmdW5jdGlvbiBfYXJyVG9TdHJpbmcoYXJyKSB7XG5cdCAgICB2YXIgc3RyaW5nID0gJyc7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdHJpbmcgKz0gYXJyW2ldLnN0cmluZyArICcgJztcblx0ICAgIH1cblx0ICAgIHJldHVybiBzdHJpbmc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBkZWZhdWxzIHRvIHBhc3NlZCBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byBhZGQgZGVmYXVsdHMgdG8uXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2FkZERlZmF1bHRzID0gZnVuY3Rpb24gX2FkZERlZmF1bHRzKG9iaikge1xuXHQgICAgLy8gZmxhZyB0aGF0IGFmdGVyIGFsbCBkZWZhdWx0cyBhcmUgc2V0IHdpbGwgaW5kaWNhdGVcblx0ICAgIC8vIGlmIHVzZXIgaGF2ZSBzZXQgdGhlIDNkIHRyYW5zZm9ybVxuXHQgICAgdGhpcy5faXMzZCA9IGZhbHNlO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0ICAgICAgLy8gc2tpcCBwcm9wZXJ0eSBpZiBpdCBpcyBsaXN0ZWQgaW4gX3NraXBQcm9wc1xuXHQgICAgICAvLyBpZiAodGhpcy5fc2tpcFByb3BzICYmIHRoaXMuX3NraXBQcm9wc1trZXldKSB7IGNvbnRpbnVlOyB9XG5cblx0ICAgICAgLy8gY29weSB0aGUgcHJvcGVydGllcyB0byB0aGUgX28gb2JqZWN0XG5cdCAgICAgIC8vIGlmIGl0J3MgbnVsbCAtIHNldCB0aGUgZGVmYXVsdCB2YWx1ZVxuXHQgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgIC8vIHNjYWxlWCBhbmQgc2NhbGVZIHNob3VsZCBmYWxsYmFjayB0byBzY2FsZVxuXHQgICAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnIHx8IGtleSA9PT0gJ3NjYWxlWScpIHtcblx0ICAgICAgICAgIG9ialtrZXldID0gb2JqWydzY2FsZSddICE9IG51bGwgPyBvYmpbJ3NjYWxlJ10gOiB0aGlzLl9kZWZhdWx0c1snc2NhbGUnXTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb2JqW2tleV0gPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAvLyBnZXQgaWYgM2QgcHJvcGVydHkgd2FzIHNldC5cblx0ICAgICAgICBpZiAodGhpcy5fM2RQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcblx0ICAgICAgICAgIHRoaXMuX2lzM2QgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5fby5pc0ZvcmNlM2QpIHtcblx0ICAgICAgdGhpcy5faXMzZCA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvYmo7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTGlmZWN5Y2xlIG1ldGhvZCB0byBkZWNsYXJlIHZhcmlhYmxlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIC8vIHNldCBkZWx0YXMgdG8gdGhlIGxhc3QgdmFsdWUsIHNvIHRoZSBfcHJvcHMgd2l0aFxuXHQgICAgLy8gZW5kIHZhbHVlcyB3aWxsIGJlIGNvcGllZCB0byB0aGUgX2hpc3RvcnksIGl0IGlzXG5cdCAgICAvLyBjcnVjaWFsIGZvciBgdGhlbmAgY2hhaW5pbmdcblx0ICAgIHRoaXMuZGVsdGFzLnJlZnJlc2goZmFsc2UpO1xuXHQgICAgLy8gY2FsbCBzdXBlciB2YXJzXG5cdCAgICBfVGhlbmFibGUucHJvdG90eXBlLl92YXJzLmNhbGwodGhpcyk7XG5cdCAgICAvLyBzdGF0ZSBvZiBzZXQgcHJvcGVydGllc1xuXHQgICAgdGhpcy5fc3RhdGUgPSB7fTtcblx0ICAgIC8vIHJlc3RvcmUgZGVsdGEgdmFsdWVzIHRoYXQgd2UgaGF2ZSByZWZyZXNoZWQgYmVmb3JlXG5cdCAgICB0aGlzLmRlbHRhcy5yZXN0b3JlKGZhbHNlKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIGRlbHRhcyBmcm9tIHBhc3NlZCBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIERlbHRhcy5cblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fY3JlYXRlRGVsdGFzID0gZnVuY3Rpb24gX2NyZWF0ZURlbHRhcyhvcHRpb25zKSB7XG5cdCAgICB0aGlzLmRlbHRhcyA9IG5ldyBfZGVsdGFzMi5kZWZhdWx0KHtcblx0ICAgICAgb3B0aW9uczogb3B0aW9ucyxcblx0ICAgICAgcHJvcHM6IHRoaXMuX3Byb3BzLFxuXHQgICAgICBhcnJheVByb3BlcnR5TWFwOiB0aGlzLl9hcnJheVByb3BlcnR5TWFwLFxuXHQgICAgICBudW1iZXJQcm9wZXJ0eU1hcDogdGhpcy5fbnVtYmVyUHJvcGVydHlNYXAsXG5cdCAgICAgIGN1c3RvbVByb3BzOiB0aGlzLl9jdXN0b21Qcm9wcyxcblx0ICAgICAgY2FsbGJhY2tzQ29udGV4dDogb3B0aW9ucy5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMsXG5cdCAgICAgIGlzQ2hhaW5lZDogISF0aGlzLl9vLnByZXZDaGFpbk1vZHVsZVxuXHQgICAgfSk7XG5cblx0ICAgIC8vIGlmIGNoYWluZWQgbW9kdWxlIHNldCB0aW1lbGluZSB0byBkZWx0YXMnIHRpbWVsaW5lIFxuXHQgICAgaWYgKHRoaXMuX28ucHJldkNoYWluTW9kdWxlKSB7XG5cdCAgICAgIHRoaXMudGltZWxpbmUgPSB0aGlzLmRlbHRhcy50aW1lbGluZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qIEBvdmVycmlkZXMgQCBUd2VlbmFibGUgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX21ha2VUd2VlbiA9IGZ1bmN0aW9uIF9tYWtlVHdlZW4oKSB7fTtcblxuXHQgIEh0bWwucHJvdG90eXBlLl9tYWtlVGltZWxpbmUgPSBmdW5jdGlvbiBfbWFrZVRpbWVsaW5lKCkge1xuXHQgICAgLy8gZG8gbm90IGNyZWF0ZSB0aW1lbGluZSBpZiBtb2R1bGUgaWYgY2hhaW5lZFxuXHQgICAgaWYgKHRoaXMuX28ucHJldkNoYWluTW9kdWxlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIGFkZCBjYWxsYmFja3Mgb3ZlcnJpZGVzXG5cdCAgICB0aGlzLl9vLnRpbWVsaW5lID0gdGhpcy5fby50aW1lbGluZSB8fCB7fTtcblx0ICAgIHRoaXMuX2FkZENhbGxiYWNrT3ZlcnJpZGVzKHRoaXMuX28udGltZWxpbmUpO1xuXHQgICAgX1RoZW5hYmxlLnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLmRlbHRhcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBjYWxsYmFjayBvdmVycmlkZXMgdG8gcGFzc2VkIG9iamVjdCBvYmplY3QuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIGFkZCBvdmVycmlkZXMgb24uXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2FkZENhbGxiYWNrT3ZlcnJpZGVzID0gZnVuY3Rpb24gX2FkZENhbGxiYWNrT3ZlcnJpZGVzKG8pIHtcblx0ICAgIHZhciBpdCA9IHRoaXM7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgby5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgICAgb25VcGRhdGU6IHRoaXMuX2RyYXcsXG5cdCAgICAgIG9uUmVmcmVzaDogdGhpcy5fcHJvcHMuaXNSZWZyZXNoU3RhdGUgPyB0aGlzLl9kcmF3IDogdm9pZCAwLFxuXHQgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KGlzRndkKSB7XG5cdCAgICAgICAgLy8gZG9uJ3QgdG91Y2ggbWFpbiBgZWxgIG9uU3RhcnQgaW4gY2hhaW5lZCBlbGVtZW50c1xuXHQgICAgICAgIGlmIChpdC5faXNDaGFpbmVkKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBzaG93IGlmIHdhcyBoaWRkZW4gYXQgc3RhcnRcblx0ICAgICAgICBpZiAoaXNGd2QgJiYgIXAuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgICAgIGl0Ll9zaG93KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGhpZGUgaWYgc2hvdWxkIGJlIGhpZGRlbiBhdCBzdGFydFxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoIXAuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgICAgICAgICBpdC5faGlkZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoaXNGd2QpIHtcblx0ICAgICAgICAvLyBkb24ndCB0b3VjaCBtYWluIGBlbGAgaWYgbm90IHRoZSBsYXN0IGluIGB0aGVuYCBjaGFpblxuXHQgICAgICAgIGlmIChpdC5faXNDaGFpbmVkKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0Z3ZCkge1xuXHQgICAgICAgICAgaWYgKCFwLmlzU2hvd0VuZCkge1xuXHQgICAgICAgICAgICBpdC5faGlkZSgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoIXAuaXNTaG93RW5kKSB7XG5cdCAgICAgICAgICBpdC5fc2hvdygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIG9uIGBzb2Z0YCBzaG93IG9mIHRoZSBtb2R1bGUsXG5cdCAgICBpdCBzaG91bGQgcmVzdG9yZSB0cmFuc2Zvcm0gc3R5bGVzIG9mIHRoZSBtb2R1bGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9zaG93QnlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2hvd0J5VHJhbnNmb3JtKCkge1xuXHQgICAgdGhpcy5fZHJhd1RyYW5zZm9ybSgpO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIG1lcmdlIGBzdGFydGAgYW5kIGBlbmRgIGZvciBhIHByb3BlcnR5IGluIHRoZW4gcmVjb3JkLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBFbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICovXG5cdCAgLy8gISEgQ09WRVIgISFcblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX21lcmdlVGhlblByb3BlcnR5ID0gZnVuY3Rpb24gX21lcmdlVGhlblByb3BlcnR5KGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcblx0ICAgIC8vIGlmIGlzbnQgdHdlZW4gcHJvcGVydHlcblx0ICAgIHZhciBpc0Jvb2xlYW4gPSB0eXBlb2YgZW5kVmFsdWUgPT09ICdib29sZWFuJyxcblx0ICAgICAgICBjdXJ2ZSxcblx0ICAgICAgICBlYXNpbmc7XG5cblx0ICAgIGlmICghaC5pc1R3ZWVuUHJvcChrZXkpICYmICF0aGlzLl9ub25NZXJnZVByb3BzW2tleV0gJiYgIWlzQm9vbGVhbikge1xuXG5cdCAgICAgIHZhciBUV0VFTl9QUk9QUyA9IHt9O1xuXHQgICAgICBpZiAoaC5pc09iamVjdChlbmRWYWx1ZSkgJiYgZW5kVmFsdWUudG8gIT0gbnVsbCkge1xuXHQgICAgICAgIGZvciAodmFyIF9rZXkgaW4gZW5kVmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChUV0VFTl9QUk9QRVJUSUVTW19rZXldIHx8IF9rZXkgPT09ICdjdXJ2ZScpIHtcblx0ICAgICAgICAgICAgVFdFRU5fUFJPUFNbX2tleV0gPSBlbmRWYWx1ZVtfa2V5XTtcblx0ICAgICAgICAgICAgZGVsZXRlIGVuZFZhbHVlW19rZXldO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBjdXJ2ZSAgICA9IGVuZFZhbHVlLmN1cnZlO1xuXHQgICAgICAgIC8vIGVhc2luZyAgID0gZW5kVmFsdWUuZWFzaW5nO1xuXHQgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUudG87XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBpZiBlbmQgdmFsdWUgaXMgZGVsdGEgLSBqdXN0IHNhdmUgaXRcblx0ICAgICAgaWYgKHRoaXMuX2lzRGVsdGEoZW5kVmFsdWUpKSB7XG5cblx0ICAgICAgICB2YXIgX1RXRUVOX1BST1BTID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgX2tleTIgaW4gZW5kVmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChUV0VFTl9QUk9QRVJUSUVTW19rZXkyXSB8fCBfa2V5MiA9PT0gJ2N1cnZlJykge1xuXHQgICAgICAgICAgICBfVFdFRU5fUFJPUFNbX2tleTJdID0gZW5kVmFsdWVbX2tleTJdO1xuXHQgICAgICAgICAgICBkZWxldGUgZW5kVmFsdWVbX2tleTJdO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcGFyc2VEZWx0YVZhbHVlcyhrZXksIGVuZFZhbHVlKTtcblxuXHQgICAgICAgIHJldHVybiAoMCwgX2V4dGVuZHM1LmRlZmF1bHQpKHt9LCByZXN1bHQsIF9UV0VFTl9QUk9QUyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHBhcnNlZEVuZFZhbHVlID0gdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KGtleSwgZW5kVmFsdWUpO1xuXHQgICAgICAgIC8vIGlmIGVuZCB2YWx1ZSBpcyBub3QgZGVsdGEgLSBtZXJnZSB3aXRoIHN0YXJ0IHZhbHVlXG5cdCAgICAgICAgaWYgKHRoaXMuX2lzRGVsdGEoc3RhcnRWYWx1ZSkpIHtcblx0ICAgICAgICAgIHZhciBfZXh0ZW5kczI7XG5cblx0ICAgICAgICAgIC8vIGlmIHN0YXJ0IHZhbHVlIGlzIGRlbHRhIC0gdGFrZSB0aGUgZW5kIHZhbHVlXG5cdCAgICAgICAgICAvLyBhcyBzdGFydCB2YWx1ZSBvZiB0aGUgbmV3IGRlbHRhXG5cdCAgICAgICAgICByZXR1cm4gKDAsIF9leHRlbmRzNS5kZWZhdWx0KSgoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltoLmdldERlbHRhRW5kKHN0YXJ0VmFsdWUpXSA9IHBhcnNlZEVuZFZhbHVlLCBfZXh0ZW5kczIpLCBUV0VFTl9QUk9QUyk7XG5cdCAgICAgICAgICAvLyBpZiBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWUgYXJlIG5vdCDiiIYgLSBtYWtlIOKIhlxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgX2V4dGVuZHMzO1xuXG5cdCAgICAgICAgICByZXR1cm4gKDAsIF9leHRlbmRzNS5kZWZhdWx0KSgoX2V4dGVuZHMzID0ge30sIF9leHRlbmRzM1tzdGFydFZhbHVlXSA9IHBhcnNlZEVuZFZhbHVlLCBfZXh0ZW5kczMpLCBUV0VFTl9QUk9QUyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIGNvcHkgdGhlIHR3ZWVuIHZhbHVlcyB1bmF0dGVuZGVkXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZW5kVmFsdWU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHJldHVybiBIdG1sO1xuXHR9KF90aGVuYWJsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gSHRtbDtcblxuLyoqKi8gfSksXG4vKiAxMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjEpO1xuXG5cdHZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBfYXNzaWduMi5kZWZhdWx0IHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuXHQgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHQgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDEyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXygxMjIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0pLFxuLyogMTIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMjMpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpLk9iamVjdC5hc3NpZ247XG5cbi8qKiovIH0pLFxuLyogMTIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuXHQkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IF9fd2VicGFja19yZXF1aXJlX18oMTI0KX0pO1xuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0Ly8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxuXHR2YXIgZ2V0S2V5cyAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKVxuXHQgICwgZ09QUyAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKVxuXHQgICwgcElFICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKVxuXHQgICwgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KVxuXHQgICwgSU9iamVjdCAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxuXHQgICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG5cdC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuXHRtb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IF9fd2VicGFja19yZXF1aXJlX18oMjMpKGZ1bmN0aW9uKCl7XG5cdCAgdmFyIEEgPSB7fVxuXHQgICAgLCBCID0ge31cblx0ICAgICwgUyA9IFN5bWJvbCgpXG5cdCAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuXHQgIEFbU10gPSA3O1xuXHQgIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcblx0ICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcblx0fSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdCAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuXHQgICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcblx0ICAgICwgaW5kZXggPSAxXG5cdCAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcblx0ICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuXHQgIHdoaWxlKGFMZW4gPiBpbmRleCl7XG5cdCAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG5cdCAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuXHQgICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cdCAgICAgICwgaiAgICAgID0gMFxuXHQgICAgICAsIGtleTtcblx0ICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG5cdCAgfSByZXR1cm4gVDtcblx0fSA6ICRhc3NpZ247XG5cbi8qKiovIH0pLFxuLyogMTI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9leHRlbmRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTIwKTtcblxuXHR2YXIgX2V4dGVuZHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kczIpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG5cdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuXHR2YXIgX3RpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTApO1xuXG5cdHZhciBfdGltZWxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZWxpbmUpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF9kZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMTI2KTtcblxuXHR2YXIgX2RlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbHRhKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXG5cdCAgVGhpcyBtb2R1bGUncyB0YXJnZXQgaXMgdG8gcGFyc2Ugb3B0aW9ucyBvYmplY3QsXG5cdCAgZmluZCBkZWx0YXMgaW4gaXQgYW5kIHNlbmQgdGhlbSB0byBgRGVsdGFgIGNsYXNzZXMuXG5cdCAgVGhlIGBEZWx0YWAgY2xhc3MgaXMgZHVsbCAtIHRoZXkgZXhwZWN0IGFjdHVhbCBwYXJzZWQgZGVsdGFzXG5cdCAgYW5kIHNlcGFyYXRlZCB0d2VlbiBvcHRpb25zLCBzbyB3ZSBzaG91bGQgcGFyc2UgdGhlbSBoZXJlLlxuXHQgIFRoZSB0aW1lbGluZSBvZiB0aGUgbW9kdWxlIGNvbnRyb2xzIHRoZSBgRGVsdGFgIG1vZHVsZXMnIHR3ZWVucy5cblxuXHQgIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3QgdG8gc2V0IGRlbHRhcyByZXN1bHQgdG8gKHBhc3MgdG8gdGhlIERlbHRhIGNsYXNzZXMpLlxuXHQgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB0byBwYXJzZSB0aGUgZGVsdGFzIGZyb20uXG5cdCAgQHBhcmFtIHtGdW5jdGlvbn0gb25VcGRhdGUgb25VcGRhdGUgY2FsbGJhY2suXG5cdCAgQHBhcmFtIG9wdGlvbmFsIHtPYmplY3R9IGFycmF5UHJvcGVydHlNYXAgTGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggdHJ1dGh5XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzIHdoaWNoIGRlc2NyaWJlIHByb3BlcnRpZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHNob3VsZCBiZSBwYXJzZWQgYXMgYXJyYXlzLlxuXHQgIEBwYXJhbSBvcHRpb25hbCB7T2JqZWN0fSBudW1iZXJQcm9wZXJ0eU1hcCBMaXN0IG9mIHByb3BlcnRpZXMgd2l0aCB0cnV0aHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgd2hpY2ggZGVzY3JpYmUgcHJvcGVydGllc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgc2hvdWxkIGJlIHBhcnNlZCBhcyBudW1iZXJzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aG91dCB1bml0cy5cblx0Ki9cblxuXHQvLyBUT0RPOlxuXHQvLyAtIGNvbG9ycyB3aXRoIGN1cnZlcyBjaGFuZ2UgYWxwaGEgbGV2ZWwgdG9vXG5cdC8vIGNvbnN0IGh0bWwgPSBuZXcgbW9qcy5IdG1sKHtcblx0Ly8gICBlbDogJyNqcy1lbCcsXG5cdC8vICAgeDogeyAwOiAxMDAgfSxcblx0Ly8gICBvblVwZGF0ZSAoKSB7XG5cdC8vICAgICBjb25zb2xlLmxvZyh0aGlzLl9wcm9wcy5vcmlnaW5YKTtcblx0Ly8gICB9LFxuXHQvLyAgIG9yaWdpblg6IHsgJ3doaXRlJzogJ2JsYWNrJywgY3VydmU6ICdNMCwxMDAgTDEwMCwgMCcgfSxcblx0Ly8gICBjdXN0b21Qcm9wZXJ0aWVzOiB7XG5cdC8vICAgICBvcmlnaW5YOiB7XG5cdC8vICAgICAgIHR5cGU6ICdjb2xvcicsXG5cdC8vICAgICAgIGRlZmF1bHQ6ICdjeWFuJ1xuXHQvLyAgICAgfSxcblx0Ly8gICAgIGRyYXcoKSB7IGNvbnNvbGUubG9nKCdkcmF3Jyk7IH1cblx0Ly8gICB9XG5cdC8vIH0pO1xuXG5cblx0dmFyIGVhc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1KTtcblx0dmFyIGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXG5cdC8vIGdldCB0d2VlbiBwcm9wZXJ0aWVzXG5cdHZhciBvYmogPSB7fTtcblx0X3R3ZWVuMi5kZWZhdWx0LnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzLmNhbGwob2JqKTtcblx0dmFyIGtleXMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKG9iai5fZGVmYXVsdHMpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICBvYmouX2RlZmF1bHRzW2tleXNbaV1dID0gMTtcblx0fVxuXHRvYmouX2RlZmF1bHRzWyd0aW1lbGluZSddID0gMTtcblx0dmFyIFRXRUVOX1BST1BFUlRJRVMgPSBvYmouX2RlZmF1bHRzO1xuXG5cdHZhciBEZWx0YXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gRGVsdGFzKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgRGVsdGFzKTtcblxuXHQgICAgdGhpcy5fbyA9IG87XG5cblx0ICAgIHRoaXMuX3Nob3J0Q29sb3JzID0ge1xuXHQgICAgICB0cmFuc3BhcmVudDogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgICBub25lOiAncmdiYSgwLDAsMCwwKScsXG5cdCAgICAgIGFxdWE6ICdyZ2IoMCwyNTUsMjU1KScsXG5cdCAgICAgIGJsYWNrOiAncmdiKDAsMCwwKScsXG5cdCAgICAgIGJsdWU6ICdyZ2IoMCwwLDI1NSknLFxuXHQgICAgICBmdWNoc2lhOiAncmdiKDI1NSwwLDI1NSknLFxuXHQgICAgICBncmF5OiAncmdiKDEyOCwxMjgsMTI4KScsXG5cdCAgICAgIGdyZWVuOiAncmdiKDAsMTI4LDApJyxcblx0ICAgICAgbGltZTogJ3JnYigwLDI1NSwwKScsXG5cdCAgICAgIG1hcm9vbjogJ3JnYigxMjgsMCwwKScsXG5cdCAgICAgIG5hdnk6ICdyZ2IoMCwwLDEyOCknLFxuXHQgICAgICBvbGl2ZTogJ3JnYigxMjgsMTI4LDApJyxcblx0ICAgICAgcHVycGxlOiAncmdiKDEyOCwwLDEyOCknLFxuXHQgICAgICByZWQ6ICdyZ2IoMjU1LDAsMCknLFxuXHQgICAgICBzaWx2ZXI6ICdyZ2IoMTkyLDE5MiwxOTIpJyxcblx0ICAgICAgdGVhbDogJ3JnYigwLDEyOCwxMjgpJyxcblx0ICAgICAgd2hpdGU6ICdyZ2IoMjU1LDI1NSwyNTUpJyxcblx0ICAgICAgeWVsbG93OiAncmdiKDI1NSwyNTUsMCknLFxuXHQgICAgICBvcmFuZ2U6ICdyZ2IoMjU1LDEyOCwwKSdcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuX2lnbm9yZURlbHRhc01hcCA9IHsgcHJldkNoYWluTW9kdWxlOiAxLCBtYXN0ZXJNb2R1bGU6IDEgfTtcblxuXHQgICAgdGhpcy5fcGFyc2VEZWx0YXMoby5vcHRpb25zKTtcblx0ICAgIHRoaXMuX2NyZWF0ZURlbHRhcygpO1xuXHQgICAgdGhpcy5fY3JlYXRlVGltZWxpbmUodGhpcy5fbWFpblR3ZWVuT3B0aW9ucyk7XG5cdCAgfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBgcmVmcmVzaGAgb24gYWxsIGNoaWxkIGBkZWx0YWAgb2JqZWN0cy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgYmVmb3JlIHN0YXJ0IHRpbWUgKHRydWUpIG9yIGFmdGVyIGVuZCB0aW1lIChmYWxzZSkuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaChpc0JlZm9yZSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kZWx0YXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fZGVsdGFzW2ldLnJlZnJlc2goaXNCZWZvcmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgYHJlc3RvcmVgIG9uIGFsbCBjaGlsZCBgZGVsdGFgIG9iamVjdHMuXG5cdCAgICBAcHVibGljXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZSgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX2RlbHRhc1tpXS5yZXN0b3JlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIFRpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaW1lbGluZSBvcHRpb25zLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX2NyZWF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gX2NyZWF0ZVRpbWVsaW5lKCkge1xuXHQgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cdCAgICAvLyBjb25zdCBvID0gdGhpcy5fbztcblx0ICAgIC8vIG9wdHMudGltZWxpbmUgPSBvcHRzLnRpbWVsaW5lIHx8IHt9O1xuXHQgICAgLy8gb3B0cy50aW1lbGluZS5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgIC8vICAgb25VcGRhdGU6ICAgby5vblVwZGF0ZSxcblx0ICAgIC8vICAgb25SZWZyZXNoOiAgby5vblVwZGF0ZVxuXHQgICAgLy8gfVxuXHQgICAgLy8gc2VuZCBjYWxsYmFja3NDb250ZXh0IHRvIHRpbWVsaW5lIGlmIHNldFxuXHQgICAgLy8gby5jYWxsYmFja3NDb250ZXh0ICYmIChvcHRzLnRpbWVsaW5lLmNhbGxiYWNrc0NvbnRleHQgPSBvLmNhbGxiYWNrc0NvbnRleHQpO1xuXHQgICAgLy8gb3B0cy50aW1lbGluZVxuXHQgICAgdGhpcy50aW1lbGluZSA9IG5ldyBfdGltZWxpbmUyLmRlZmF1bHQoKTtcblx0ICAgIHRoaXMudGltZWxpbmUuYWRkKHRoaXMuX2RlbHRhcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBEZWx0YXMgZnJvbSBwYXJzZWQgb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fY3JlYXRlRGVsdGFzID0gZnVuY3Rpb24gX2NyZWF0ZURlbHRhcygpIHtcblx0ICAgIHRoaXMuX2RlbHRhcyA9IFtdO1xuXG5cdCAgICAvLyBjcmVhdGUgbWFpbiBkZWx0YSBvYmplY3Rcblx0ICAgIHRoaXMuX2RlbHRhcy5wdXNoKHRoaXMuX2NyZWF0ZURlbHRhKHRoaXMuX21haW5EZWx0YXMsIHRoaXMuX21haW5Ud2Vlbk9wdGlvbnMpKTtcblxuXHQgICAgLy8gY3JlYXRlIGNoaWxkIGRlbHRhIG9iamVjdFxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZERlbHRhcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgZGVsdGEgPSB0aGlzLl9jaGlsZERlbHRhc1tpXTtcblx0ICAgICAgdGhpcy5fZGVsdGFzLnB1c2godGhpcy5fY3JlYXRlRGVsdGEoW2RlbHRhLmRlbHRhXSwgZGVsdGEudHdlZW5PcHRpb25zKSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBEZWx0YSBvYmplY3Qgd2l0aCBwYXNzZWQgb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FycmF5fSBBcnJheSBvZiBkZWx0YXMuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVHdlZW4gcHJvcGVydGllcy5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IERlbHRhIG9iamVjdFxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX2NyZWF0ZURlbHRhID0gZnVuY3Rpb24gX2NyZWF0ZURlbHRhKGRlbHRhcywgdHdlZW5PcHRpb25zKSB7XG5cdCAgICB2YXIgbyA9IHRoaXMuX287XG5cdCAgICByZXR1cm4gbmV3IF9kZWx0YTIuZGVmYXVsdCh7XG5cdCAgICAgIGRlbHRhczogZGVsdGFzLCB0d2Vlbk9wdGlvbnM6IHR3ZWVuT3B0aW9ucyxcblx0ICAgICAgcHJvcHM6IG8ucHJvcHMsXG5cdCAgICAgIGlzQ2hhaW5lZDogby5pc0NoYWluZWQsXG5cdCAgICAgIGNhbGxiYWNrc0NvbnRleHQ6IG8uY2FsbGJhY2tzQ29udGV4dFxuXHQgICAgfSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGRlbHRhIG9iamVjdHMgZnJvbSBvcHRpb25zLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9iamVjdCB0byBwYXJzZSB0aGUgZGVsdGFzIGZyb20uXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VEZWx0YXMgPSBmdW5jdGlvbiBfcGFyc2VEZWx0YXMob2JqKSB7XG5cdCAgICAvLyBzcGlsdCBtYWluIGFuaW1hdGlvbiBwcm9wZXJ0aWVzIGFuZCBtYWluIHR3ZWVuIHByb3BlcnRpZXNcblx0ICAgIHZhciBtYWluU3BsaXQgPSB0aGlzLl9zcGxpdFR3ZWVuT3B0aW9ucyhvYmopO1xuXHQgICAgLy8gbWFpbiBhbmltYXRpb24gcHJvcGVydGllc1xuXHQgICAgdmFyIG9wdHMgPSBtYWluU3BsaXQuZGVsdGE7XG5cdCAgICAvLyBtYWluIHR3ZWVuIHByb3BlcnRpZXNcblx0ICAgIHRoaXMuX21haW5Ud2Vlbk9wdGlvbnMgPSBtYWluU3BsaXQudHdlZW5PcHRpb25zO1xuXG5cdCAgICB0aGlzLl9tYWluRGVsdGFzID0gW107XG5cdCAgICB0aGlzLl9jaGlsZERlbHRhcyA9IFtdO1xuXHQgICAgdmFyIGtleXMgPSAoMCwgX2tleXMyLmRlZmF1bHQpKG9wdHMpO1xuXHQgICAgLy8gbG9vcCB0aHJ1IGFsbCBwcm9wZXJ0aWVzIHdpdGhvdXQgdHdlZW4gb25lc1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXHQgICAgICAvLyBpcyBwcm9wZXJ0eSBpcyBkZWx0YSAtIHBhcnNlIGl0XG5cdCAgICAgIGlmICh0aGlzLl9pc0RlbHRhKG9wdHNba2V5XSkgJiYgIXRoaXMuX2lnbm9yZURlbHRhc01hcFtrZXldKSB7XG5cdCAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5fc3BsaXRBbmRQYXJzZURlbHRhKGtleSwgb3B0c1trZXldKTtcblx0ICAgICAgICAvLyBpZiBwYXJzZWQgb2JqZWN0IGhhcyBubyB0d2VlbiB2YWx1ZXMgLSBpdCdzIGRlbHRhIG9mIHRoZSBtYWluIG9iamVjdFxuXHQgICAgICAgIGlmICghZGVsdGEudHdlZW5PcHRpb25zKSB7XG5cdCAgICAgICAgICB0aGlzLl9tYWluRGVsdGFzLnB1c2goZGVsdGEuZGVsdGEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBvdGhlcndpc2UgaXQgaXMgZGlzdGluY3QgZGVsdGEgb2JqZWN0XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2NoaWxkRGVsdGFzLnB1c2goZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNwbGl0IHR3ZWVuIHZhbHVlcyBhbmQgcGFyc2Ugc2luZ2xlIGRlbHRhIHJlY29yZC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBSYXcgZGVsdGEgb2JqZWN0LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU3BsaXQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IHR3ZWVuT3B0aW9ucyBUd2VlbiBwcm9wZXJ0aWVzLlxuXHQgICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGRlbHRhIFBhcnNlZCBkZWx0YS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9zcGxpdEFuZFBhcnNlRGVsdGEgPSBmdW5jdGlvbiBfc3BsaXRBbmRQYXJzZURlbHRhKG5hbWUsIG9iamVjdCkge1xuXHQgICAgdmFyIHNwbGl0ID0gdGhpcy5fc3BsaXRUd2Vlbk9wdGlvbnMob2JqZWN0KTtcblx0ICAgIC8vIHBhcnNlIGRlbHRhIGluIHRoZSBvYmplY3Rcblx0ICAgIHNwbGl0LmRlbHRhID0gdGhpcy5fcGFyc2VEZWx0YShuYW1lLCBzcGxpdC5kZWx0YSk7XG5cdCAgICByZXR1cm4gc3BsaXQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGRlbHRhIGJ5IGRlbGVnYXRpbmcgdGhlIHZhcmlhYmxlcyB0byBfcGFyc2UqRGVsdGEgbWV0aG9kcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBSYXcgZGVsdGEgb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE1vZHVsZSBpbmRleC5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZURlbHRhID0gZnVuY3Rpb24gX3BhcnNlRGVsdGEobmFtZSwgb2JqZWN0LCBpbmRleCkge1xuXHQgICAgLy8gaWYgbmFtZSBpcyBpbiBfby5jdXN0b21Qcm9wcyAtIHBhcnNlIGl0IHJlZ2FyZGluZyB0aGUgdHlwZVxuXHQgICAgcmV0dXJuIHRoaXMuX28uY3VzdG9tUHJvcHMgJiYgdGhpcy5fby5jdXN0b21Qcm9wc1tuYW1lXSAhPSBudWxsID8gdGhpcy5fcGFyc2VEZWx0YUJ5Q3VzdG9tKG5hbWUsIG9iamVjdCwgaW5kZXgpIDogdGhpcy5fcGFyc2VEZWx0YUJ5R3Vlc3MobmFtZSwgb2JqZWN0LCBpbmRleCk7XG5cdCAgfTtcblx0ICAvKipcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBkZWx0YSBieSB0YWtpbmcgdGhlIHR5cGUgZnJvbSB0aGUgY3VzdG9tUHJvcHMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFJhdyBkZWx0YSBvYmplY3QuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gTW9kdWxlIGluZGV4LlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3BhcnNlRGVsdGFCeUN1c3RvbSA9IGZ1bmN0aW9uIF9wYXJzZURlbHRhQnlDdXN0b20obmFtZSwgb2JqZWN0LCBpbmRleCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3BhcnNlTnVtYmVyRGVsdGEobmFtZSwgb2JqZWN0LCBpbmRleCk7XG5cdCAgICAvLyBjb25zdCBjdXN0b21SZWNvcmQgPSB0aGlzLl9vLmN1c3RvbVByb3BzW25hbWVdO1xuXHQgICAgLy8gc3dpdGNoICggY3VzdG9tUmVjb3JkLnR5cGUudG9Mb3dlckNhc2UoKSApIHtcblx0ICAgIC8vICAgY2FzZSAnY29sb3InOiAgeyByZXR1cm4gdGhpcy5fcGFyc2VDb2xvckRlbHRhKCBuYW1lLCBvYmplY3QgKTsgfVxuXHQgICAgLy8gICBjYXNlICdhcnJheSc6ICB7IHJldHVybiB0aGlzLl9wYXJzZUFycmF5RGVsdGEoIG5hbWUsIG9iamVjdCApOyB9XG5cdCAgICAvLyAgIGNhc2UgJ251bWJlcic6IHsgcmV0dXJuIHRoaXMuX3BhcnNlTnVtYmVyRGVsdGEoIG5hbWUsIG9iamVjdCwgaW5kZXggKTsgfVxuXHQgICAgLy8gICBjYXNlICd1bml0JzogICB7IHJldHVybiB0aGlzLl9wYXJzZVVuaXREZWx0YSggbmFtZSwgb2JqZWN0LCBpbmRleCApOyB9XG5cdCAgICAvLyB9XG5cdCAgfTtcblx0ICAvKipcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBkZWx0YSBieSByZWFzb25pbmcgYWJvdXQgaXQncyB2YWx1ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBSYXcgZGVsdGEgb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE1vZHVsZSBpbmRleC5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZURlbHRhQnlHdWVzcyA9IGZ1bmN0aW9uIF9wYXJzZURlbHRhQnlHdWVzcyhuYW1lLCBvYmplY3QsIGluZGV4KSB7XG5cdCAgICB2YXIgX3ByZXBhcnNlRGVsdGEyID0gdGhpcy5fcHJlcGFyc2VEZWx0YShvYmplY3QpLFxuXHQgICAgICAgIHN0YXJ0ID0gX3ByZXBhcnNlRGVsdGEyLnN0YXJ0O1xuXG5cdCAgICB2YXIgbyA9IHRoaXMuX287XG5cblx0ICAgIC8vIGNvbG9yIHZhbHVlc1xuXHQgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc3RhcnQpKSAmJiAhc3RhcnQubWF0Y2goL3JhbmRcXCgvKSAmJiAhc3RhcnQubWF0Y2goL3N0YWdnZXJcXCgvKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcGFyc2VDb2xvckRlbHRhKG5hbWUsIG9iamVjdCk7XG5cdCAgICAgIC8vIGFycmF5IHZhbHVlc1xuXHQgICAgfSBlbHNlIGlmIChvLmFycmF5UHJvcGVydHlNYXAgJiYgby5hcnJheVByb3BlcnR5TWFwW25hbWVdKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9wYXJzZUFycmF5RGVsdGEobmFtZSwgb2JqZWN0KTtcblx0ICAgICAgLy8gdW5pdCBvciBudW1iZXIgdmFsdWVzXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gby5udW1iZXJQcm9wZXJ0eU1hcCAmJiBvLm51bWJlclByb3BlcnR5TWFwW25hbWVdID9cblx0ICAgICAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIGluIHRoZSBudW1iZXIgcHJvcGVydHkgbWFwIC0gcGFyc2UgaXQgbGlrZSBudW1iZXJcblx0ICAgICAgdGhpcy5fcGFyc2VOdW1iZXJEZWx0YShuYW1lLCBvYmplY3QsIGluZGV4KVxuXHQgICAgICAvLyBvdGhlcndpc2UgLSBsaWtlIG51bWJlciB3aXRoIHVuaXRzXG5cdCAgICAgIDogdGhpcy5fcGFyc2VVbml0RGVsdGEobmFtZSwgb2JqZWN0LCBpbmRleCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNlcGFyYXRlIHR3ZWVuIG9wdGlvbnMgZnJvbSBkZWx0YSBwcm9wZXJ0aWVzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCBmb3Igc2VwYXJhdGlvbi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB0aGF0IGNvbnRhaW5zIDIgb2JqZWN0c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAtIG9uZSBkZWx0YSBvcHRpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC0gb25lIHR3ZWVuIG9wdGlvbnMgKCBjb3VsZCBiZSBlbXB0eSBpZiBubyB0d2VlbiBvcHRzIClcblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9zcGxpdFR3ZWVuT3B0aW9ucyA9IGZ1bmN0aW9uIF9zcGxpdFR3ZWVuT3B0aW9ucyhkZWx0YSkge1xuXHQgICAgZGVsdGEgPSAoMCwgX2V4dGVuZHMzLmRlZmF1bHQpKHt9LCBkZWx0YSk7XG5cblx0ICAgIHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShkZWx0YSksXG5cdCAgICAgICAgdHdlZW5PcHRpb25zID0ge307XG5cdCAgICB2YXIgaXNUd2VlbiA9IG51bGw7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgaWYgKFRXRUVOX1BST1BFUlRJRVNba2V5XSkge1xuXHQgICAgICAgIGlmIChkZWx0YVtrZXldICE9IG51bGwpIHtcblx0ICAgICAgICAgIHR3ZWVuT3B0aW9uc1trZXldID0gZGVsdGFba2V5XTtcblx0ICAgICAgICAgIGlzVHdlZW4gPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkZWxldGUgZGVsdGFba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZGVsdGE6IGRlbHRhLFxuXHQgICAgICB0d2Vlbk9wdGlvbnM6IGlzVHdlZW4gPyB0d2Vlbk9wdGlvbnMgOiB1bmRlZmluZWRcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWx0YSBwcm9wZXJ0eS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUGFyYW1ldGVyIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59XG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5faXNEZWx0YSA9IGZ1bmN0aW9uIF9pc0RlbHRhKG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGlzT2JqZWN0ID0gaC5pc09iamVjdChvcHRpb25zVmFsdWUpO1xuXHQgICAgaXNPYmplY3QgPSBpc09iamVjdCAmJiAhb3B0aW9uc1ZhbHVlLnVuaXQ7XG5cdCAgICByZXR1cm4gISghaXNPYmplY3QgfHwgaC5pc0FycmF5KG9wdGlvbnNWYWx1ZSkgfHwgaC5pc0RPTShvcHRpb25zVmFsdWUpKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgY29sb3IgZGVsdGEgdmFsdWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBkZWx0YS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZUNvbG9yRGVsdGEgPSBmdW5jdGlvbiBfcGFyc2VDb2xvckRlbHRhKGtleSwgdmFsdWUpIHtcblx0ICAgIGlmIChrZXkgPT09ICdzdHJva2VMaW5lY2FwJykge1xuXHQgICAgICBoLndhcm4oJ1NvcnJ5LCBzdHJva2UtbGluZWNhcCBwcm9wZXJ0eSBpcyBub3QgYW5pbWF0YWJsZSB5ZXQsIHVzaW5nIHRoZSBzdGFydCgje3N0YXJ0fSkgdmFsdWUgaW5zdGVhZCcsIHZhbHVlKTtcblx0ICAgICAgcmV0dXJuIHt9O1xuXHQgICAgfVxuXHQgICAgdmFyIHByZVBhcnNlID0gdGhpcy5fcHJlcGFyc2VEZWx0YSh2YWx1ZSk7XG5cblx0ICAgIHZhciBzdGFydENvbG9yT2JqID0gdGhpcy5fbWFrZUNvbG9yT2JqKHByZVBhcnNlLnN0YXJ0KSxcblx0ICAgICAgICBlbmRDb2xvck9iaiA9IHRoaXMuX21ha2VDb2xvck9iaihwcmVQYXJzZS5lbmQpO1xuXG5cdCAgICB2YXIgZGVsdGEgPSB7XG5cdCAgICAgIHR5cGU6ICdjb2xvcicsXG5cdCAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgc3RhcnQ6IHN0YXJ0Q29sb3JPYmosXG5cdCAgICAgIGVuZDogZW5kQ29sb3JPYmosXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZSxcblx0ICAgICAgZGVsdGE6IHtcblx0ICAgICAgICByOiBlbmRDb2xvck9iai5yIC0gc3RhcnRDb2xvck9iai5yLFxuXHQgICAgICAgIGc6IGVuZENvbG9yT2JqLmcgLSBzdGFydENvbG9yT2JqLmcsXG5cdCAgICAgICAgYjogZW5kQ29sb3JPYmouYiAtIHN0YXJ0Q29sb3JPYmouYixcblx0ICAgICAgICBhOiBlbmRDb2xvck9iai5hIC0gc3RhcnRDb2xvck9iai5hXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGFycmF5IGRlbHRhIHZhbHVlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQYXJzZWQgZGVsdGEuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VBcnJheURlbHRhID0gZnVuY3Rpb24gX3BhcnNlQXJyYXlEZWx0YShrZXksIHZhbHVlKSB7XG5cdCAgICB2YXIgcHJlUGFyc2UgPSB0aGlzLl9wcmVwYXJzZURlbHRhKHZhbHVlKTtcblxuXHQgICAgdmFyIHN0YXJ0QXJyID0gdGhpcy5fc3RyVG9BcnIocHJlUGFyc2Uuc3RhcnQpLFxuXHQgICAgICAgIGVuZEFyciA9IHRoaXMuX3N0clRvQXJyKHByZVBhcnNlLmVuZCk7XG5cblx0ICAgIGgubm9ybURhc2hBcnJheXMoc3RhcnRBcnIsIGVuZEFycik7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnRBcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGVuZCA9IGVuZEFycltpXTtcblx0ICAgICAgaC5tZXJnZVVuaXRzKHN0YXJ0QXJyW2ldLCBlbmQsIGtleSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkZWx0YSA9IHtcblx0ICAgICAgdHlwZTogJ2FycmF5Jyxcblx0ICAgICAgbmFtZToga2V5LFxuXHQgICAgICBzdGFydDogc3RhcnRBcnIsXG5cdCAgICAgIGVuZDogZW5kQXJyLFxuXHQgICAgICBkZWx0YTogaC5jYWxjQXJyRGVsdGEoc3RhcnRBcnIsIGVuZEFyciksXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZVxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBudW1lcmljIGRlbHRhIHZhbHVlcyB3aXRoIHVuaXRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgbW9kdWxlLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUGFyc2VkIGRlbHRhLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3BhcnNlVW5pdERlbHRhID0gZnVuY3Rpb24gX3BhcnNlVW5pdERlbHRhKGtleSwgdmFsdWUsIGluZGV4KSB7XG5cdCAgICB2YXIgcHJlUGFyc2UgPSB0aGlzLl9wcmVwYXJzZURlbHRhKHZhbHVlKTtcblxuXHQgICAgdmFyIGVuZCA9IGgucGFyc2VVbml0KGgucGFyc2VTdHJpbmdPcHRpb24ocHJlUGFyc2UuZW5kLCBpbmRleCkpLFxuXHQgICAgICAgIHN0YXJ0ID0gaC5wYXJzZVVuaXQoaC5wYXJzZVN0cmluZ09wdGlvbihwcmVQYXJzZS5zdGFydCwgaW5kZXgpKTtcblxuXHQgICAgaC5tZXJnZVVuaXRzKHN0YXJ0LCBlbmQsIGtleSk7XG5cdCAgICB2YXIgZGVsdGEgPSB7XG5cdCAgICAgIHR5cGU6ICd1bml0Jyxcblx0ICAgICAgbmFtZToga2V5LFxuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogZW5kLFxuXHQgICAgICBkZWx0YTogZW5kLnZhbHVlIC0gc3RhcnQudmFsdWUsXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgbnVtZXJpYyBkZWx0YSB2YWx1ZXMgd2l0aG91dCB1bml0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1vZHVsZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBkZWx0YS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZU51bWJlckRlbHRhID0gZnVuY3Rpb24gX3BhcnNlTnVtYmVyRGVsdGEoa2V5LCB2YWx1ZSwgaW5kZXgpIHtcblx0ICAgIHZhciBwcmVQYXJzZSA9IHRoaXMuX3ByZXBhcnNlRGVsdGEodmFsdWUpO1xuXG5cdCAgICB2YXIgZW5kID0gcGFyc2VGbG9hdChoLnBhcnNlU3RyaW5nT3B0aW9uKHByZVBhcnNlLmVuZCwgaW5kZXgpKSxcblx0ICAgICAgICBzdGFydCA9IHBhcnNlRmxvYXQoaC5wYXJzZVN0cmluZ09wdGlvbihwcmVQYXJzZS5zdGFydCwgaW5kZXgpKTtcblxuXHQgICAgdmFyIGRlbHRhID0ge1xuXHQgICAgICB0eXBlOiAnbnVtYmVyJyxcblx0ICAgICAgbmFtZToga2V5LFxuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogZW5kLFxuXHQgICAgICBkZWx0YTogZW5kIC0gc3RhcnQsXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZVxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBleHRyYWN0IGBjdXJ2ZWAgYW5kIGBzdGFydGAvYGVuZGAgdmFsdWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBEZWx0YSBvYmplY3QuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQcmVwYXJzZWQgZGVsdGEuXG5cdCAgICAgICAgICAgICAgQHByb3BlcnR5IHtTdHJpbmd9IFN0YXJ0IHZhbHVlLlxuXHQgICAgICAgICAgICAgIEBwcm9wZXJ0eSB7U3RyaW5nLCBOdW1iZXJ9IEVuZCB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wcmVwYXJzZURlbHRhID0gZnVuY3Rpb24gX3ByZXBhcnNlRGVsdGEodmFsdWUpIHtcblx0ICAgIC8vIGNsb25lIHZhbHVlIG9iamVjdFxuXHQgICAgdmFsdWUgPSAoMCwgX2V4dGVuZHMzLmRlZmF1bHQpKHt9LCB2YWx1ZSk7XG5cdCAgICAvLyBwYXJzZSBjdXJ2ZSBpZiBleGlzdFxuXHQgICAgdmFyIGN1cnZlID0gdmFsdWUuY3VydmU7XG5cdCAgICBpZiAoY3VydmUgIT0gbnVsbCkge1xuXHQgICAgICBjdXJ2ZSA9IGVhc2luZy5wYXJzZUVhc2luZyhjdXJ2ZSk7XG5cdCAgICAgIGN1cnZlLl9wYXJlbnQgPSB0aGlzO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHZhbHVlLmN1cnZlO1xuXHQgICAgLy8gcGFyc2Ugc3RhcnQgYW5kIGVuZCB2YWx1ZXNcblx0ICAgIHZhciBzdGFydCA9ICgwLCBfa2V5czIuZGVmYXVsdCkodmFsdWUpWzBdLFxuXHQgICAgICAgIGVuZCA9IHZhbHVlW3N0YXJ0XTtcblxuXHQgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY3VydmU6IGN1cnZlIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGNvbG9yIGludG8gdXNhYmxlIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gQ29sb3Igc3RyaW5nLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUGFyc2VkIGNvbG9yIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX21ha2VDb2xvck9iaiA9IGZ1bmN0aW9uIF9tYWtlQ29sb3JPYmooY29sb3IpIHtcblx0ICAgIC8vIEhFWFxuXHQgICAgdmFyIGNvbG9yT2JqID0ge307XG5cdCAgICBpZiAoY29sb3JbMF0gPT09ICcjJykge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsxLDJ9KShbYS1mXFxkXXsxLDJ9KShbYS1mXFxkXXsxLDJ9KSQvaS5leGVjKGNvbG9yKTtcblx0ICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgIHZhciByID0gcmVzdWx0WzFdLmxlbmd0aCA9PT0gMiA/IHJlc3VsdFsxXSA6IHJlc3VsdFsxXSArIHJlc3VsdFsxXSxcblx0ICAgICAgICAgICAgZyA9IHJlc3VsdFsyXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMl0gOiByZXN1bHRbMl0gKyByZXN1bHRbMl0sXG5cdCAgICAgICAgICAgIGIgPSByZXN1bHRbM10ubGVuZ3RoID09PSAyID8gcmVzdWx0WzNdIDogcmVzdWx0WzNdICsgcmVzdWx0WzNdO1xuXG5cdCAgICAgICAgY29sb3JPYmogPSB7XG5cdCAgICAgICAgICByOiBwYXJzZUludChyLCAxNiksIGc6IHBhcnNlSW50KGcsIDE2KSwgYjogcGFyc2VJbnQoYiwgMTYpLCBhOiAxXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBub3QgSEVYXG5cdCAgICAvLyBzaG9ydGhhbmQgY29sb3IgYW5kIHJnYigpXG5cdCAgICBpZiAoY29sb3JbMF0gIT09ICcjJykge1xuXHQgICAgICB2YXIgaXNSZ2IgPSBjb2xvclswXSA9PT0gJ3InICYmIGNvbG9yWzFdID09PSAnZycgJiYgY29sb3JbMl0gPT09ICdiJztcblx0ICAgICAgdmFyIHJnYkNvbG9yID0gdm9pZCAwO1xuXHQgICAgICAvLyByZ2IgY29sb3Jcblx0ICAgICAgaWYgKGlzUmdiKSB7XG5cdCAgICAgICAgcmdiQ29sb3IgPSBjb2xvcjtcblx0ICAgICAgfTtcblx0ICAgICAgLy8gc2hvcnRoYW5kIGNvbG9yIG5hbWVcblx0ICAgICAgaWYgKCFpc1JnYikge1xuXHQgICAgICAgIGlmICghdGhpcy5fc2hvcnRDb2xvcnNbY29sb3JdKSB7XG5cdCAgICAgICAgICBoLmRpdi5zdHlsZS5jb2xvciA9IGNvbG9yO1xuXHQgICAgICAgICAgcmdiQ29sb3IgPSBoLmNvbXB1dGVkU3R5bGUoaC5kaXYpLmNvbG9yO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZ2JDb2xvciA9IHRoaXMuX3Nob3J0Q29sb3JzW2NvbG9yXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcmVnZXhTdHJpbmcxID0gJ15yZ2JhP1xcXFwoKFxcXFxkezEsM30pLFxcXFxzPyhcXFxcZHsxLDN9KSwnLFxuXHQgICAgICAgICAgcmVnZXhTdHJpbmcyID0gJ1xcXFxzPyhcXFxcZHsxLDN9KSw/XFxcXHM/KFxcXFxkezF9fDA/XFxcXC5cXFxcZHsxLH0pP1xcXFwpJCcsXG5cdCAgICAgICAgICBfcmVzdWx0ID0gbmV3IFJlZ0V4cChyZWdleFN0cmluZzEgKyByZWdleFN0cmluZzIsICdnaScpLmV4ZWMocmdiQ29sb3IpLFxuXHQgICAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KF9yZXN1bHRbNF0gfHwgMSk7XG5cblx0ICAgICAgaWYgKF9yZXN1bHQpIHtcblx0ICAgICAgICBjb2xvck9iaiA9IHtcblx0ICAgICAgICAgIHI6IHBhcnNlSW50KF9yZXN1bHRbMV0sIDEwKSxcblx0ICAgICAgICAgIGc6IHBhcnNlSW50KF9yZXN1bHRbMl0sIDEwKSxcblx0ICAgICAgICAgIGI6IHBhcnNlSW50KF9yZXN1bHRbM10sIDEwKSxcblx0ICAgICAgICAgIGE6IGFscGhhICE9IG51bGwgJiYgIWlzTmFOKGFscGhhKSA/IGFscGhhIDogMVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNvbG9yT2JqO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBzdHJpbmcgaW50byBhcnJheS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZywgTnVtYmVyfSBTdHJpbmcgb3IgbnVtYmVyIHRvIHBhcnNlLlxuXHQgICAgQHJldHVybnMge0FycmF5fSBQYXJzZWQgYXJyYXkuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fc3RyVG9BcnIgPSBmdW5jdGlvbiBfc3RyVG9BcnIoc3RyaW5nKSB7XG5cdCAgICB2YXIgYXJyID0gW107XG5cdCAgICAvLyBwbGFpbiBudW1iZXJcblx0ICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3RyaW5nKSkge1xuXHQgICAgICBhcnIucHVzaChoLnBhcnNlVW5pdChzdHJpbmcpKTtcblx0ICAgICAgcmV0dXJuIGFycjtcblx0ICAgIH1cblx0ICAgIC8vIHN0cmluZyBhcnJheVxuXHQgICAgc3RyaW5nLnRyaW0oKS5zcGxpdCgvXFxzKy9naW0pLmZvckVhY2goZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICBhcnIucHVzaChoLnBhcnNlVW5pdChoLnBhcnNlSWZSYW5kKHN0cikpKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGFycjtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIERlbHRhcztcblx0fSgpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IERlbHRhcztcblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKTtcblxuXHR2YXIgRGVsdGEgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gRGVsdGEoKSB7XG5cdCAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBEZWx0YSk7XG5cblx0ICAgIHRoaXMuX28gPSBvO1xuXHQgICAgdGhpcy5fY3JlYXRlVHdlZW4oby50d2Vlbk9wdGlvbnMpO1xuXHQgICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzIHJlbmRlclxuXHQgICAgIXRoaXMuX28uaXNDaGFpbmVkICYmIHRoaXMucmVmcmVzaCh0cnVlKTtcblx0ICB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIGBfcmVmcmVzaGAgbWV0aG9kIG9uIGB0d2VlbmAuXG5cdCAgICBVc2Ugc3dpdGNoIGJldHdlZW4gYDBgIGFuZCBgMWAgcHJvZ3Jlc3MgZm9yIGRlbHRhIHZhbHVlLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJZiByZWZyZXNoIGJlZm9yZSBzdGFydCB0aW1lIG9yIGFmdGVyLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goaXNCZWZvcmUpIHtcblx0ICAgIHRoaXMuX3ByZXZpb3VzVmFsdWVzID0gW107XG5cblx0ICAgIHZhciBkZWx0YXMgPSB0aGlzLl9vLmRlbHRhcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBuYW1lID0gZGVsdGFzW2ldLm5hbWU7XG5cdCAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWVzLnB1c2goe1xuXHQgICAgICAgIG5hbWU6IG5hbWUsIHZhbHVlOiB0aGlzLl9vLnByb3BzW25hbWVdXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnR3ZWVuLl9yZWZyZXNoKGlzQmVmb3JlKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXN0b3JlIGFsbCBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYF9wcmV2aW91c1ZhbHVlc2AgYXJyYXkuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZSgpIHtcblx0ICAgIHZhciBwcmV2ID0gdGhpcy5fcHJldmlvdXNWYWx1ZXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHJlY29yZCA9IHByZXZbaV07XG5cdCAgICAgIHRoaXMuX28ucHJvcHNbcmVjb3JkLm5hbWVdID0gcmVjb3JkLnZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0d2VlbiBvZiB0aGUgZGVsdGEuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY3JlYXRlVHdlZW4gPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW4oKSB7XG5cdCAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cblx0ICAgIHZhciBpdCA9IHRoaXM7XG5cdCAgICBvLmNhbGxiYWNrT3ZlcnJpZGVzID0ge1xuXHQgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZXAsIHApIHtcblx0ICAgICAgICBpdC5fY2FsY0N1cnJlbnRQcm9wcyhlcCwgcCk7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8vIGlmIG5vdCBjaGFpbmVkIC0gYWRkIHRoZSBvblJlZnJlc2ggY2FsbGJhY2tcblx0ICAgIC8vIHRvIHJlZnJlc2ggdGhlIHR3ZWVuIHdoZW4gbmVlZGVkXG5cdCAgICBpZiAoIXRoaXMuX28uaXNDaGFpbmVkKSB7XG5cdCAgICAgIG8uY2FsbGJhY2tPdmVycmlkZXMub25SZWZyZXNoID0gZnVuY3Rpb24gKGlzQmVmb3JlLCBlcCwgcCkge1xuXHQgICAgICAgIGl0Ll9jYWxjQ3VycmVudFByb3BzKGVwLCBwKTtcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgby5jYWxsYmFja3NDb250ZXh0ID0gdGhpcy5fby5jYWxsYmFja3NDb250ZXh0O1xuXHQgICAgdGhpcy50d2VlbiA9IG5ldyBfdHdlZW4yLmRlZmF1bHQobyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBkZWx0YXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEVhc2VkIHByb2dyZXNzIHRvIGNhbGN1bGF0ZSAtIFswLi4xXS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQcm9ncmVzcyB0byBjYWxjdWxhdGUgLSBbMC4uMV0uXG5cdCAgKi9cblxuXG5cdCAgRGVsdGEucHJvdG90eXBlLl9jYWxjQ3VycmVudFByb3BzID0gZnVuY3Rpb24gX2NhbGNDdXJyZW50UHJvcHMoZWFzZWRQcm9ncmVzcywgcCkge1xuXHQgICAgdmFyIGRlbHRhcyA9IHRoaXMuX28uZGVsdGFzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHR5cGUgPSBkZWx0YXNbaV0udHlwZTtcblx0ICAgICAgdGhpc1snX2NhbGNDdXJyZW50XycgKyB0eXBlXShkZWx0YXNbaV0sIGVhc2VkUHJvZ3Jlc3MsIHApO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjIHRoZSBjdXJyZW50IGNvbG9yIGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X2NvbG9yID0gZnVuY3Rpb24gX2NhbGNDdXJyZW50X2NvbG9yKGRlbHRhLCBlcCwgcCkge1xuXHQgICAgdmFyIHIsXG5cdCAgICAgICAgZyxcblx0ICAgICAgICBiLFxuXHQgICAgICAgIGEsXG5cdCAgICAgICAgc3RhcnQgPSBkZWx0YS5zdGFydCxcblx0ICAgICAgICBkID0gZGVsdGEuZGVsdGE7XG5cdCAgICBpZiAoIWRlbHRhLmN1cnZlKSB7XG5cdCAgICAgIHIgPSBwYXJzZUludChzdGFydC5yICsgZXAgKiBkLnIsIDEwKTtcblx0ICAgICAgZyA9IHBhcnNlSW50KHN0YXJ0LmcgKyBlcCAqIGQuZywgMTApO1xuXHQgICAgICBiID0gcGFyc2VJbnQoc3RhcnQuYiArIGVwICogZC5iLCAxMCk7XG5cdCAgICAgIGEgPSBwYXJzZUZsb2F0KHN0YXJ0LmEgKyBlcCAqIGQuYSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgY3AgPSBkZWx0YS5jdXJ2ZShwKTtcblx0ICAgICAgciA9IHBhcnNlSW50KGNwICogKHN0YXJ0LnIgKyBwICogZC5yKSwgMTApO1xuXHQgICAgICBnID0gcGFyc2VJbnQoY3AgKiAoc3RhcnQuZyArIHAgKiBkLmcpLCAxMCk7XG5cdCAgICAgIGIgPSBwYXJzZUludChjcCAqIChzdGFydC5iICsgcCAqIGQuYiksIDEwKTtcblx0ICAgICAgYSA9IHBhcnNlRmxvYXQoY3AgKiAoc3RhcnQuYSArIHAgKiBkLmEpKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX28ucHJvcHNbZGVsdGEubmFtZV0gPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsYyB0aGUgY3VycmVudCBudW1iZXIgZGVsdGEgdmFsdWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRGVsdGFcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUGxhaW4gcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY2FsY0N1cnJlbnRfbnVtYmVyID0gZnVuY3Rpb24gX2NhbGNDdXJyZW50X251bWJlcihkZWx0YSwgZXAsIHApIHtcblx0ICAgIHRoaXMuX28ucHJvcHNbZGVsdGEubmFtZV0gPSAhZGVsdGEuY3VydmUgPyBkZWx0YS5zdGFydCArIGVwICogZGVsdGEuZGVsdGEgOiBkZWx0YS5jdXJ2ZShwKSAqIChkZWx0YS5zdGFydCArIHAgKiBkZWx0YS5kZWx0YSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGMgdGhlIGN1cnJlbnQgbnVtYmVyIHdpdGggdW5pdHMgZGVsdGEgdmFsdWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRGVsdGFcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUGxhaW4gcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY2FsY0N1cnJlbnRfdW5pdCA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudF91bml0KGRlbHRhLCBlcCwgcCkge1xuXHQgICAgdmFyIGN1cnJlbnRWYWx1ZSA9ICFkZWx0YS5jdXJ2ZSA/IGRlbHRhLnN0YXJ0LnZhbHVlICsgZXAgKiBkZWx0YS5kZWx0YSA6IGRlbHRhLmN1cnZlKHApICogKGRlbHRhLnN0YXJ0LnZhbHVlICsgcCAqIGRlbHRhLmRlbHRhKTtcblxuXHQgICAgdGhpcy5fby5wcm9wc1tkZWx0YS5uYW1lXSA9ICcnICsgY3VycmVudFZhbHVlICsgZGVsdGEuZW5kLnVuaXQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGMgdGhlIGN1cnJlbnQgYXJyYXkgZGVsdGEgdmFsdWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRGVsdGFcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUGxhaW4gcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY2FsY0N1cnJlbnRfYXJyYXkgPSBmdW5jdGlvbiBfY2FsY0N1cnJlbnRfYXJyYXkoZGVsdGEsIGVwLCBwKSB7XG5cdCAgICAvLyB2YXIgYXJyLFxuXHQgICAgdmFyIG5hbWUgPSBkZWx0YS5uYW1lLFxuXHQgICAgICAgIHByb3BzID0gdGhpcy5fby5wcm9wcyxcblx0ICAgICAgICBzdHJpbmcgPSAnJztcblxuXHQgICAgLy8gdG8gcHJldmVudCBHQyBib3RoZXJpbmcgd2l0aCBhcnJheXMgZ2FyYmFnZVxuXHQgICAgLy8gaWYgKCBoLmlzQXJyYXkoIHByb3BzW25hbWVdICkgKSB7XG5cdCAgICAvLyAgIGFyciA9IHByb3BzW25hbWVdO1xuXHQgICAgLy8gICBhcnIubGVuZ3RoID0gMDtcblx0ICAgIC8vIH0gZWxzZSB7IGFyciA9IFtdOyB9XG5cblx0ICAgIC8vIGp1c3Qgb3B0aW1pemF0aW9uIHRvIHByZXZlbnQgY3VydmVcblx0ICAgIC8vIGNhbGN1bGF0aW9ucyBvbiBldmVyeSBhcnJheSBpdGVtXG5cdCAgICB2YXIgcHJvYyA9IGRlbHRhLmN1cnZlID8gZGVsdGEuY3VydmUocCkgOiBudWxsO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhLmRlbHRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBpdGVtID0gZGVsdGEuZGVsdGFbaV0sXG5cdCAgICAgICAgICBkYXNoID0gIWRlbHRhLmN1cnZlID8gZGVsdGEuc3RhcnRbaV0udmFsdWUgKyBlcCAqIGl0ZW0udmFsdWUgOiBwcm9jICogKGRlbHRhLnN0YXJ0W2ldLnZhbHVlICsgcCAqIGl0ZW0udmFsdWUpO1xuXG5cdCAgICAgIHN0cmluZyArPSAnJyArIGRhc2ggKyBpdGVtLnVuaXQgKyAnICc7XG5cdCAgICAgIC8vIGFyci5wdXNoKHtcblx0ICAgICAgLy8gICBzdHJpbmc6IGAke2Rhc2h9JHtpdGVtLnVuaXR9YCxcblx0ICAgICAgLy8gICB2YWx1ZTogIGRhc2gsXG5cdCAgICAgIC8vICAgdW5pdDogICBpdGVtLnVuaXQsXG5cdCAgICAgIC8vIH0pO1xuXHQgICAgfVxuXHQgICAgcHJvcHNbbmFtZV0gPSBzdHJpbmc7XG5cdCAgfTtcblxuXHQgIHJldHVybiBEZWx0YTtcblx0fSgpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IERlbHRhO1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdHZhciBfdGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0dmFyIF90dW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTYpO1xuXG5cdHZhciBfdHVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90dW5hYmxlKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBTdGFnZ2VyID0gZnVuY3Rpb24gKF9UdW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoU3RhZ2dlciwgX1R1bmFibGUpO1xuXG5cdCAgZnVuY3Rpb24gU3RhZ2dlcihvcHRpb25zLCBNb2R1bGUpIHtcblx0ICAgIHZhciBfcmV0O1xuXG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTdGFnZ2VyKTtcblxuXHQgICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfVHVuYWJsZS5jYWxsKHRoaXMpKTtcblxuXHQgICAgcmV0dXJuIF9yZXQgPSBfdGhpcy5faW5pdChvcHRpb25zLCBNb2R1bGUpLCAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKF90aGlzLCBfcmV0KTtcblx0ICB9XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0aGVuIGNoYWluIG9uIGNoaWxkIG1vZHVsZXMuXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaGVuIG9wdGlvbnMuXHJcblx0ICAgIEByZXR1cm4ge09iamVjdH0gdGhpcy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG8pIHtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IGNoaWxkIG1vZHVsZSdzIG9wdGlvbiBhbmQgcGFzcyB0byB0aGUgY2hpbGQgYHRoZW5gXG5cdCAgICAgIHRoaXMuX21vZHVsZXNbaV0udGhlbih0aGlzLl9nZXRPcHRpb25CeUluZGV4KGksIG8pKTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIHR1bmUgY2hpbGQgbW9kdWxlcy5cclxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR1bmUgb3B0aW9ucy5cclxuXHQgICAgQHJldHVybiB7T2JqZWN0fSB0aGlzLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUudHVuZSA9IGZ1bmN0aW9uIHR1bmUobykge1xuXHQgICAgaWYgKG8gPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAvLyBnZXQgY2hpbGQgbW9kdWxlJ3Mgb3B0aW9uIGFuZCBwYXNzIHRvIHRoZSBjaGlsZCBgdGhlbmBcblx0ICAgICAgdGhpcy5fbW9kdWxlc1tpXS50dW5lKHRoaXMuX2dldE9wdGlvbkJ5SW5kZXgoaSwgbykpO1xuXHQgICAgfVxuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZ2VuZXJhdGUgY2hpbGQgbW9kdWxlcy5cclxuXHQgICAgQHJldHVybiB7T2JqZWN0fSB0aGlzLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAvLyBnZXQgY2hpbGQgbW9kdWxlJ3Mgb3B0aW9uIGFuZCBwYXNzIHRvIHRoZSBjaGlsZCBgdGhlbmBcblx0ICAgICAgdGhpcy5fbW9kdWxlc1tpXS5nZW5lcmF0ZSgpO1xuXHQgICAgfVxuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZ2V0IGFuIG9wdGlvbiBieSBtb2R1bG8gYW5kIG5hbWUuXHJcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXHJcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBmb3IgdGhlIG1vZHVsbyBjYWxjdWxhdGlvbi5cclxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgaGFzaCB0byBsb29rIGluLlxyXG5cdCAgICBAcmV0dXJuIHtBbnl9IFByb3BlcnR5LlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX2dldE9wdGlvbkJ5TW9kID0gZnVuY3Rpb24gX2dldE9wdGlvbkJ5TW9kKG5hbWUsIGksIHN0b3JlKSB7XG5cdCAgICB2YXIgcHJvcHMgPSBzdG9yZVtuYW1lXTtcblx0ICAgIC8vIGlmIG5vdCBkb20gbGlzdCB0aGVuIGNsb25lIGl0IHRvIGFycmF5XG5cdCAgICBpZiAocHJvcHMgKyAnJyA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJyB8fCBwcm9wcyArICcnID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKSBwcm9wcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHByb3BzLCAwKTtcblx0ICAgIC8vIGdldCB0aGUgdmFsdWUgaW4gYXJyYXkgb3IgcmV0dXJuIHRoZSB2YWx1ZSBpdHNlbGZcblx0ICAgIHZhciB2YWx1ZSA9IF9oMi5kZWZhdWx0LmlzQXJyYXkocHJvcHMpID8gcHJvcHNbaSAlIHByb3BzLmxlbmd0aF0gOiBwcm9wcztcblx0ICAgIC8vIGNoZWNrIGlmIHZhbHVlIGhhcyB0aGUgc3RhZ2dlciBleHByZXNzaW9uLCBpZiBzbyBwYXJzZSBpdFxuXHQgICAgcmV0dXJuIF9oMi5kZWZhdWx0LnBhcnNlSWZTdGFnZ2VyKHZhbHVlLCBpKTtcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBnZXQgb3B0aW9uIGJ5IG1vZHVsbyBvZiBpbmRleC5cclxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IGZvciBtb2R1bG8gY2FsY3VsYXRpb25zLlxyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBoYXNoIHRvIGxvb2sgaW4uXHJcblx0ICAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS5fZ2V0T3B0aW9uQnlJbmRleCA9IGZ1bmN0aW9uIF9nZXRPcHRpb25CeUluZGV4KGksIHN0b3JlKSB7XG5cdCAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuXHQgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0ICAgICgwLCBfa2V5czIuZGVmYXVsdCkoc3RvcmUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICByZXR1cm4gb3B0aW9uc1trZXldID0gX3RoaXMyLl9nZXRPcHRpb25CeU1vZChrZXksIGksIHN0b3JlKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZ2V0IHRvdGFsIGNoaWxkIG1vZHVsZXMgcXVhbnRpdHkuXHJcblx0ICAgIEBwYXJhbSAge1N0cmluZ30gTmFtZSBvZiBxdWFudGlmaWVyIGluIG9wdGlvbnMgaGFzaC5cclxuXHQgICAgQHBhcmFtICB7T2JqZWN0fSBPcHRpb25zIGhhc2ggb2JqZWN0LlxyXG5cdCAgICBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBvZiBjaGlsZCBvYmplY3QgdGhhdCBzaG91bGQgYmUgZGVmaW5lZC5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9nZXRDaGlsZFF1YW50aXR5ID0gZnVuY3Rpb24gX2dldENoaWxkUXVhbnRpdHkobmFtZSwgc3RvcmUpIHtcblx0ICAgIC8vIGlmIG51bWJlciB3YXMgc2V0XG5cdCAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJldHVybiBuYW1lO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcXVhbnRpZmllciA9IHN0b3JlW25hbWVdO1xuXHQgICAgaWYgKF9oMi5kZWZhdWx0LmlzQXJyYXkocXVhbnRpZmllcikpIHtcblx0ICAgICAgcmV0dXJuIHF1YW50aWZpZXIubGVuZ3RoO1xuXHQgICAgfSBlbHNlIGlmIChxdWFudGlmaWVyICsgJycgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScpIHtcblx0ICAgICAgcmV0dXJuIHF1YW50aWZpZXIubGVuZ3RoO1xuXHQgICAgfSBlbHNlIGlmIChxdWFudGlmaWVyICsgJycgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScpIHtcblx0ICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHF1YW50aWZpZXIsIDApLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAocXVhbnRpZmllciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdCAgICAgIHJldHVybiAxO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgcXVhbnRpZmllciA9PSAnc3RyaW5nJykge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBtYWtlIHN0YWdnZXIgZm9ybSBvcHRpb25zXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zLlxyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gQ2hpbGQgY2xhc3MuXHJcblx0ICAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KG9wdGlvbnMsIE1vZHVsZSkge1xuXHQgICAgdmFyIGNvdW50ID0gdGhpcy5fZ2V0Q2hpbGRRdWFudGl0eShvcHRpb25zLnF1YW50aWZpZXIgfHwgJ2VsJywgb3B0aW9ucyk7XG5cdCAgICB0aGlzLl9jcmVhdGVUaW1lbGluZShvcHRpb25zKTt0aGlzLl9tb2R1bGVzID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IGNoaWxkIG1vZHVsZSdzIG9wdGlvblxuXHQgICAgICB2YXIgb3B0aW9uID0gdGhpcy5fZ2V0T3B0aW9uQnlJbmRleChpLCBvcHRpb25zKTtcblx0ICAgICAgb3B0aW9uLmlzUnVuTGVzcyA9IHRydWU7XG5cdCAgICAgIC8vIHNldCBpbmRleCBvZiB0aGUgbW9kdWxlXG5cdCAgICAgIG9wdGlvbi5pbmRleCA9IGk7XG5cdCAgICAgIC8vIGNyZWF0ZSBjaGlsZCBtb2R1bGVcblx0ICAgICAgdmFyIG1vZHVsZSA9IG5ldyBNb2R1bGUob3B0aW9uKTt0aGlzLl9tb2R1bGVzLnB1c2gobW9kdWxlKTtcblx0ICAgICAgLy8gYWRkIGNoaWxkIG1vZHVsZSdzIHRpbWVsaW5lIHRvIHRoZSBzZWxmIHRpbWVsaW5lXG5cdCAgICAgIHRoaXMudGltZWxpbmUuYWRkKG1vZHVsZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdGltZWxpbmUuXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaW1lbGluZSBvcHRpb25zLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX2NyZWF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gX2NyZWF0ZVRpbWVsaW5lKCkge1xuXHQgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG5cdCAgICB0aGlzLnRpbWVsaW5lID0gbmV3IF90aW1lbGluZTIuZGVmYXVsdChvcHRpb25zLnRpbWVsaW5lKTtcblx0ICB9O1xuXG5cdCAgLyogQG92ZXJyaWRlcyBAIFR3ZWVuYWJsZSAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS5fbWFrZVR3ZWVuID0gZnVuY3Rpb24gX21ha2VUd2VlbigpIHt9O1xuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX21ha2VUaW1lbGluZSA9IGZ1bmN0aW9uIF9tYWtlVGltZWxpbmUoKSB7fTtcblxuXHQgIHJldHVybiBTdGFnZ2VyO1xuXHR9KF90dW5hYmxlMi5kZWZhdWx0KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNb2R1bGUpIHtcblx0ICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgIHJldHVybiBuZXcgU3RhZ2dlcihvcHRpb25zLCBNb2R1bGUpO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXHJcblx0ICBDbGFzcyBmb3IgdG9nZ2xpbmcgb3BhY2l0eSBvbiBidW5jaCBvZiBlbGVtZW50c1xyXG5cdCAgQGNsYXNzIFNwcml0ZXJcclxuXHQgIEB0b2RvXHJcblx0ICAgIC0gYWRkIGlzRm9yY2UzZCBvcHRpb25cclxuXHQgICAgLSBhZGQgcnVuIG5ldyBvcHRpb24gbWVyZ2luZ1xyXG5cdCAgICAtIGFkZCB0aGVuIGNoYWluc1xyXG5cdCovXG5cdHZhciBTcHJpdGVyID0gZnVuY3Rpb24gKCkge1xuXHQgIC8qXHJcblx0ICAgIERlZmF1bHRzL0FQSXNcclxuXHQgICovXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICB0aGlzLl9kZWZhdWx0cyA9IHtcblx0ICAgICAgLypcclxuXHQgICAgICAgIER1cmF0aW9uXHJcblx0ICAgICAgICBAcHJvcGVydHkgZHVyYXRpb25cclxuXHQgICAgICAgIEB0eXBlICAgICB7TnVtYmVyfVxyXG5cdCAgICAgICovXG5cdCAgICAgIGR1cmF0aW9uOiA1MDAsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBEZWxheVxyXG5cdCAgICAgICAgQHByb3BlcnR5IGRlbGF5XHJcblx0ICAgICAgICBAdHlwZSAgICAge051bWJlcn1cclxuXHQgICAgICAqL1xuXHQgICAgICBkZWxheTogMCxcblx0ICAgICAgLypcclxuXHQgICAgICAgIEVhc2luZy4gUGxlYXNlIHNlZSB0aGUgXHJcblx0ICAgICAgICBbdGltZWxpbmUgbW9kdWxlIHBhcnNlRWFzaW5nIGZ1bmN0aW9uXSh0aW1lbGluZS5jb2ZmZWUuaHRtbCNwYXJzZUVhc2luZylcclxuXHQgICAgICAgIGZvciBhbGwgYXZhbGlhYmxlIG9wdGlvbnMuXHJcblx0ICAgICAgICAgIEBwcm9wZXJ0eSBlYXNpbmdcclxuXHQgICAgICAgIEB0eXBlICAgICB7U3RyaW5nLCBGdW5jdGlvbn1cclxuXHQgICAgICAqL1xuXHQgICAgICBlYXNpbmc6ICdsaW5lYXIubm9uZScsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBSZXBlYXQgdGltZXMgY291bnRcclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IHJlcGVhdFxyXG5cdCAgICAgICAgQHR5cGUgICAgIHtOdW1iZXJ9XHJcblx0ICAgICAgKi9cblx0ICAgICAgcmVwZWF0OiAwLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgWW95byBvcHRpb24gZGVmaW5lcyBpZiBhbmltYXRpb24gc2hvdWxkIGJlIGFsdGVyZWQgb24gcmVwZWF0LlxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICBAcHJvcGVydHkgeW95b1xyXG5cdCAgICAgICAgQHR5cGUgICAgIHtCb29sZWFufVxyXG5cdCAgICAgICovXG5cdCAgICAgIHlveW86IGZhbHNlLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgaXNSdW5MZXNzIG9wdGlvbiBwcmV2ZW50cyBhbmltYXRpb24gZnJvbSBydW5uaW5nIGltbWVkaWF0ZWx5IGFmdGVyXHJcblx0ICAgICAgICBpbml0aWFsaXphdGlvbi5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IGlzUnVuTGVzc1xyXG5cdCAgICAgICAgQHR5cGUgICAgIHtCb29sZWFufVxyXG5cdCAgICAgICovXG5cdCAgICAgIGlzUnVuTGVzczogZmFsc2UsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBpc1Nob3dFbmQgb3B0aW9uIGRlZmluZXMgaWYgdGhlIGxhc3QgZnJhbWUgc2hvdWxkIGJlIHNob3duIHdoZW5cclxuXHQgICAgICAgIGFuaW1hdGlvbiBjb21wbGV0ZWQuXHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBpc1Nob3dFbmRcclxuXHQgICAgICAgIEB0eXBlICAgICB7Qm9vbGVhbn1cclxuXHQgICAgICAqL1xuXHQgICAgICBpc1Nob3dFbmQ6IGZhbHNlLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgb25TdGFydCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbmNlIG9uIGFuaW1hdGlvbiBzdGFydC5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IG9uU3RhcnRcclxuXHQgICAgICAgIEB0eXBlICAgICB7RnVuY3Rpb259XHJcblx0ICAgICAgKi9cblx0ICAgICAgb25TdGFydDogbnVsbCxcblx0ICAgICAgLypcclxuXHQgICAgICAgIG9uVXBkYXRlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IGZyYW1lIG9mIHRoZSBhbmltYXRpb24uXHJcblx0ICAgICAgICBUaGUgY3VycmVudCBwcm9ncmVzcyBpbiByYW5nZSAqKlswLDFdKiogd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICBAcHJvcGVydHkgb25VcGRhdGVcclxuXHQgICAgICAgIEB0eXBlICAgICB7RnVuY3Rpb259XHJcblx0ICAgICAgKi9cblx0ICAgICAgb25VcGRhdGU6IG51bGwsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBvbkNvbXBsZXRlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIG9uY2Ugb24gYW5pbWF0aW9uIGNvbXBsZXRlLlxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICBAcHJvcGVydHkgb25Db21wbGV0ZVxyXG5cdCAgICAgICAgQHR5cGUgICAgIHtGdW5jdGlvbn1cclxuXHQgICAgICAqL1xuXHQgICAgICBvbkNvbXBsZXRlOiBudWxsXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBTcHJpdGVyKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3ByaXRlcik7XG5cblx0ICAgIHRoaXMubyA9IG87XG5cdCAgICBpZiAoIXRoaXMuby5lbCkge1xuXHQgICAgICByZXR1cm4gX2gyLmRlZmF1bHQuZXJyb3IoJ05vIFwiZWxcIiBvcHRpb24gc3BlY2lmaWVkLCBhYm9ydGluZycpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fdmFycygpO3RoaXMuX2RlY2xhcmVEZWZhdWx0cygpO3RoaXMuX2V4dGVuZERlZmF1bHRzKCk7dGhpcy5fcGFyc2VGcmFtZXMoKTtcblx0ICAgIGlmICh0aGlzLl9mcmFtZXMubGVuZ3RoIDw9IDIpIF9oMi5kZWZhdWx0Lndhcm4oJ1Nwcml0ZXI6IG9ubHkgJyArIHRoaXMuX2ZyYW1lcy5sZW5ndGggKyAnIGZyYW1lcyBmb3VuZCcpO1xuXHQgICAgaWYgKHRoaXMuX2ZyYW1lcy5sZW5ndGggPCAxKSBfaDIuZGVmYXVsdC5lcnJvcihcIlNwcml0ZXI6IHRoZXJlIGlzIG5vIGZyYW1lcyB0byBhbmltYXRlLCBhYm9ydGluZ1wiKTtcblx0ICAgIHRoaXMuX2NyZWF0ZVR3ZWVuKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgc29tZSB2YXJpYWJsZXMuXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIHJ1blxyXG5cdCAgICBAcGFyYW0gIHtPYmplY3R9IE5ldyBvcHRpb25zXHJcblx0ICAgIEB0b2RvICAgSW1wbGVtZW50IG5ldyBvYmplY3QgbWVyZ2luZ1xyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMuX3Byb3BzID0gX2gyLmRlZmF1bHQuY2xvbmVPYmoodGhpcy5vKTtcblx0ICAgIHRoaXMuZWwgPSB0aGlzLm8uZWw7XG5cdCAgICB0aGlzLl9mcmFtZXMgPSBbXTtcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBydW4gdGhlIHNwcml0ZXIgb24gZGVtYW5kLlxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBydW5cclxuXHQgICAgQHBhcmFtICB7T2JqZWN0fSBOZXcgb3B0aW9uc1xyXG5cdCAgICBAdG9kbyAgIEltcGxlbWVudCBuZXcgb2JqZWN0IG1lcmdpbmdcclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1bihvKSB7XG5cdCAgICByZXR1cm4gdGhpcy50aW1lbGluZS5wbGF5KCk7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZXh0ZW5kIF9wcm9wcyBieSBvcHRpb25zKHRoaXMubylcclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgX2V4dGVuZERlZmF1bHRzXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICByZXR1cm4gX2gyLmRlZmF1bHQuZXh0ZW5kKHRoaXMuX3Byb3BzLCB0aGlzLl9kZWZhdWx0cyk7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgZnJhbWVzIGFzIGNoaWxkIG5vZGVzIG9mIGVsLlxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBfcGFyc2VGcmFtZXNcclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9wYXJzZUZyYW1lcyA9IGZ1bmN0aW9uIF9wYXJzZUZyYW1lcygpIHtcblx0ICAgIHRoaXMuX2ZyYW1lcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGRyZW4sIDApO1xuXHQgICAgdGhpcy5fZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lLCBpKSB7XG5cdCAgICAgIHJldHVybiBmcmFtZS5zdHlsZS5vcGFjaXR5ID0gMDtcblx0ICAgIH0pO1xuXHQgICAgdGhpcy5fZnJhbWVTdGVwID0gMSAvIHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdCAgfTtcblxuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdHdlZW4gYW5kIHRpbWVsaW5lIGFuZCBzdXBwbHkgY2FsbGJhY2tzLlxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBfY3JlYXRlVHdlZW5cclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9jcmVhdGVUd2VlbiA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlbigpIHtcblx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cblx0ICAgIHRoaXMuX3R3ZWVuID0gbmV3IF90d2VlbjIuZGVmYXVsdCh7XG5cdCAgICAgIGR1cmF0aW9uOiB0aGlzLl9wcm9wcy5kdXJhdGlvbixcblx0ICAgICAgZGVsYXk6IHRoaXMuX3Byb3BzLmRlbGF5LFxuXHQgICAgICB5b3lvOiB0aGlzLl9wcm9wcy55b3lvLFxuXHQgICAgICByZXBlYXQ6IHRoaXMuX3Byb3BzLnJlcGVhdCxcblx0ICAgICAgZWFzaW5nOiB0aGlzLl9wcm9wcy5lYXNpbmcsXG5cdCAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLl9wcm9wcy5vblN0YXJ0ICYmIF90aGlzLl9wcm9wcy5vblN0YXJ0KCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLl9wcm9wcy5vbkNvbXBsZXRlICYmIF90aGlzLl9wcm9wcy5vbkNvbXBsZXRlKCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShwKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLl9zZXRQcm9ncmVzcyhwKTtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnRpbWVsaW5lID0gbmV3IF90aW1lbGluZTIuZGVmYXVsdCgpO3RoaXMudGltZWxpbmUuYWRkKHRoaXMuX3R3ZWVuKTtcblx0ICAgIGlmICghdGhpcy5fcHJvcHMuaXNSdW5MZXNzKSB0aGlzLl9zdGFydFR3ZWVuKCk7XG5cdCAgfTtcblxuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBzdGFydCB0d2VlblxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBfc3RhcnRUd2VlblxyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX3N0YXJ0VHdlZW4gPSBmdW5jdGlvbiBfc3RhcnRUd2VlbigpIHtcblx0ICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIF90aGlzMi50aW1lbGluZS5wbGF5KCk7XG5cdCAgICB9LCAxKTtcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBzZXQgcHJvZ3Jlc3Mgb2YgdGhlIHNwcml0ZVxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBfc2V0UHJvZ3Jlc3NcclxuXHQgICAgQHBhcmFtICB7TnVtYmVyfSBQcm9ncmVzcyBpbiByYW5nZSAqKlswLDFdKipcclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIF9zZXRQcm9ncmVzcyhwKSB7XG5cdCAgICAvLyBnZXQgdGhlIGZyYW1lIG51bWJlclxuXHQgICAgdmFyIHByb2MgPSBNYXRoLmZsb29yKHAgLyB0aGlzLl9mcmFtZVN0ZXApO1xuXHQgICAgLy8gcmVhY3Qgb25seSBpZiBmcmFtZSBjaGFuZ2VzXG5cdCAgICBpZiAodGhpcy5fcHJldkZyYW1lICE9IHRoaXMuX2ZyYW1lc1twcm9jXSkge1xuXHQgICAgICAvLyBpZiBwcmV2aW91cyBmcmFtZSBpc250IGN1cnJlbnQgb25lLCBoaWRlIGl0XG5cdCAgICAgIGlmICh0aGlzLl9wcmV2RnJhbWUpIHtcblx0ICAgICAgICB0aGlzLl9wcmV2RnJhbWUuc3R5bGUub3BhY2l0eSA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gaWYgZW5kIG9mIGFuaW1hdGlvbiBhbmQgaXNTaG93RW5kIGZsYWcgd2FzIHNwZWNpZmllZFxuXHQgICAgICAvLyB0aGVuIHNob3cgdGhlIGxhc3QgZnJhbWUgZWxzZSBzaG93IGN1cnJlbnQgZnJhbWVcblx0ICAgICAgdmFyIGN1cnJlbnROdW0gPSBwID09PSAxICYmIHRoaXMuX3Byb3BzLmlzU2hvd0VuZCA/IHByb2MgLSAxIDogcHJvYztcblx0ICAgICAgLy8gc2hvdyB0aGUgY3VycmVudCBmcmFtZVxuXHQgICAgICBpZiAodGhpcy5fZnJhbWVzW2N1cnJlbnROdW1dKSB7XG5cdCAgICAgICAgdGhpcy5fZnJhbWVzW2N1cnJlbnROdW1dLnN0eWxlLm9wYWNpdHkgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHNldCBwcmV2aW91cyBmcmFtZSBhcyBjdXJyZW50XG5cdCAgICAgIHRoaXMuX3ByZXZGcmFtZSA9IHRoaXMuX2ZyYW1lc1twcm9jXTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9wcm9wcy5vblVwZGF0ZSkge1xuXHQgICAgICB0aGlzLl9wcm9wcy5vblVwZGF0ZShwKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0dXJuIFNwcml0ZXI7XG5cdH0oKTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBTcHJpdGVyO1xuXG4vKioqLyB9KSxcbi8qIDEyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBNb3Rpb25QYXRoLCBUaW1lbGluZSwgVHdlZW4sIGgsIHJlc2l6ZSxcblx0ICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cblx0cmVzaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzApO1xuXG5cdFR3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpW1wiZGVmYXVsdFwiXTtcblxuXHRUaW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEwKVtcImRlZmF1bHRcIl07XG5cblx0TW90aW9uUGF0aCA9IChmdW5jdGlvbigpIHtcblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcblx0ICAgIHBhdGg6IG51bGwsXG5cdCAgICBjdXJ2YXR1cmU6IHtcblx0ICAgICAgeDogJzc1JScsXG5cdCAgICAgIHk6ICc1MCUnXG5cdCAgICB9LFxuXHQgICAgaXNDb21wb3NpdGVMYXllcjogdHJ1ZSxcblx0ICAgIGRlbGF5OiAwLFxuXHQgICAgZHVyYXRpb246IDEwMDAsXG5cdCAgICBlYXNpbmc6IG51bGwsXG5cdCAgICByZXBlYXQ6IDAsXG5cdCAgICB5b3lvOiBmYWxzZSxcblx0ICAgIG9uU3RhcnQ6IG51bGwsXG5cdCAgICBvbkNvbXBsZXRlOiBudWxsLFxuXHQgICAgb25VcGRhdGU6IG51bGwsXG5cdCAgICBvZmZzZXRYOiAwLFxuXHQgICAgb2Zmc2V0WTogMCxcblx0ICAgIGFuZ2xlT2Zmc2V0OiBudWxsLFxuXHQgICAgcGF0aFN0YXJ0OiAwLFxuXHQgICAgcGF0aEVuZDogMSxcblx0ICAgIG1vdGlvbkJsdXI6IDAsXG5cdCAgICB0cmFuc2Zvcm1PcmlnaW46IG51bGwsXG5cdCAgICBpc0FuZ2xlOiBmYWxzZSxcblx0ICAgIGlzUmV2ZXJzZTogZmFsc2UsXG5cdCAgICBpc1J1bkxlc3M6IGZhbHNlLFxuXHQgICAgaXNQcmVzZXRQb3NpdGlvbjogdHJ1ZVxuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBNb3Rpb25QYXRoKG8xKSB7XG5cdCAgICB0aGlzLm8gPSBvMSAhPSBudWxsID8gbzEgOiB7fTtcblx0ICAgIHRoaXMuY2FsY0hlaWdodCA9IGJpbmQodGhpcy5jYWxjSGVpZ2h0LCB0aGlzKTtcblx0ICAgIGlmICh0aGlzLnZhcnMoKSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLmNyZWF0ZVR3ZWVuKCk7XG5cdCAgICB0aGlzO1xuXHQgIH1cblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMuZ2V0U2NhbGVyID0gaC5iaW5kKHRoaXMuZ2V0U2NhbGVyLCB0aGlzKTtcblx0ICAgIHRoaXMucmVzaXplID0gcmVzaXplO1xuXHQgICAgdGhpcy5wcm9wcyA9IGguY2xvbmVPYmoodGhpcy5kZWZhdWx0cyk7XG5cdCAgICB0aGlzLmV4dGVuZE9wdGlvbnModGhpcy5vKTtcblx0ICAgIHRoaXMuaXNNb3Rpb25CbHVyUmVzZXQgPSBoLmlzU2FmYXJpIHx8IGguaXNJRTtcblx0ICAgIHRoaXMuaXNNb3Rpb25CbHVyUmVzZXQgJiYgKHRoaXMucHJvcHMubW90aW9uQmx1ciA9IDApO1xuXHQgICAgdGhpcy5oaXN0b3J5ID0gW2guY2xvbmVPYmoodGhpcy5wcm9wcyldO1xuXHQgICAgcmV0dXJuIHRoaXMucG9zdFZhcnMoKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuY3VydmVUb1BhdGggPSBmdW5jdGlvbihvKSB7XG5cdCAgICB2YXIgYW5nbGUsIGN1cnZhdHVyZSwgY3VydmF0dXJlWCwgY3VydmF0dXJlWSwgY3VydmVQb2ludCwgY3VydmVYUG9pbnQsIGRYLCBkWSwgZW5kUG9pbnQsIHBhdGgsIHBlcmNlbnQsIHJhZGl1cywgc3RhcnQ7XG5cdCAgICBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGguTlMsICdwYXRoJyk7XG5cdCAgICBzdGFydCA9IG8uc3RhcnQ7XG5cdCAgICBlbmRQb2ludCA9IHtcblx0ICAgICAgeDogc3RhcnQueCArIG8uc2hpZnQueCxcblx0ICAgICAgeTogc3RhcnQueCArIG8uc2hpZnQueVxuXHQgICAgfTtcblx0ICAgIGN1cnZhdHVyZSA9IG8uY3VydmF0dXJlO1xuXHQgICAgZFggPSBvLnNoaWZ0Lng7XG5cdCAgICBkWSA9IG8uc2hpZnQueTtcblx0ICAgIHJhZGl1cyA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG5cdCAgICBwZXJjZW50ID0gcmFkaXVzIC8gMTAwO1xuXHQgICAgYW5nbGUgPSBNYXRoLmF0YW4oZFkgLyBkWCkgKiAoMTgwIC8gTWF0aC5QSSkgKyA5MDtcblx0ICAgIGlmIChvLnNoaWZ0LnggPCAwKSB7XG5cdCAgICAgIGFuZ2xlID0gYW5nbGUgKyAxODA7XG5cdCAgICB9XG5cdCAgICBjdXJ2YXR1cmVYID0gaC5wYXJzZVVuaXQoY3VydmF0dXJlLngpO1xuXHQgICAgY3VydmF0dXJlWCA9IGN1cnZhdHVyZVgudW5pdCA9PT0gJyUnID8gY3VydmF0dXJlWC52YWx1ZSAqIHBlcmNlbnQgOiBjdXJ2YXR1cmVYLnZhbHVlO1xuXHQgICAgY3VydmVYUG9pbnQgPSBoLmdldFJhZGlhbFBvaW50KHtcblx0ICAgICAgY2VudGVyOiB7XG5cdCAgICAgICAgeDogc3RhcnQueCxcblx0ICAgICAgICB5OiBzdGFydC55XG5cdCAgICAgIH0sXG5cdCAgICAgIHJhZGl1czogY3VydmF0dXJlWCxcblx0ICAgICAgYW5nbGU6IGFuZ2xlXG5cdCAgICB9KTtcblx0ICAgIGN1cnZhdHVyZVkgPSBoLnBhcnNlVW5pdChjdXJ2YXR1cmUueSk7XG5cdCAgICBjdXJ2YXR1cmVZID0gY3VydmF0dXJlWS51bml0ID09PSAnJScgPyBjdXJ2YXR1cmVZLnZhbHVlICogcGVyY2VudCA6IGN1cnZhdHVyZVkudmFsdWU7XG5cdCAgICBjdXJ2ZVBvaW50ID0gaC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgIGNlbnRlcjoge1xuXHQgICAgICAgIHg6IGN1cnZlWFBvaW50LngsXG5cdCAgICAgICAgeTogY3VydmVYUG9pbnQueVxuXHQgICAgICB9LFxuXHQgICAgICByYWRpdXM6IGN1cnZhdHVyZVksXG5cdCAgICAgIGFuZ2xlOiBhbmdsZSArIDkwXG5cdCAgICB9KTtcblx0ICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgXCJNXCIgKyBzdGFydC54ICsgXCIsXCIgKyBzdGFydC55ICsgXCIgUVwiICsgY3VydmVQb2ludC54ICsgXCIsXCIgKyBjdXJ2ZVBvaW50LnkgKyBcIiBcIiArIGVuZFBvaW50LnggKyBcIixcIiArIGVuZFBvaW50LnkpO1xuXHQgICAgcmV0dXJuIHBhdGg7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnBvc3RWYXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLnByb3BzLnBhdGhTdGFydCA9IGguY2xhbXAodGhpcy5wcm9wcy5wYXRoU3RhcnQsIDAsIDEpO1xuXHQgICAgdGhpcy5wcm9wcy5wYXRoRW5kID0gaC5jbGFtcCh0aGlzLnByb3BzLnBhdGhFbmQsIHRoaXMucHJvcHMucGF0aFN0YXJ0LCAxKTtcblx0ICAgIHRoaXMuYW5nbGUgPSAwO1xuXHQgICAgdGhpcy5zcGVlZFggPSAwO1xuXHQgICAgdGhpcy5zcGVlZFkgPSAwO1xuXHQgICAgdGhpcy5ibHVyWCA9IDA7XG5cdCAgICB0aGlzLmJsdXJZID0gMDtcblx0ICAgIHRoaXMucHJldkNvb3JkcyA9IHt9O1xuXHQgICAgdGhpcy5ibHVyQW1vdW50ID0gMjA7XG5cdCAgICB0aGlzLnByb3BzLm1vdGlvbkJsdXIgPSBoLmNsYW1wKHRoaXMucHJvcHMubW90aW9uQmx1ciwgMCwgMSk7XG5cdCAgICB0aGlzLm9uVXBkYXRlID0gdGhpcy5wcm9wcy5vblVwZGF0ZTtcblx0ICAgIGlmICghdGhpcy5vLmVsKSB7XG5cdCAgICAgIGguZXJyb3IoJ01pc3NlZCBcImVsXCIgb3B0aW9uLiBJdCBjb3VsZCBiZSBhIHNlbGVjdG9yLCBET01Ob2RlIG9yIGFub3RoZXIgbW9kdWxlLicpO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHRoaXMuZWwgPSB0aGlzLnBhcnNlRWwodGhpcy5wcm9wcy5lbCk7XG5cdCAgICB0aGlzLnByb3BzLm1vdGlvbkJsdXIgPiAwICYmIHRoaXMuY3JlYXRlRmlsdGVyKCk7XG5cdCAgICB0aGlzLnBhdGggPSB0aGlzLmdldFBhdGgoKTtcblx0ICAgIGlmICghdGhpcy5wYXRoLmdldEF0dHJpYnV0ZSgnZCcpKSB7XG5cdCAgICAgIGguZXJyb3IoJ1BhdGggaGFzIG5vIGNvb3JkaW5hdGVzIHRvIHdvcmsgd2l0aCwgYWJvcnRpbmcnKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB0aGlzLmxlbiA9IHRoaXMucGF0aC5nZXRUb3RhbExlbmd0aCgpO1xuXHQgICAgdGhpcy5zbGljZWRMZW4gPSB0aGlzLmxlbiAqICh0aGlzLnByb3BzLnBhdGhFbmQgLSB0aGlzLnByb3BzLnBhdGhTdGFydCk7XG5cdCAgICB0aGlzLnN0YXJ0TGVuID0gdGhpcy5wcm9wcy5wYXRoU3RhcnQgKiB0aGlzLmxlbjtcblx0ICAgIHRoaXMuZmlsbCA9IHRoaXMucHJvcHMuZmlsbDtcblx0ICAgIGlmICh0aGlzLmZpbGwgIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMucGFyc2VFbCh0aGlzLnByb3BzLmZpbGwuY29udGFpbmVyKTtcblx0ICAgICAgdGhpcy5maWxsUnVsZSA9IHRoaXMucHJvcHMuZmlsbC5maWxsUnVsZSB8fCAnYWxsJztcblx0ICAgICAgdGhpcy5nZXRTY2FsZXIoKTtcblx0ICAgICAgaWYgKHRoaXMuY29udGFpbmVyICE9IG51bGwpIHtcblx0ICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KHRoaXMuY29udGFpbmVyLCAnb25yZXNpemUnLCB0aGlzLmdldFNjYWxlcik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnQodGhpcy5jb250YWluZXIsICdvbnJlc2l6ZScsIHRoaXMuZ2V0U2NhbGVyKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBoYW5kbGVyKSB7XG5cdCAgICByZXR1cm4gZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oZWwsIHR5cGUsIGhhbmRsZXIpIHtcblx0ICAgIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuY3JlYXRlRmlsdGVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgZGl2LCBzdmc7XG5cdCAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ICAgIHRoaXMuZmlsdGVySUQgPSBcImZpbHRlci1cIiArIChoLmdldFVuaXFJRCgpKTtcblx0ICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzdmcgaWQ9XFxcInN2Zy1cIiArIHRoaXMuZmlsdGVySUQgKyBcIlxcXCJcXG4gICAgc3R5bGU9XFxcInZpc2liaWxpdHk6aGlkZGVuOyB3aWR0aDowcHg7IGhlaWdodDowcHhcXFwiPlxcbiAgPGZpbHRlciBpZD1cXFwiXCIgKyB0aGlzLmZpbHRlcklEICsgXCJcXFwiIHk9XFxcIi0yMFxcXCIgeD1cXFwiLTIwXFxcIiB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiPlxcbiAgICA8ZmVPZmZzZXRcXG4gICAgICBpZD1cXFwiYmx1ci1vZmZzZXRcXFwiIGluPVxcXCJTb3VyY2VHcmFwaGljXFxcIlxcbiAgICAgIGR4PVxcXCIwXFxcIiBkeT1cXFwiMFxcXCIgcmVzdWx0PVxcXCJvZmZzZXQyXFxcIj48L2ZlT2Zmc2V0PlxcbiAgICA8ZmVHYXVzc2lhbmJsdXJcXG4gICAgICBpZD1cXFwiYmx1clxcXCIgaW49XFxcIm9mZnNldDJcXFwiXFxuICAgICAgc3RkRGV2aWF0aW9uPVxcXCIwLDBcXFwiIHJlc3VsdD1cXFwiYmx1cjJcXFwiPjwvZmVHYXVzc2lhbmJsdXI+XFxuICAgIDxmZU1lcmdlPlxcbiAgICAgIDxmZU1lcmdlTm9kZSBpbj1cXFwiU291cmNlR3JhcGhpY1xcXCI+PC9mZU1lcmdlTm9kZT5cXG4gICAgICA8ZmVNZXJnZU5vZGUgaW49XFxcImJsdXIyXFxcIj48L2ZlTWVyZ2VOb2RlPlxcbiAgICA8L2ZlTWVyZ2U+XFxuICA8L2ZpbHRlcj5cXG48L3N2Zz5cIjtcblx0ICAgIHN2ZyA9IGRpdi5xdWVyeVNlbGVjdG9yKFwiI3N2Zy1cIiArIHRoaXMuZmlsdGVySUQpO1xuXHQgICAgdGhpcy5maWx0ZXIgPSBzdmcucXVlcnlTZWxlY3RvcignI2JsdXInKTtcblx0ICAgIHRoaXMuZmlsdGVyT2Zmc2V0ID0gc3ZnLnF1ZXJ5U2VsZWN0b3IoJyNibHVyLW9mZnNldCcpO1xuXHQgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoc3ZnLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuXHQgICAgdGhpcy5lbC5zdHlsZVsnZmlsdGVyJ10gPSBcInVybCgjXCIgKyB0aGlzLmZpbHRlcklEICsgXCIpXCI7XG5cdCAgICByZXR1cm4gdGhpcy5lbC5zdHlsZVtoLnByZWZpeC5jc3MgKyBcImZpbHRlclwiXSA9IFwidXJsKCNcIiArIHRoaXMuZmlsdGVySUQgKyBcIilcIjtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUucGFyc2VFbCA9IGZ1bmN0aW9uKGVsKSB7XG5cdCAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuXHQgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHQgICAgICByZXR1cm4gZWw7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwuX3NldFByb3AgIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLmlzTW9kdWxlID0gdHJ1ZTtcblx0ICAgICAgcmV0dXJuIGVsO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcGF0aDtcblx0ICAgIHBhdGggPSBoLnBhcnNlUGF0aCh0aGlzLnByb3BzLnBhdGgpO1xuXHQgICAgaWYgKHBhdGgpIHtcblx0ICAgICAgcmV0dXJuIHBhdGg7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5wcm9wcy5wYXRoLnggfHwgdGhpcy5wcm9wcy5wYXRoLnkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuY3VydmVUb1BhdGgoe1xuXHQgICAgICAgIHN0YXJ0OiB7XG5cdCAgICAgICAgICB4OiAwLFxuXHQgICAgICAgICAgeTogMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2hpZnQ6IHtcblx0ICAgICAgICAgIHg6IHRoaXMucHJvcHMucGF0aC54IHx8IDAsXG5cdCAgICAgICAgICB5OiB0aGlzLnByb3BzLnBhdGgueSB8fCAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBjdXJ2YXR1cmU6IHtcblx0ICAgICAgICAgIHg6IHRoaXMucHJvcHMuY3VydmF0dXJlLnggfHwgdGhpcy5kZWZhdWx0cy5jdXJ2YXR1cmUueCxcblx0ICAgICAgICAgIHk6IHRoaXMucHJvcHMuY3VydmF0dXJlLnkgfHwgdGhpcy5kZWZhdWx0cy5jdXJ2YXR1cmUueVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmdldFNjYWxlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGVuZCwgc2l6ZSwgc3RhcnQ7XG5cdCAgICB0aGlzLmNTaXplID0ge1xuXHQgICAgICB3aWR0aDogdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGggfHwgMCxcblx0ICAgICAgaGVpZ2h0OiB0aGlzLmNvbnRhaW5lci5vZmZzZXRIZWlnaHQgfHwgMFxuXHQgICAgfTtcblx0ICAgIHN0YXJ0ID0gdGhpcy5wYXRoLmdldFBvaW50QXRMZW5ndGgoMCk7XG5cdCAgICBlbmQgPSB0aGlzLnBhdGguZ2V0UG9pbnRBdExlbmd0aCh0aGlzLmxlbik7XG5cdCAgICBzaXplID0ge307XG5cdCAgICB0aGlzLnNjYWxlciA9IHt9O1xuXHQgICAgc2l6ZS53aWR0aCA9IGVuZC54ID49IHN0YXJ0LnggPyBlbmQueCAtIHN0YXJ0LnggOiBzdGFydC54IC0gZW5kLng7XG5cdCAgICBzaXplLmhlaWdodCA9IGVuZC55ID49IHN0YXJ0LnkgPyBlbmQueSAtIHN0YXJ0LnkgOiBzdGFydC55IC0gZW5kLnk7XG5cdCAgICBzd2l0Y2ggKHRoaXMuZmlsbFJ1bGUpIHtcblx0ICAgICAgY2FzZSAnYWxsJzpcblx0ICAgICAgICB0aGlzLmNhbGNXaWR0aChzaXplKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jYWxjSGVpZ2h0KHNpemUpO1xuXHQgICAgICBjYXNlICd3aWR0aCc6XG5cdCAgICAgICAgdGhpcy5jYWxjV2lkdGgoc2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVyLnkgPSB0aGlzLnNjYWxlci54O1xuXHQgICAgICBjYXNlICdoZWlnaHQnOlxuXHQgICAgICAgIHRoaXMuY2FsY0hlaWdodChzaXplKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIueCA9IHRoaXMuc2NhbGVyLnk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmNhbGNXaWR0aCA9IGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgIHRoaXMuc2NhbGVyLnggPSB0aGlzLmNTaXplLndpZHRoIC8gc2l6ZS53aWR0aDtcblx0ICAgIHJldHVybiAhaXNGaW5pdGUodGhpcy5zY2FsZXIueCkgJiYgKHRoaXMuc2NhbGVyLnggPSAxKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuY2FsY0hlaWdodCA9IGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgIHRoaXMuc2NhbGVyLnkgPSB0aGlzLmNTaXplLmhlaWdodCAvIHNpemUuaGVpZ2h0O1xuXHQgICAgcmV0dXJuICFpc0Zpbml0ZSh0aGlzLnNjYWxlci55KSAmJiAodGhpcy5zY2FsZXIueSA9IDEpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihvKSB7XG5cdCAgICB2YXIgZmlzdEl0ZW0sIGtleSwgdmFsdWU7XG5cdCAgICBpZiAobykge1xuXHQgICAgICBmaXN0SXRlbSA9IHRoaXMuaGlzdG9yeVswXTtcblx0ICAgICAgZm9yIChrZXkgaW4gbykge1xuXHQgICAgICAgIHZhbHVlID0gb1trZXldO1xuXHQgICAgICAgIGlmIChoLmNhbGxiYWNrc01hcFtrZXldIHx8IGgudHdlZW5PcHRpb25NYXBba2V5XSkge1xuXHQgICAgICAgICAgaC53YXJuKFwidGhlIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBwcm9wZXJ0eSBjYW4gbm90IGJlIG92ZXJyaWRkZW4gb24gcnVuIHlldFwiKTtcblx0ICAgICAgICAgIGRlbGV0ZSBvW2tleV07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHRoaXMuaGlzdG9yeVswXVtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHRoaXMudHVuZU9wdGlvbnMobyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zdGFydFR3ZWVuKCk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmNyZWF0ZVR3ZWVuID0gZnVuY3Rpb24oKSB7XG5cdCAgICB0aGlzLnR3ZWVuID0gbmV3IFR3ZWVuKHtcblx0ICAgICAgZHVyYXRpb246IHRoaXMucHJvcHMuZHVyYXRpb24sXG5cdCAgICAgIGRlbGF5OiB0aGlzLnByb3BzLmRlbGF5LFxuXHQgICAgICB5b3lvOiB0aGlzLnByb3BzLnlveW8sXG5cdCAgICAgIHJlcGVhdDogdGhpcy5wcm9wcy5yZXBlYXQsXG5cdCAgICAgIGVhc2luZzogdGhpcy5wcm9wcy5lYXNpbmcsXG5cdCAgICAgIG9uU3RhcnQ6IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgIHZhciByZWY7XG5cdCAgICAgICAgICByZXR1cm4gKHJlZiA9IF90aGlzLnByb3BzLm9uU3RhcnQpICE9IG51bGwgPyByZWYuYXBwbHkoX3RoaXMpIDogdm9pZCAwO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpLFxuXHQgICAgICBvbkNvbXBsZXRlOiAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB2YXIgcmVmO1xuXHQgICAgICAgICAgX3RoaXMucHJvcHMubW90aW9uQmx1ciAmJiBfdGhpcy5zZXRCbHVyKHtcblx0ICAgICAgICAgICAgYmx1cjoge1xuXHQgICAgICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICAgICAgeTogMFxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBvZmZzZXQ6IHtcblx0ICAgICAgICAgICAgICB4OiAwLFxuXHQgICAgICAgICAgICAgIHk6IDBcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICByZXR1cm4gKHJlZiA9IF90aGlzLnByb3BzLm9uQ29tcGxldGUpICE9IG51bGwgPyByZWYuYXBwbHkoX3RoaXMpIDogdm9pZCAwO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpLFxuXHQgICAgICBvblVwZGF0ZTogKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcblx0ICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRQcm9ncmVzcyhwKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9KSh0aGlzKSxcblx0ICAgICAgb25GaXJzdFVwZGF0ZTogKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGlzRm9yd2FyZCwgaXNZb3lvKSB7XG5cdCAgICAgICAgICBpZiAoIWlzRm9yd2FyZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGlzdG9yeS5sZW5ndGggPiAxICYmIF90aGlzLnR1bmVPcHRpb25zKF90aGlzLmhpc3RvcnlbMF0pO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpXG5cdCAgICB9KTtcblx0ICAgIHRoaXMudGltZWxpbmUgPSBuZXcgVGltZWxpbmU7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLnR3ZWVuKTtcblx0ICAgICF0aGlzLnByb3BzLmlzUnVuTGVzcyAmJiB0aGlzLnN0YXJ0VHdlZW4oKTtcblx0ICAgIHJldHVybiB0aGlzLnByb3BzLmlzUHJlc2V0UG9zaXRpb24gJiYgdGhpcy5zZXRQcm9ncmVzcygwLCB0cnVlKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuc3RhcnRUd2VlbiA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHNldFRpbWVvdXQoKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHJlZjtcblx0ICAgICAgICByZXR1cm4gKHJlZiA9IF90aGlzLnRpbWVsaW5lKSAhPSBudWxsID8gcmVmLnBsYXkoKSA6IHZvaWQgMDtcblx0ICAgICAgfTtcblx0ICAgIH0pKHRoaXMpKSwgMSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24ocCwgaXNJbml0KSB7XG5cdCAgICB2YXIgbGVuLCBwb2ludCwgeCwgeTtcblx0ICAgIGxlbiA9IHRoaXMuc3RhcnRMZW4gKyAoIXRoaXMucHJvcHMuaXNSZXZlcnNlID8gcCAqIHRoaXMuc2xpY2VkTGVuIDogKDEgLSBwKSAqIHRoaXMuc2xpY2VkTGVuKTtcblx0ICAgIHBvaW50ID0gdGhpcy5wYXRoLmdldFBvaW50QXRMZW5ndGgobGVuKTtcblx0ICAgIHggPSBwb2ludC54ICsgdGhpcy5wcm9wcy5vZmZzZXRYO1xuXHQgICAgeSA9IHBvaW50LnkgKyB0aGlzLnByb3BzLm9mZnNldFk7XG5cdCAgICB0aGlzLl9nZXRDdXJyZW50QW5nbGUocG9pbnQsIGxlbiwgcCk7XG5cdCAgICB0aGlzLl9zZXRUcmFuc2Zvcm1PcmlnaW4ocCk7XG5cdCAgICB0aGlzLl9zZXRUcmFuc2Zvcm0oeCwgeSwgcCwgaXNJbml0KTtcblx0ICAgIHJldHVybiB0aGlzLnByb3BzLm1vdGlvbkJsdXIgJiYgdGhpcy5tYWtlTW90aW9uQmx1cih4LCB5KTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuc2V0RWxQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHApIHtcblx0ICAgIHZhciBjb21wb3NpdGUsIGlzQ29tcG9zaXRlLCByb3RhdGUsIHRyYW5zZm9ybTtcblx0ICAgIHJvdGF0ZSA9IHRoaXMuYW5nbGUgIT09IDAgPyBcInJvdGF0ZShcIiArIHRoaXMuYW5nbGUgKyBcImRlZylcIiA6ICcnO1xuXHQgICAgaXNDb21wb3NpdGUgPSB0aGlzLnByb3BzLmlzQ29tcG9zaXRlTGF5ZXIgJiYgaC5pczNkO1xuXHQgICAgY29tcG9zaXRlID0gaXNDb21wb3NpdGUgPyAndHJhbnNsYXRlWigwKScgOiAnJztcblx0ICAgIHRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsXCIgKyB5ICsgXCJweCkgXCIgKyByb3RhdGUgKyBcIiBcIiArIGNvbXBvc2l0ZTtcblx0ICAgIHJldHVybiBoLnNldFByZWZpeGVkU3R5bGUodGhpcy5lbCwgJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnNldE1vZHVsZVBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgdGhpcy5lbC5fc2V0UHJvcCh7XG5cdCAgICAgIHNoaWZ0WDogeCArIFwicHhcIixcblx0ICAgICAgc2hpZnRZOiB5ICsgXCJweFwiLFxuXHQgICAgICBhbmdsZTogdGhpcy5hbmdsZVxuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gdGhpcy5lbC5fZHJhdygpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5fZ2V0Q3VycmVudEFuZ2xlID0gZnVuY3Rpb24ocG9pbnQsIGxlbiwgcCkge1xuXHQgICAgdmFyIGF0YW4sIGlzVHJhbnNmb3JtRnVuT3JpZ2luLCBwcmV2UG9pbnQsIHgxLCB4Mjtcblx0ICAgIGlzVHJhbnNmb3JtRnVuT3JpZ2luID0gdHlwZW9mIHRoaXMucHJvcHMudHJhbnNmb3JtT3JpZ2luID09PSAnZnVuY3Rpb24nO1xuXHQgICAgaWYgKHRoaXMucHJvcHMuaXNBbmdsZSB8fCAodGhpcy5wcm9wcy5hbmdsZU9mZnNldCAhPSBudWxsKSB8fCBpc1RyYW5zZm9ybUZ1bk9yaWdpbikge1xuXHQgICAgICBwcmV2UG9pbnQgPSB0aGlzLnBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW4gLSAxKTtcblx0ICAgICAgeDEgPSBwb2ludC55IC0gcHJldlBvaW50Lnk7XG5cdCAgICAgIHgyID0gcG9pbnQueCAtIHByZXZQb2ludC54O1xuXHQgICAgICBhdGFuID0gTWF0aC5hdGFuKHgxIC8geDIpO1xuXHQgICAgICAhaXNGaW5pdGUoYXRhbikgJiYgKGF0YW4gPSAwKTtcblx0ICAgICAgdGhpcy5hbmdsZSA9IGF0YW4gKiBoLlJBRF9UT19ERUc7XG5cdCAgICAgIGlmICgodHlwZW9mIHRoaXMucHJvcHMuYW5nbGVPZmZzZXQpICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGUgKz0gdGhpcy5wcm9wcy5hbmdsZU9mZnNldCB8fCAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmFuZ2xlID0gdGhpcy5wcm9wcy5hbmdsZU9mZnNldC5jYWxsKHRoaXMsIHRoaXMuYW5nbGUsIHApO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5hbmdsZSA9IDA7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBwLCBpc0luaXQpIHtcblx0ICAgIHZhciB0cmFuc2Zvcm07XG5cdCAgICBpZiAodGhpcy5zY2FsZXIpIHtcblx0ICAgICAgeCAqPSB0aGlzLnNjYWxlci54O1xuXHQgICAgICB5ICo9IHRoaXMuc2NhbGVyLnk7XG5cdCAgICB9XG5cdCAgICB0cmFuc2Zvcm0gPSBudWxsO1xuXHQgICAgaWYgKCFpc0luaXQpIHtcblx0ICAgICAgdHJhbnNmb3JtID0gdHlwZW9mIHRoaXMub25VcGRhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMub25VcGRhdGUocCwge1xuXHQgICAgICAgIHg6IHgsXG5cdCAgICAgICAgeTogeSxcblx0ICAgICAgICBhbmdsZTogdGhpcy5hbmdsZVxuXHQgICAgICB9KSA6IHZvaWQgMDtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLmlzTW9kdWxlKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnNldE1vZHVsZVBvc2l0aW9uKHgsIHkpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc2V0RWxQb3NpdGlvbih4LCB5LCBwKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gaC5zZXRQcmVmaXhlZFN0eWxlKHRoaXMuZWwsICd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLl9zZXRUcmFuc2Zvcm1PcmlnaW4gPSBmdW5jdGlvbihwKSB7XG5cdCAgICB2YXIgaXNUcmFuc2Zvcm1GdW5PcmlnaW4sIHRPcmlnaW47XG5cdCAgICBpZiAodGhpcy5wcm9wcy50cmFuc2Zvcm1PcmlnaW4pIHtcblx0ICAgICAgaXNUcmFuc2Zvcm1GdW5PcmlnaW4gPSB0eXBlb2YgdGhpcy5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gPT09ICdmdW5jdGlvbic7XG5cdCAgICAgIHRPcmlnaW4gPSAhaXNUcmFuc2Zvcm1GdW5PcmlnaW4gPyB0aGlzLnByb3BzLnRyYW5zZm9ybU9yaWdpbiA6IHRoaXMucHJvcHMudHJhbnNmb3JtT3JpZ2luKHRoaXMuYW5nbGUsIHApO1xuXHQgICAgICByZXR1cm4gaC5zZXRQcmVmaXhlZFN0eWxlKHRoaXMuZWwsICd0cmFuc2Zvcm0tb3JpZ2luJywgdE9yaWdpbik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLm1ha2VNb3Rpb25CbHVyID0gZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgdmFyIGFic29sdXRlQW5nbGUsIGNvb3JkcywgZFgsIGRZLCBzaWduWCwgc2lnblksIHRhaWxBbmdsZTtcblx0ICAgIHRhaWxBbmdsZSA9IDA7XG5cdCAgICBzaWduWCA9IDE7XG5cdCAgICBzaWduWSA9IDE7XG5cdCAgICBpZiAoKHRoaXMucHJldkNvb3Jkcy54ID09IG51bGwpIHx8ICh0aGlzLnByZXZDb29yZHMueSA9PSBudWxsKSkge1xuXHQgICAgICB0aGlzLnNwZWVkWCA9IDA7XG5cdCAgICAgIHRoaXMuc3BlZWRZID0gMDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRYID0geCAtIHRoaXMucHJldkNvb3Jkcy54O1xuXHQgICAgICBkWSA9IHkgLSB0aGlzLnByZXZDb29yZHMueTtcblx0ICAgICAgaWYgKGRYID4gMCkge1xuXHQgICAgICAgIHNpZ25YID0gLTE7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHNpZ25YIDwgMCkge1xuXHQgICAgICAgIHNpZ25ZID0gLTE7XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy5zcGVlZFggPSBNYXRoLmFicyhkWCk7XG5cdCAgICAgIHRoaXMuc3BlZWRZID0gTWF0aC5hYnMoZFkpO1xuXHQgICAgICB0YWlsQW5nbGUgPSBNYXRoLmF0YW4oZFkgLyBkWCkgKiAoMTgwIC8gTWF0aC5QSSkgKyA5MDtcblx0ICAgIH1cblx0ICAgIGFic29sdXRlQW5nbGUgPSB0YWlsQW5nbGUgLSB0aGlzLmFuZ2xlO1xuXHQgICAgY29vcmRzID0gdGhpcy5hbmdUb0Nvb3JkcyhhYnNvbHV0ZUFuZ2xlKTtcblx0ICAgIHRoaXMuYmx1clggPSBoLmNsYW1wKCh0aGlzLnNwZWVkWCAvIDE2KSAqIHRoaXMucHJvcHMubW90aW9uQmx1ciwgMCwgMSk7XG5cdCAgICB0aGlzLmJsdXJZID0gaC5jbGFtcCgodGhpcy5zcGVlZFkgLyAxNikgKiB0aGlzLnByb3BzLm1vdGlvbkJsdXIsIDAsIDEpO1xuXHQgICAgdGhpcy5zZXRCbHVyKHtcblx0ICAgICAgYmx1cjoge1xuXHQgICAgICAgIHg6IDMgKiB0aGlzLmJsdXJYICogdGhpcy5ibHVyQW1vdW50ICogTWF0aC5hYnMoY29vcmRzLngpLFxuXHQgICAgICAgIHk6IDMgKiB0aGlzLmJsdXJZICogdGhpcy5ibHVyQW1vdW50ICogTWF0aC5hYnMoY29vcmRzLnkpXG5cdCAgICAgIH0sXG5cdCAgICAgIG9mZnNldDoge1xuXHQgICAgICAgIHg6IDMgKiBzaWduWCAqIHRoaXMuYmx1clggKiBjb29yZHMueCAqIHRoaXMuYmx1ckFtb3VudCxcblx0ICAgICAgICB5OiAzICogc2lnblkgKiB0aGlzLmJsdXJZICogY29vcmRzLnkgKiB0aGlzLmJsdXJBbW91bnRcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB0aGlzLnByZXZDb29yZHMueCA9IHg7XG5cdCAgICByZXR1cm4gdGhpcy5wcmV2Q29vcmRzLnkgPSB5O1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5zZXRCbHVyID0gZnVuY3Rpb24obykge1xuXHQgICAgaWYgKCF0aGlzLmlzTW90aW9uQmx1clJlc2V0KSB7XG5cdCAgICAgIHRoaXMuZmlsdGVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgby5ibHVyLnggKyBcIixcIiArIG8uYmx1ci55KTtcblx0ICAgICAgdGhpcy5maWx0ZXJPZmZzZXQuc2V0QXR0cmlidXRlKCdkeCcsIG8ub2Zmc2V0LngpO1xuXHQgICAgICByZXR1cm4gdGhpcy5maWx0ZXJPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsIG8ub2Zmc2V0LnkpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBrZXksIHJlc3VsdHMsIHZhbHVlO1xuXHQgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgZm9yIChrZXkgaW4gbykge1xuXHQgICAgICB2YWx1ZSA9IG9ba2V5XTtcblx0ICAgICAgcmVzdWx0cy5wdXNoKHRoaXNba2V5XSA9IHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5leHRlbmRPcHRpb25zID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGtleSwgcmVzdWx0cywgdmFsdWU7XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICBmb3IgKGtleSBpbiBvKSB7XG5cdCAgICAgIHZhbHVlID0gb1trZXldO1xuXHQgICAgICByZXN1bHRzLnB1c2godGhpcy5wcm9wc1trZXldID0gdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvKSB7XG5cdCAgICB2YXIgaXQsIGtleSwgb3B0cywgcHJldk9wdGlvbnMsIHZhbHVlO1xuXHQgICAgcHJldk9wdGlvbnMgPSB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdO1xuXHQgICAgb3B0cyA9IHt9O1xuXHQgICAgZm9yIChrZXkgaW4gcHJldk9wdGlvbnMpIHtcblx0ICAgICAgdmFsdWUgPSBwcmV2T3B0aW9uc1trZXldO1xuXHQgICAgICBpZiAoIWguY2FsbGJhY2tzTWFwW2tleV0gJiYgIWgudHdlZW5PcHRpb25NYXBba2V5XSB8fCBrZXkgPT09ICdkdXJhdGlvbicpIHtcblx0ICAgICAgICBpZiAob1trZXldID09IG51bGwpIHtcblx0ICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAob1trZXldID09IG51bGwpIHtcblx0ICAgICAgICAgIG9ba2V5XSA9IHZvaWQgMDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKGgudHdlZW5PcHRpb25NYXBba2V5XSkge1xuXHQgICAgICAgIG9wdHNba2V5XSA9IGtleSAhPT0gJ2R1cmF0aW9uJyA/IG9ba2V5XSA6IG9ba2V5XSAhPSBudWxsID8gb1trZXldIDogcHJldk9wdGlvbnNba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgdGhpcy5oaXN0b3J5LnB1c2gobyk7XG5cdCAgICBpdCA9IHRoaXM7XG5cdCAgICBvcHRzLm9uVXBkYXRlID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzLnNldFByb2dyZXNzKHApO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcyk7XG5cdCAgICBvcHRzLm9uU3RhcnQgPSAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciByZWY7XG5cdCAgICAgICAgcmV0dXJuIChyZWYgPSBfdGhpcy5wcm9wcy5vblN0YXJ0KSAhPSBudWxsID8gcmVmLmFwcGx5KF90aGlzKSA6IHZvaWQgMDtcblx0ICAgICAgfTtcblx0ICAgIH0pKHRoaXMpO1xuXHQgICAgb3B0cy5vbkNvbXBsZXRlID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgcmVmO1xuXHQgICAgICAgIHJldHVybiAocmVmID0gX3RoaXMucHJvcHMub25Db21wbGV0ZSkgIT0gbnVsbCA/IHJlZi5hcHBseShfdGhpcykgOiB2b2lkIDA7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKTtcblx0ICAgIG9wdHMub25GaXJzdFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICByZXR1cm4gaXQudHVuZU9wdGlvbnMoaXQuaGlzdG9yeVt0aGlzLmluZGV4XSk7XG5cdCAgICB9O1xuXHQgICAgb3B0cy5pc0NoYWluZWQgPSAhby5kZWxheTtcblx0ICAgIHRoaXMudGltZWxpbmUuYXBwZW5kKG5ldyBUd2VlbihvcHRzKSk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUudHVuZU9wdGlvbnMgPSBmdW5jdGlvbihvKSB7XG5cdCAgICB0aGlzLmV4dGVuZE9wdGlvbnMobyk7XG5cdCAgICByZXR1cm4gdGhpcy5wb3N0VmFycygpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5hbmdUb0Nvb3JkcyA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cdCAgICB2YXIgcmFkQW5nbGUsIHgsIHk7XG5cdCAgICBhbmdsZSA9IGFuZ2xlICUgMzYwO1xuXHQgICAgcmFkQW5nbGUgPSAoKGFuZ2xlIC0gOTApICogTWF0aC5QSSkgLyAxODA7XG5cdCAgICB4ID0gTWF0aC5jb3MocmFkQW5nbGUpO1xuXHQgICAgeSA9IE1hdGguc2luKHJhZEFuZ2xlKTtcblx0ICAgIHggPSB4IDwgMCA/IE1hdGgubWF4KHgsIC0wLjcpIDogTWF0aC5taW4oeCwgLjcpO1xuXHQgICAgeSA9IHkgPCAwID8gTWF0aC5tYXgoeSwgLTAuNykgOiBNYXRoLm1pbih5LCAuNyk7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICB4OiB4ICogMS40Mjg1NzE0MjksXG5cdCAgICAgIHk6IHkgKiAxLjQyODU3MTQyOVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIE1vdGlvblBhdGg7XG5cblx0fSkoKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IE1vdGlvblBhdGg7XG5cblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XG5cdC8qIVxuXHQgIExlZ29NdXNocm9vbSBAbGVnb211c2hyb29tIGh0dHA6Ly9sZWdvbXVzaHJvb20uY29tXG5cdCAgTUlUIExpY2Vuc2UgMjAxNFxuXHQgKi9cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHQoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIE1haW47XG5cdCAgTWFpbiA9IChmdW5jdGlvbigpIHtcblx0ICAgIGZ1bmN0aW9uIE1haW4obykge1xuXHQgICAgICB0aGlzLm8gPSBvICE9IG51bGwgPyBvIDoge307XG5cdCAgICAgIGlmICh3aW5kb3cuaXNBbnlSZXNpemVFdmVudEluaXRlZCkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLnZhcnMoKTtcblx0ICAgICAgdGhpcy5yZWRlZmluZVByb3RvKCk7XG5cdCAgICB9XG5cblx0ICAgIE1haW4ucHJvdG90eXBlLnZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgd2luZG93LmlzQW55UmVzaXplRXZlbnRJbml0ZWQgPSB0cnVlO1xuXHQgICAgICB0aGlzLmFsbG93ZWRQcm90b3MgPSBbSFRNTERpdkVsZW1lbnQsIEhUTUxGb3JtRWxlbWVudCwgSFRNTExpbmtFbGVtZW50LCBIVE1MQm9keUVsZW1lbnQsIEhUTUxQYXJhZ3JhcGhFbGVtZW50LCBIVE1MRmllbGRTZXRFbGVtZW50LCBIVE1MTGVnZW5kRWxlbWVudCwgSFRNTExhYmVsRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQsIEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxPTGlzdEVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIEhUTUxIZWFkaW5nRWxlbWVudCwgSFRNTFF1b3RlRWxlbWVudCwgSFRNTFByZUVsZW1lbnQsIEhUTUxCUkVsZW1lbnQsIEhUTUxGb250RWxlbWVudCwgSFRNTEhSRWxlbWVudCwgSFRNTE1vZEVsZW1lbnQsIEhUTUxQYXJhbUVsZW1lbnQsIEhUTUxNYXBFbGVtZW50LCBIVE1MVGFibGVFbGVtZW50LCBIVE1MVGFibGVDYXB0aW9uRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTFRhYmxlQ2VsbEVsZW1lbnQsIEhUTUxTZWxlY3RFbGVtZW50LCBIVE1MSW5wdXRFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50LCBIVE1MQW5jaG9yRWxlbWVudCwgSFRNTE9iamVjdEVsZW1lbnQsIEhUTUxUYWJsZUNvbEVsZW1lbnQsIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBIVE1MVGFibGVSb3dFbGVtZW50XTtcblx0ICAgICAgcmV0dXJuIHRoaXMudGltZXJFbGVtZW50cyA9IHtcblx0ICAgICAgICBpbWc6IDEsXG5cdCAgICAgICAgdGV4dGFyZWE6IDEsXG5cdCAgICAgICAgaW5wdXQ6IDEsXG5cdCAgICAgICAgZW1iZWQ6IDEsXG5cdCAgICAgICAgb2JqZWN0OiAxLFxuXHQgICAgICAgIHN2ZzogMSxcblx0ICAgICAgICBjYW52YXM6IDEsXG5cdCAgICAgICAgdHI6IDEsXG5cdCAgICAgICAgdGJvZHk6IDEsXG5cdCAgICAgICAgdGhlYWQ6IDEsXG5cdCAgICAgICAgdGZvb3Q6IDEsXG5cdCAgICAgICAgYTogMSxcblx0ICAgICAgICBzZWxlY3Q6IDEsXG5cdCAgICAgICAgb3B0aW9uOiAxLFxuXHQgICAgICAgIG9wdGdyb3VwOiAxLFxuXHQgICAgICAgIGRsOiAxLFxuXHQgICAgICAgIGR0OiAxLFxuXHQgICAgICAgIGJyOiAxLFxuXHQgICAgICAgIGJhc2Vmb250OiAxLFxuXHQgICAgICAgIGZvbnQ6IDEsXG5cdCAgICAgICAgY29sOiAxLFxuXHQgICAgICAgIGlmcmFtZTogMVxuXHQgICAgICB9O1xuXHQgICAgfTtcblxuXHQgICAgTWFpbi5wcm90b3R5cGUucmVkZWZpbmVQcm90byA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgaSwgaXQsIHByb3RvLCB0O1xuXHQgICAgICBpdCA9IHRoaXM7XG5cdCAgICAgIHJldHVybiB0ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciBqLCBsZW4sIHJlZiwgcmVzdWx0cztcblx0ICAgICAgICByZWYgPSB0aGlzLmFsbG93ZWRQcm90b3M7XG5cdCAgICAgICAgcmVzdWx0cyA9IFtdO1xuXHQgICAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG5cdCAgICAgICAgICBwcm90byA9IHJlZltpXTtcblx0ICAgICAgICAgIGlmIChwcm90by5wcm90b3R5cGUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIHJlc3VsdHMucHVzaCgoZnVuY3Rpb24ocHJvdG8pIHtcblx0ICAgICAgICAgICAgdmFyIGxpc3RlbmVyLCByZW1vdmVyO1xuXHQgICAgICAgICAgICBsaXN0ZW5lciA9IHByb3RvLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyIHx8IHByb3RvLnByb3RvdHlwZS5hdHRhY2hFdmVudDtcblx0ICAgICAgICAgICAgKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgdmFyIHdyYXBwZWRMaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICB3cmFwcGVkTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcHRpb247XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcyAhPT0gd2luZG93IHx8IHRoaXMgIT09IGRvY3VtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IGFyZ3VtZW50c1swXSA9PT0gJ29ucmVzaXplJyAmJiAhdGhpcy5pc0FueVJlc2l6ZUV2ZW50SW5pdGVkO1xuXHQgICAgICAgICAgICAgICAgICBvcHRpb24gJiYgaXQuaGFuZGxlUmVzaXplKHtcblx0ICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmd1bWVudHMsXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdDogdGhpc1xuXHQgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgaWYgKHByb3RvLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSB3cmFwcGVkTGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQgPSB3cmFwcGVkTGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KShsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgIHJlbW92ZXIgPSBwcm90by5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciB8fCBwcm90by5wcm90b3R5cGUuZGV0YWNoRXZlbnQ7XG5cdCAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24ocmVtb3Zlcikge1xuXHQgICAgICAgICAgICAgIHZhciB3cmFwcGVkUmVtb3Zlcjtcblx0ICAgICAgICAgICAgICB3cmFwcGVkUmVtb3ZlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pc0FueVJlc2l6ZUV2ZW50SW5pdGVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZSAmJiB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuaWZyYW1lKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm90by5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHdyYXBwZWRSZW1vdmVyO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG8ucHJvdG90eXBlLmRldGFjaEV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLmRldGFjaEV2ZW50ID0gd3JhcHBlZExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkocmVtb3Zlcik7XG5cdCAgICAgICAgICB9KShwcm90bykpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0cztcblx0ICAgICAgfSkuY2FsbCh0aGlzKTtcblx0ICAgIH07XG5cblx0ICAgIE1haW4ucHJvdG90eXBlLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0ICAgICAgdmFyIGNvbXB1dGVkU3R5bGUsIGVsLCBpZnJhbWUsIGlzRW1wdHksIGlzTm9Qb3MsIGlzU3RhdGljLCByZWY7XG5cdCAgICAgIGVsID0gYXJncy50aGF0O1xuXHQgICAgICBpZiAoIXRoaXMudGltZXJFbGVtZW50c1tlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCldKSB7XG5cdCAgICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdCAgICAgICAgZWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0ICAgICAgICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblx0ICAgICAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgICAgIGlmcmFtZS5zdHlsZS56SW5kZXggPSAtOTk5O1xuXHQgICAgICAgIGlmcmFtZS5zdHlsZS5vcGFjaXR5ID0gMDtcblx0ICAgICAgICBpZnJhbWUuc3R5bGUudG9wID0gMDtcblx0ICAgICAgICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG5cdCAgICAgICAgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShlbCkgOiBlbC5jdXJyZW50U3R5bGU7XG5cdCAgICAgICAgaXNOb1BvcyA9IGVsLnN0eWxlLnBvc2l0aW9uID09PSAnJztcblx0ICAgICAgICBpc1N0YXRpYyA9IGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmIGlzTm9Qb3M7XG5cdCAgICAgICAgaXNFbXB0eSA9IGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICcnICYmIGVsLnN0eWxlLnBvc2l0aW9uID09PSAnJztcblx0ICAgICAgICBpZiAoaXNTdGF0aWMgfHwgaXNFbXB0eSkge1xuXHQgICAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoKHJlZiA9IGlmcmFtZS5jb250ZW50V2luZG93KSAhPSBudWxsKSB7XG5cdCAgICAgICAgICByZWYub25yZXNpemUgPSAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGlzcGF0Y2hFdmVudChlbCk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICB9KSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWwuaWZyYW1lID0gaWZyYW1lO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuaW5pdFRpbWVyKGVsKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZWwuaXNBbnlSZXNpemVFdmVudEluaXRlZCA9IHRydWU7XG5cdCAgICB9O1xuXG5cdCAgICBNYWluLnByb3RvdHlwZS5pbml0VGltZXIgPSBmdW5jdGlvbihlbCkge1xuXHQgICAgICB2YXIgaGVpZ2h0LCB3aWR0aDtcblx0ICAgICAgd2lkdGggPSAwO1xuXHQgICAgICBoZWlnaHQgPSAwO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgIHZhciBuZXdIZWlnaHQsIG5ld1dpZHRoO1xuXHQgICAgICAgICAgbmV3V2lkdGggPSBlbC5vZmZzZXRXaWR0aDtcblx0ICAgICAgICAgIG5ld0hlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcblx0ICAgICAgICAgIGlmIChuZXdXaWR0aCAhPT0gd2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBoZWlnaHQpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hFdmVudChlbCk7XG5cdCAgICAgICAgICAgIHdpZHRoID0gbmV3V2lkdGg7XG5cdCAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcyksIHRoaXMuby5pbnRlcnZhbCB8fCA2Mi41KTtcblx0ICAgIH07XG5cblx0ICAgIE1haW4ucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihlbCkge1xuXHQgICAgICB2YXIgZTtcblx0ICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG5cdCAgICAgICAgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG5cdCAgICAgICAgZS5pbml0RXZlbnQoJ29ucmVzaXplJywgZmFsc2UsIGZhbHNlKTtcblx0ICAgICAgICByZXR1cm4gZWwuZGlzcGF0Y2hFdmVudChlKTtcblx0ICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCkge1xuXHQgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuXHQgICAgICAgIHJldHVybiBlbC5maXJlRXZlbnQoJ29ucmVzaXplJywgZSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBNYWluLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBpLCBpdCwgaiwgbGVuLCBwcm90bywgcmVmLCByZXN1bHRzO1xuXHQgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuXHQgICAgICB0aGlzLmludGVydmFsID0gbnVsbDtcblx0ICAgICAgd2luZG93LmlzQW55UmVzaXplRXZlbnRJbml0ZWQgPSBmYWxzZTtcblx0ICAgICAgaXQgPSB0aGlzO1xuXHQgICAgICByZWYgPSB0aGlzLmFsbG93ZWRQcm90b3M7XG5cdCAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgZm9yIChpID0gaiA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGogPCBsZW47IGkgPSArK2opIHtcblx0ICAgICAgICBwcm90byA9IHJlZltpXTtcblx0ICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlID09IG51bGwpIHtcblx0ICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHRzLnB1c2goKGZ1bmN0aW9uKHByb3RvKSB7XG5cdCAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICBsaXN0ZW5lciA9IHByb3RvLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyIHx8IHByb3RvLnByb3RvdHlwZS5hdHRhY2hFdmVudDtcblx0ICAgICAgICAgIGlmIChwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICBwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IEVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5cdCAgICAgICAgICB9IGVsc2UgaWYgKHByb3RvLnByb3RvdHlwZS5hdHRhY2hFdmVudCkge1xuXHQgICAgICAgICAgICBwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQgPSBFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hFdmVudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICAgIGlmIChwcm90by5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChwcm90by5wcm90b3R5cGUuZGV0YWNoRXZlbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5kZXRhY2hFdmVudCA9IEVsZW1lbnQucHJvdG90eXBlLmRldGFjaEV2ZW50O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0pKHByb3RvKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICB9O1xuXG5cdCAgICByZXR1cm4gTWFpbjtcblxuXHQgIH0pKCk7XG5cdCAgaWYgKHRydWUpIHtcblx0ICAgIHJldHVybiAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBNYWluO1xuXHQgICAgfS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHQgIH0gZWxzZSBpZiAoKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpICYmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpKSB7XG5cdCAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBuZXcgTWFpbjtcblx0ICB9IGVsc2Uge1xuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG5cdCAgICAgIHdpbmRvdy5BbnlSZXNpemVFdmVudCA9IE1haW47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwgPyB3aW5kb3cuYW55UmVzaXplRXZlbnQgPSBuZXcgTWFpbiA6IHZvaWQgMDtcblx0ICB9XG5cdH0pKCk7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pXG59KTtcbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tby1qcy9idWlsZC9tby5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports) {

eval("(function () {\n\n    function Animocon(el, options) {\n        this.el = el;\n        this.options = extend({}, this.options);\n        extend(this.options, options);\n\n        this.checked = false;\n\n        this.timeline = new mojs.Timeline();\n\n        for (var i = 0, len = this.options.tweens.length; i < len; ++i) {\n            this.timeline.add(this.options.tweens[i]);\n        }\n\n        var self = this;\n        this.el.addEventListener(clickHandler, function () {\n            if (self.checked) {\n                self.options.onUnCheck();\n            } else {\n                self.options.onCheck();\n                self.timeline.replay();\n            }\n            self.checked = !self.checked;\n        });\n    }\n\n    Animocon.prototype.options = {\n        tweens: [new mojs.Burst({})],\n        onCheck: function onCheck() {\n            return false;\n        },\n        onUnCheck: function onUnCheck() {\n            return false;\n        }\n    };\n\n    // bursts when hovering the .special-link link\n    var molinkEl = document.querySelector('.special-link');\n    if (molinkEl) {\n        var moTimeline = new mojs.Timeline(),\n            moburst1 = new mojs.Burst({\n            parent: molinkEl,\n            count: 6,\n            left: '0%',\n            top: '-20%',\n            radius: { 0: 60 },\n            children: {\n                fill: ['#988ADE', '#DE8AA0', '#8AAEDE', '#8ADEAD', '#DEC58A', '#8AD1DE'],\n                duration: 1300,\n                easing: mojs.easing.bezier(0.1, 1, 0.3, 1)\n            }\n        }),\n            moburst2 = new mojs.Burst({\n            parent: molinkEl,\n            left: '-100%', top: '-20%',\n            count: 14,\n            radius: { 0: 120 },\n            children: {\n                fill: ['#988ADE', '#DE8AA0', '#8AAEDE', '#8ADEAD', '#DEC58A', '#8AD1DE'],\n                duration: 1600,\n                delay: 100,\n                easing: mojs.easing.bezier(0.1, 1, 0.3, 1)\n            }\n        }),\n            moburst3 = new mojs.Burst({\n            parent: molinkEl,\n            left: '130%', top: '70%',\n            count: 8,\n            radius: { 0: 90 },\n            children: {\n                fill: ['#988ADE', '#DE8AA0', '#8AAEDE', '#8ADEAD', '#DEC58A', '#8AD1DE'],\n                duration: 1500,\n                delay: 200,\n                easing: mojs.easing.bezier(0.1, 1, 0.3, 1)\n            }\n        }),\n            moburst4 = new mojs.Burst({\n            parent: molinkEl,\n            left: '-20%', top: '-150%',\n            count: 14,\n            radius: { 0: 60 },\n            children: {\n                fill: ['#988ADE', '#DE8AA0', '#8AAEDE', '#8ADEAD', '#DEC58A', '#8AD1DE'],\n                duration: 2000,\n                delay: 300,\n                easing: mojs.easing.bezier(0.1, 1, 0.3, 1)\n            }\n        }),\n            moburst5 = new mojs.Burst({\n            parent: molinkEl,\n            count: 12,\n            left: '30%', top: '100%',\n            radius: { 0: 60 },\n            children: {\n                fill: ['#988ADE', '#DE8AA0', '#8AAEDE', '#8ADEAD', '#DEC58A', '#8AD1DE'],\n                duration: 1400,\n                delay: 400,\n                easing: mojs.easing.bezier(0.1, 1, 0.3, 1)\n            }\n        });\n        moTimeline.add(moburst1, moburst2, moburst3, moburst4, moburst5);\n        molinkEl.addEventListener('mouseenter', function () {\n            moTimeline.replay();\n        });\n    }\n})(window, mojs);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FuaW1hdGlvbi5qcz8wMWYxIl0sIm5hbWVzIjpbIkFuaW1vY29uIiwiZWwiLCJvcHRpb25zIiwiZXh0ZW5kIiwiY2hlY2tlZCIsInRpbWVsaW5lIiwibW9qcyIsIlRpbWVsaW5lIiwiaSIsImxlbiIsInR3ZWVucyIsImxlbmd0aCIsImFkZCIsInNlbGYiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xpY2tIYW5kbGVyIiwib25VbkNoZWNrIiwib25DaGVjayIsInJlcGxheSIsInByb3RvdHlwZSIsIkJ1cnN0IiwibW9saW5rRWwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtb1RpbWVsaW5lIiwibW9idXJzdDEiLCJwYXJlbnQiLCJjb3VudCIsImxlZnQiLCJ0b3AiLCJyYWRpdXMiLCJjaGlsZHJlbiIsImZpbGwiLCJkdXJhdGlvbiIsImVhc2luZyIsImJlemllciIsIm1vYnVyc3QyIiwiZGVsYXkiLCJtb2J1cnN0MyIsIm1vYnVyc3Q0IiwibW9idXJzdDUiLCJ3aW5kb3ciXSwibWFwcGluZ3MiOiJBQUFBLENBQUMsWUFBVTs7QUFFVixhQUFTQSxRQUFULENBQWtCQyxFQUFsQixFQUFzQkMsT0FBdEIsRUFBK0I7QUFDOUIsYUFBS0QsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsYUFBS0MsT0FBTCxHQUFlQyxPQUFRLEVBQVIsRUFBWSxLQUFLRCxPQUFqQixDQUFmO0FBQ0FDLGVBQVEsS0FBS0QsT0FBYixFQUFzQkEsT0FBdEI7O0FBRUEsYUFBS0UsT0FBTCxHQUFlLEtBQWY7O0FBRUEsYUFBS0MsUUFBTCxHQUFnQixJQUFJQyxLQUFLQyxRQUFULEVBQWhCOztBQUVBLGFBQUksSUFBSUMsSUFBSSxDQUFSLEVBQVdDLE1BQU0sS0FBS1AsT0FBTCxDQUFhUSxNQUFiLENBQW9CQyxNQUF6QyxFQUFpREgsSUFBSUMsR0FBckQsRUFBMEQsRUFBRUQsQ0FBNUQsRUFBK0Q7QUFDOUQsaUJBQUtILFFBQUwsQ0FB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R0d1QixNQTNHSCxFQTJHV25DLElBM0dYIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XHJcblxyXG5cdGZ1bmN0aW9uIEFuaW1vY29uKGVsLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLmVsID0gZWw7XHJcblx0XHR0aGlzLm9wdGlvbnMgPSBleHRlbmQoIHt9LCB0aGlzLm9wdGlvbnMgKTtcclxuXHRcdGV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRpb25zICk7XHJcblxyXG5cdFx0dGhpcy5jaGVja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy50aW1lbGluZSA9IG5ldyBtb2pzLlRpbWVsaW5lKCk7XHJcblx0XHRcclxuXHRcdGZvcih2YXIgaSA9IDAsIGxlbiA9IHRoaXMub3B0aW9ucy50d2VlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuXHRcdFx0dGhpcy50aW1lbGluZS5hZGQodGhpcy5vcHRpb25zLnR3ZWVuc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0dGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKGNsaWNrSGFuZGxlciwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKCBzZWxmLmNoZWNrZWQgKSB7XHJcblx0XHRcdFx0c2VsZi5vcHRpb25zLm9uVW5DaGVjaygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHNlbGYub3B0aW9ucy5vbkNoZWNrKCk7XHJcblx0XHRcdFx0c2VsZi50aW1lbGluZS5yZXBsYXkoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzZWxmLmNoZWNrZWQgPSAhc2VsZi5jaGVja2VkO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRBbmltb2Nvbi5wcm90b3R5cGUub3B0aW9ucyA9IHtcclxuXHRcdHR3ZWVucyA6IFtcclxuXHRcdFx0bmV3IG1vanMuQnVyc3Qoe30pXHJcblx0XHRdLFxyXG5cdFx0b25DaGVjayA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXHJcblx0XHRvblVuQ2hlY2sgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBcclxuICAgIC8vIGJ1cnN0cyB3aGVuIGhvdmVyaW5nIHRoZSAuc3BlY2lhbC1saW5rIGxpbmtcclxuICAgIHZhciBtb2xpbmtFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcGVjaWFsLWxpbmsnKVxyXG4gICAgaWYgKG1vbGlua0VsKSB7XHJcbiAgICAgICAgdmFyIG1vVGltZWxpbmUgPSBuZXcgbW9qcy5UaW1lbGluZSgpLFxyXG4gICAgICAgIG1vYnVyc3QxID0gbmV3IG1vanMuQnVyc3Qoe1xyXG4gICAgICAgICAgICBwYXJlbnQ6IFx0XHRcdG1vbGlua0VsLFxyXG4gICAgICAgICAgICBjb3VudDogXHRcdFx0XHQ2LFxyXG4gICAgICAgICAgICBsZWZ0OiBcdFx0XHRcdCcwJScsXHJcbiAgICAgICAgICAgIHRvcDogIFx0XHRcdFx0Jy0yMCUnLFxyXG4gICAgICAgICAgICByYWRpdXM6IFx0XHRcdHswOjYwfSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IHtcclxuICAgICAgICAgICAgICAgIGZpbGwgOiBcdFx0XHRbICcjOTg4QURFJywgJyNERThBQTAnLCAnIzhBQUVERScsICcjOEFERUFEJywgJyNERUM1OEEnLCAnIzhBRDFERScgXSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBcdDEzMDAsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmc6IFx0XHRtb2pzLmVhc2luZy5iZXppZXIoMC4xLCAxLCAwLjMsIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBtb2J1cnN0MiA9IG5ldyBtb2pzLkJ1cnN0KHtcclxuICAgICAgICAgICAgcGFyZW50OiBcdG1vbGlua0VsLFxyXG4gICAgICAgICAgICBsZWZ0OiAnLTEwMCUnLCB0b3A6ICctMjAlJyxcclxuICAgICAgICAgICAgY291bnQ6IFx0XHQxNCxcclxuICAgICAgICAgICAgcmFkaXVzOiBcdFx0ezA6MTIwfSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFx0XHRcdFsgJyM5ODhBREUnLCAnI0RFOEFBMCcsICcjOEFBRURFJywgJyM4QURFQUQnLCAnI0RFQzU4QScsICcjOEFEMURFJyBdLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IFx0MTYwMCxcclxuICAgICAgICAgICAgICAgIGRlbGF5OiBcdFx0XHQxMDAsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmc6IFx0XHRtb2pzLmVhc2luZy5iZXppZXIoMC4xLCAxLCAwLjMsIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBtb2J1cnN0MyA9IG5ldyBtb2pzLkJ1cnN0KHtcclxuICAgICAgICAgICAgcGFyZW50OiBcdFx0XHRtb2xpbmtFbCxcclxuICAgICAgICAgICAgbGVmdDogJzEzMCUnLCB0b3A6ICc3MCUnLFxyXG4gICAgICAgICAgICBjb3VudDogXHRcdFx0XHQ4LFxyXG4gICAgICAgICAgICByYWRpdXM6IFx0XHRcdHswOjkwfSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IHtcclxuICAgICAgICAgICAgICAgIGZpbGw6IFx0XHRcdFsgJyM5ODhBREUnLCAnI0RFOEFBMCcsICcjOEFBRURFJywgJyM4QURFQUQnLCAnI0RFQzU4QScsICcjOEFEMURFJyBdLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IFx0MTUwMCxcclxuICAgICAgICAgICAgICAgIGRlbGF5OiBcdFx0XHQyMDAsXHJcbiAgICAgICAgICAgICAgICBlYXNpbmc6IFx0XHRtb2pzLmVhc2luZy5iZXppZXIoMC4xLCAxLCAwLjMsIDEpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBtb2J1cnN0NCA9IG5ldyBtb2pzLkJ1cnN0KHtcclxuICAgICAgICAgICAgcGFyZW50OiBtb2xpbmtFbCxcclxuICAgICAgICAgICAgbGVmdDogJy0yMCUnLCB0b3A6ICctMTUwJScsXHJcbiAgICAgICAgICAgIGNvdW50OiBcdFx0MTQsXHJcbiAgICAgICAgICAgIHJhZGl1czogXHR7MDo2MH0sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcdFx0XHRbICcjOTg4QURFJywgJyNERThBQTAnLCAnIzhBQUVERScsICcjOEFERUFEJywgJyNERUM1OEEnLCAnIzhBRDFERScgXSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBcdDIwMDAsXHJcbiAgICAgICAgICAgICAgICBkZWxheTogXHRcdFx0MzAwLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBcdFx0bW9qcy5lYXNpbmcuYmV6aWVyKDAuMSwgMSwgMC4zLCAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgbW9idXJzdDUgPSBuZXcgbW9qcy5CdXJzdCh7XHJcbiAgICAgICAgICAgIHBhcmVudDogXHRtb2xpbmtFbCxcclxuICAgICAgICAgICAgY291bnQ6IFx0XHQxMixcclxuICAgICAgICAgICAgbGVmdDogJzMwJScsIHRvcDogJzEwMCUnLFxyXG4gICAgICAgICAgICByYWRpdXM6IFx0XHR7MDo2MH0sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBcdFx0XHRbICcjOTg4QURFJywgJyNERThBQTAnLCAnIzhBQUVERScsICcjOEFERUFEJywgJyNERUM1OEEnLCAnIzhBRDFERScgXSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBcdDE0MDAsXHJcbiAgICAgICAgICAgICAgICBkZWxheTogXHRcdFx0NDAwLFxyXG4gICAgICAgICAgICAgICAgZWFzaW5nOiBcdFx0bW9qcy5lYXNpbmcuYmV6aWVyKDAuMSwgMSwgMC4zLCAxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbW9UaW1lbGluZS5hZGQobW9idXJzdDEsIG1vYnVyc3QyLCBtb2J1cnN0MywgbW9idXJzdDQsIG1vYnVyc3Q1KTtcclxuICAgICAgICBtb2xpbmtFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIG1vVGltZWxpbmUucmVwbGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59KSh3aW5kb3csIG1vanMpXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9hbmltYXRpb24uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3MvYXBwLnNjc3M/NTEwNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3MvYXBwLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3MvcHJlbG9hZGVyLnNjc3M/MWVkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3MvcHJlbG9hZGVyLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n");

/***/ })
/******/ ]);